var Tf=Object.create;var ji=Object.defineProperty;var Nf=Object.getOwnPropertyDescriptor;var Cf=Object.getOwnPropertyNames;var Lf=Object.getPrototypeOf,If=Object.prototype.hasOwnProperty;var Pf=(n,r)=>()=>(r||n((r={exports:{}}).exports,r),r.exports),cc=(n,r)=>{for(var e in r)ji(n,e,{get:r[e],enumerable:!0})},uc=(n,r,e,t)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of Cf(r))!If.call(n,o)&&o!==e&&ji(n,o,{get:()=>r[o],enumerable:!(t=Nf(r,o))||t.enumerable});return n};var Af=(n,r,e)=>(e=n!=null?Tf(Lf(n)):{},uc(r||!n||!n.__esModule?ji(e,"default",{value:n,enumerable:!0}):e,n)),Mf=n=>uc(ji({},"__esModule",{value:!0}),n);var Jd=Pf((Ia,Qd)=>{(function(n,r){typeof Ia=="object"&&typeof Qd<"u"?r(Ia):typeof define=="function"&&define.amd?define(["exports"],r):r((n=typeof globalThis<"u"?globalThis:n||self).SVDJS={})})(Ia,function(n){"use strict";n.SVD=function(r,e,t,o,i){if(e=e===void 0||e,t=t===void 0||t,i=1e-64/(o=o||Math.pow(2,-52)),!r)throw new TypeError("Matrix a is not defined");var s,a,l,c,u,m,p,d,f,g,x,y,v=r[0].length,P=r.length;if(P<v)throw new TypeError("Invalid matrix: m < n");for(var S=[],b=[],E=[],w=e==="f"?P:v,h=g=p=0;h<P;h++)b[h]=new Array(w).fill(0);for(h=0;h<v;h++)E[h]=new Array(v).fill(0);var _,N=new Array(v).fill(0);for(h=0;h<P;h++)for(s=0;s<v;s++)b[h][s]=r[h][s];for(h=0;h<v;h++){for(S[h]=p,f=0,l=h+1,s=h;s<P;s++)f+=Math.pow(b[s][h],2);if(f<i)p=0;else for(d=(m=b[h][h])*(p=m<0?Math.sqrt(f):-Math.sqrt(f))-f,b[h][h]=m-p,s=l;s<v;s++){for(f=0,a=h;a<P;a++)f+=b[a][h]*b[a][s];for(m=f/d,a=h;a<P;a++)b[a][s]=b[a][s]+m*b[a][h]}for(N[h]=p,f=0,s=l;s<v;s++)f+=Math.pow(b[h][s],2);if(f<i)p=0;else{for(d=(m=b[h][h+1])*(p=m<0?Math.sqrt(f):-Math.sqrt(f))-f,b[h][h+1]=m-p,s=l;s<v;s++)S[s]=b[h][s]/d;for(s=l;s<P;s++){for(f=0,a=l;a<v;a++)f+=b[s][a]*b[h][a];for(a=l;a<v;a++)b[s][a]=b[s][a]+f*S[a]}}g<(x=Math.abs(N[h])+Math.abs(S[h]))&&(g=x)}if(t)for(h=v-1;0<=h;h--){if(p!==0){for(d=b[h][h+1]*p,s=l;s<v;s++)E[s][h]=b[h][s]/d;for(s=l;s<v;s++){for(f=0,a=l;a<v;a++)f+=b[h][a]*E[a][s];for(a=l;a<v;a++)E[a][s]=E[a][s]+f*E[a][h]}}for(s=l;s<v;s++)E[h][s]=0,E[s][h]=0;E[h][h]=1,p=S[h],l=h}if(e){if(e==="f")for(h=v;h<P;h++){for(s=v;s<P;s++)b[h][s]=0;b[h][h]=1}for(h=v-1;0<=h;h--){for(l=h+1,p=N[h],s=l;s<w;s++)b[h][s]=0;if(p!==0){for(d=b[h][h]*p,s=l;s<w;s++){for(f=0,a=l;a<P;a++)f+=b[a][h]*b[a][s];for(m=f/d,a=h;a<P;a++)b[a][s]=b[a][s]+m*b[a][h]}for(s=h;s<P;s++)b[s][h]=b[s][h]/p}else for(s=h;s<P;s++)b[s][h]=0;b[h][h]=b[h][h]+1}}for(o*=g,a=v-1;0<=a;a--)for(var I=0;I<50;I++){for(_=!1,l=a;0<=l;l--){if(Math.abs(S[l])<=o){_=!0;break}if(Math.abs(N[l-1])<=o)break}if(!_){for(u=0,c=l-(f=1),h=l;h<a+1&&(m=f*S[h],S[h]=u*S[h],!(Math.abs(m)<=o));h++)if(p=N[h],N[h]=Math.sqrt(m*m+p*p),u=p/(d=N[h]),f=-m/d,e)for(s=0;s<P;s++)x=b[s][c],y=b[s][h],b[s][c]=x*u+y*f,b[s][h]=-x*f+y*u}if(y=N[a],l===a){if(y<0&&(N[a]=-y,t))for(s=0;s<v;s++)E[s][a]=-E[s][a];break}for(g=N[l],m=(((x=N[a-1])-y)*(x+y)+((p=S[a-1])-(d=S[a]))*(p+d))/(2*d*x),p=Math.sqrt(m*m+1),m=((g-y)*(g+y)+d*(x/(m<0?m-p:m+p)-d))/g,h=l+(f=u=1);h<a+1;h++){if(p=S[h],x=N[h],d=f*p,p*=u,y=Math.sqrt(m*m+d*d),m=g*(u=m/(S[h-1]=y))+p*(f=d/y),p=-g*f+p*u,d=x*f,x*=u,t)for(s=0;s<v;s++)g=E[s][h-1],y=E[s][h],E[s][h-1]=g*u+y*f,E[s][h]=-g*f+y*u;if(y=Math.sqrt(m*m+d*d),m=(u=m/(N[h-1]=y))*p+(f=d/y)*x,g=-f*p+u*x,e)for(s=0;s<P;s++)x=b[s][h-1],y=b[s][h],b[s][h-1]=x*u+y*f,b[s][h]=-x*f+y*u}S[l]=0,S[a]=m,N[a]=g}for(h=0;h<v;h++)N[h]<o&&(N[h]=0);return{u:b,q:N,v:E}},n.VERSION="1.1.1",Object.defineProperty(n,"__esModule",{value:!0})})});var Yb={};cc(Yb,{default:()=>Pa});module.exports=Mf(Yb);var Aa=require("three");function Oa(n,r){return Object.setPrototypeOf(n,r),n}function pc(n){return Array.isArray(n)?n:[n]}var Of=typeof global=="object"&&global&&global.Object===Object&&global,ki=Of;var _f=typeof self=="object"&&self&&self.Object===Object&&self,Df=ki||_f||Function("return this")(),Xe=Df;var Ef=Xe.Symbol,xt=Ef;var mc=Object.prototype,Bf=mc.hasOwnProperty,Gf=mc.toString,Vn=xt?xt.toStringTag:void 0;function Rf(n){var r=Bf.call(n,Vn),e=n[Vn];try{n[Vn]=void 0;var t=!0}catch{}var o=Gf.call(n);return t&&(r?n[Vn]=e:delete n[Vn]),o}var dc=Rf;var zf=Object.prototype,Vf=zf.toString;function Ff(n){return Vf.call(n)}var fc=Ff;var Uf="[object Null]",jf="[object Undefined]",hc=xt?xt.toStringTag:void 0;function kf(n){return n==null?n===void 0?jf:Uf:hc&&hc in Object(n)?dc(n):fc(n)}var Et=kf;function Hf(n){return n!=null&&typeof n=="object"}var dt=Hf;var Wf="[object Symbol]";function qf(n){return typeof n=="symbol"||dt(n)&&Et(n)==Wf}var Oo=qf;function $f(n,r){for(var e=-1,t=n==null?0:n.length,o=Array(t);++e<t;)o[e]=r(n[e],e,n);return o}var Hi=$f;var Xf=Array.isArray,Ye=Xf;var Yf=1/0,gc=xt?xt.prototype:void 0,yc=gc?gc.toString:void 0;function xc(n){if(typeof n=="string")return n;if(Ye(n))return Hi(n,xc)+"";if(Oo(n))return yc?yc.call(n):"";var r=n+"";return r=="0"&&1/n==-Yf?"-0":r}var vc=xc;function Kf(n){var r=typeof n;return n!=null&&(r=="object"||r=="function")}var ft=Kf;function Qf(n){return n}var Wi=Qf;var Jf="[object AsyncFunction]",Zf="[object Function]",eh="[object GeneratorFunction]",th="[object Proxy]";function rh(n){if(!ft(n))return!1;var r=Et(n);return r==Zf||r==eh||r==Jf||r==th}var _o=rh;var oh=Xe["__core-js_shared__"],qi=oh;var bc=function(){var n=/[^.]+$/.exec(qi&&qi.keys&&qi.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}();function nh(n){return!!bc&&bc in n}var Sc=nh;var ih=Function.prototype,sh=ih.toString;function ah(n){if(n!=null){try{return sh.call(n)}catch{}try{return n+""}catch{}}return""}var Pr=ah;var lh=/[\\^$.*+?()[\]{}|]/g,ch=/^\[object .+?Constructor\]$/,uh=Function.prototype,ph=Object.prototype,mh=uh.toString,dh=ph.hasOwnProperty,fh=RegExp("^"+mh.call(dh).replace(lh,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function hh(n){if(!ft(n)||Sc(n))return!1;var r=_o(n)?fh:ch;return r.test(Pr(n))}var wc=hh;function gh(n,r){return n?.[r]}var Tc=gh;function yh(n,r){var e=Tc(n,r);return wc(e)?e:void 0}var Lt=yh;var xh=Lt(Xe,"WeakMap"),$i=xh;var Nc=Object.create,vh=function(){function n(){}return function(r){if(!ft(r))return{};if(Nc)return Nc(r);n.prototype=r;var e=new n;return n.prototype=void 0,e}}(),Cc=vh;function bh(n,r,e){switch(e.length){case 0:return n.call(r);case 1:return n.call(r,e[0]);case 2:return n.call(r,e[0],e[1]);case 3:return n.call(r,e[0],e[1],e[2])}return n.apply(r,e)}var Lc=bh;function Sh(n,r){var e=-1,t=n.length;for(r||(r=Array(t));++e<t;)r[e]=n[e];return r}var Xi=Sh;var wh=800,Th=16,Nh=Date.now;function Ch(n){var r=0,e=0;return function(){var t=Nh(),o=Th-(t-e);if(e=t,o>0){if(++r>=wh)return arguments[0]}else r=0;return n.apply(void 0,arguments)}}var Ic=Ch;function Lh(n){return function(){return n}}var Pc=Lh;var Ih=function(){try{var n=Lt(Object,"defineProperty");return n({},"",{}),n}catch{}}(),Do=Ih;var Ph=Do?function(n,r){return Do(n,"toString",{configurable:!0,enumerable:!1,value:Pc(r),writable:!0})}:Wi,Ac=Ph;var Ah=Ic(Ac),Yi=Ah;function Mh(n,r){for(var e=-1,t=n==null?0:n.length;++e<t&&r(n[e],e,n)!==!1;);return n}var Mc=Mh;var Oh=9007199254740991,_h=/^(?:0|[1-9]\d*)$/;function Dh(n,r){var e=typeof n;return r=r??Oh,!!r&&(e=="number"||e!="symbol"&&_h.test(n))&&n>-1&&n%1==0&&n<r}var Ki=Dh;function Eh(n,r,e){r=="__proto__"&&Do?Do(n,r,{configurable:!0,enumerable:!0,value:e,writable:!0}):n[r]=e}var Eo=Eh;function Bh(n,r){return n===r||n!==n&&r!==r}var Vr=Bh;var Gh=Object.prototype,Rh=Gh.hasOwnProperty;function zh(n,r,e){var t=n[r];(!(Rh.call(n,r)&&Vr(t,e))||e===void 0&&!(r in n))&&Eo(n,r,e)}var Qi=zh;function Vh(n,r,e,t){var o=!e;e||(e={});for(var i=-1,s=r.length;++i<s;){var a=r[i],l=t?t(e[a],n[a],a,e,n):void 0;l===void 0&&(l=n[a]),o?Eo(e,a,l):Qi(e,a,l)}return e}var Ft=Vh;var Oc=Math.max;function Fh(n,r,e){return r=Oc(r===void 0?n.length-1:r,0),function(){for(var t=arguments,o=-1,i=Oc(t.length-r,0),s=Array(i);++o<i;)s[o]=t[r+o];o=-1;for(var a=Array(r+1);++o<r;)a[o]=t[o];return a[r]=e(s),Lc(n,this,a)}}var Ji=Fh;function Uh(n,r){return Yi(Ji(n,r,Wi),n+"")}var _c=Uh;var jh=9007199254740991;function kh(n){return typeof n=="number"&&n>-1&&n%1==0&&n<=jh}var Zi=kh;function Hh(n){return n!=null&&Zi(n.length)&&!_o(n)}var Fr=Hh;function Wh(n,r,e){if(!ft(e))return!1;var t=typeof r;return(t=="number"?Fr(e)&&Ki(r,e.length):t=="string"&&r in e)?Vr(e[r],n):!1}var Dc=Wh;function qh(n){return _c(function(r,e){var t=-1,o=e.length,i=o>1?e[o-1]:void 0,s=o>2?e[2]:void 0;for(i=n.length>3&&typeof i=="function"?(o--,i):void 0,s&&Dc(e[0],e[1],s)&&(i=o<3?void 0:i,o=1),r=Object(r);++t<o;){var a=e[t];a&&n(r,a,t,i)}return r})}var Ec=qh;var $h=Object.prototype;function Xh(n){var r=n&&n.constructor,e=typeof r=="function"&&r.prototype||$h;return n===e}var Bo=Xh;function Yh(n,r){for(var e=-1,t=Array(n);++e<n;)t[e]=r(e);return t}var Bc=Yh;var Kh="[object Arguments]";function Qh(n){return dt(n)&&Et(n)==Kh}var _a=Qh;var Gc=Object.prototype,Jh=Gc.hasOwnProperty,Zh=Gc.propertyIsEnumerable,eg=_a(function(){return arguments}())?_a:function(n){return dt(n)&&Jh.call(n,"callee")&&!Zh.call(n,"callee")},ao=eg;function tg(){return!1}var Rc=tg;var Fc=typeof exports=="object"&&exports&&!exports.nodeType&&exports,zc=Fc&&typeof module=="object"&&module&&!module.nodeType&&module,rg=zc&&zc.exports===Fc,Vc=rg?Xe.Buffer:void 0,og=Vc?Vc.isBuffer:void 0,ng=og||Rc,Go=ng;var ig="[object Arguments]",sg="[object Array]",ag="[object Boolean]",lg="[object Date]",cg="[object Error]",ug="[object Function]",pg="[object Map]",mg="[object Number]",dg="[object Object]",fg="[object RegExp]",hg="[object Set]",gg="[object String]",yg="[object WeakMap]",xg="[object ArrayBuffer]",vg="[object DataView]",bg="[object Float32Array]",Sg="[object Float64Array]",wg="[object Int8Array]",Tg="[object Int16Array]",Ng="[object Int32Array]",Cg="[object Uint8Array]",Lg="[object Uint8ClampedArray]",Ig="[object Uint16Array]",Pg="[object Uint32Array]",_e={};_e[bg]=_e[Sg]=_e[wg]=_e[Tg]=_e[Ng]=_e[Cg]=_e[Lg]=_e[Ig]=_e[Pg]=!0;_e[ig]=_e[sg]=_e[xg]=_e[ag]=_e[vg]=_e[lg]=_e[cg]=_e[ug]=_e[pg]=_e[mg]=_e[dg]=_e[fg]=_e[hg]=_e[gg]=_e[yg]=!1;function Ag(n){return dt(n)&&Zi(n.length)&&!!_e[Et(n)]}var Uc=Ag;function Mg(n){return function(r){return n(r)}}var Ro=Mg;var jc=typeof exports=="object"&&exports&&!exports.nodeType&&exports,Fn=jc&&typeof module=="object"&&module&&!module.nodeType&&module,Og=Fn&&Fn.exports===jc,Da=Og&&ki.process,_g=function(){try{var n=Fn&&Fn.require&&Fn.require("util").types;return n||Da&&Da.binding&&Da.binding("util")}catch{}}(),Ar=_g;var kc=Ar&&Ar.isTypedArray,Dg=kc?Ro(kc):Uc,es=Dg;var Eg=Object.prototype,Bg=Eg.hasOwnProperty;function Gg(n,r){var e=Ye(n),t=!e&&ao(n),o=!e&&!t&&Go(n),i=!e&&!t&&!o&&es(n),s=e||t||o||i,a=s?Bc(n.length,String):[],l=a.length;for(var c in n)(r||Bg.call(n,c))&&!(s&&(c=="length"||o&&(c=="offset"||c=="parent")||i&&(c=="buffer"||c=="byteLength"||c=="byteOffset")||Ki(c,l)))&&a.push(c);return a}var ts=Gg;function Rg(n,r){return function(e){return n(r(e))}}var rs=Rg;var zg=rs(Object.keys,Object),Hc=zg;var Vg=Object.prototype,Fg=Vg.hasOwnProperty;function Ug(n){if(!Bo(n))return Hc(n);var r=[];for(var e in Object(n))Fg.call(n,e)&&e!="constructor"&&r.push(e);return r}var Wc=Ug;function jg(n){return Fr(n)?ts(n):Wc(n)}var zo=jg;function kg(n){var r=[];if(n!=null)for(var e in Object(n))r.push(e);return r}var qc=kg;var Hg=Object.prototype,Wg=Hg.hasOwnProperty;function qg(n){if(!ft(n))return qc(n);var r=Bo(n),e=[];for(var t in n)t=="constructor"&&(r||!Wg.call(n,t))||e.push(t);return e}var $c=qg;function $g(n){return Fr(n)?ts(n,!0):$c(n)}var ir=$g;var Xg=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Yg=/^\w*$/;function Kg(n,r){if(Ye(n))return!1;var e=typeof n;return e=="number"||e=="symbol"||e=="boolean"||n==null||Oo(n)?!0:Yg.test(n)||!Xg.test(n)||r!=null&&n in Object(r)}var Xc=Kg;var Qg=Lt(Object,"create"),Mr=Qg;function Jg(){this.__data__=Mr?Mr(null):{},this.size=0}var Yc=Jg;function Zg(n){var r=this.has(n)&&delete this.__data__[n];return this.size-=r?1:0,r}var Kc=Zg;var ey="__lodash_hash_undefined__",ty=Object.prototype,ry=ty.hasOwnProperty;function oy(n){var r=this.__data__;if(Mr){var e=r[n];return e===ey?void 0:e}return ry.call(r,n)?r[n]:void 0}var Qc=oy;var ny=Object.prototype,iy=ny.hasOwnProperty;function sy(n){var r=this.__data__;return Mr?r[n]!==void 0:iy.call(r,n)}var Jc=sy;var ay="__lodash_hash_undefined__";function ly(n,r){var e=this.__data__;return this.size+=this.has(n)?0:1,e[n]=Mr&&r===void 0?ay:r,this}var Zc=ly;function Vo(n){var r=-1,e=n==null?0:n.length;for(this.clear();++r<e;){var t=n[r];this.set(t[0],t[1])}}Vo.prototype.clear=Yc;Vo.prototype.delete=Kc;Vo.prototype.get=Qc;Vo.prototype.has=Jc;Vo.prototype.set=Zc;var Ea=Vo;function cy(){this.__data__=[],this.size=0}var eu=cy;function uy(n,r){for(var e=n.length;e--;)if(Vr(n[e][0],r))return e;return-1}var Ur=uy;var py=Array.prototype,my=py.splice;function dy(n){var r=this.__data__,e=Ur(r,n);if(e<0)return!1;var t=r.length-1;return e==t?r.pop():my.call(r,e,1),--this.size,!0}var tu=dy;function fy(n){var r=this.__data__,e=Ur(r,n);return e<0?void 0:r[e][1]}var ru=fy;function hy(n){return Ur(this.__data__,n)>-1}var ou=hy;function gy(n,r){var e=this.__data__,t=Ur(e,n);return t<0?(++this.size,e.push([n,r])):e[t][1]=r,this}var nu=gy;function Fo(n){var r=-1,e=n==null?0:n.length;for(this.clear();++r<e;){var t=n[r];this.set(t[0],t[1])}}Fo.prototype.clear=eu;Fo.prototype.delete=tu;Fo.prototype.get=ru;Fo.prototype.has=ou;Fo.prototype.set=nu;var jr=Fo;var yy=Lt(Xe,"Map"),kr=yy;function xy(){this.size=0,this.__data__={hash:new Ea,map:new(kr||jr),string:new Ea}}var iu=xy;function vy(n){var r=typeof n;return r=="string"||r=="number"||r=="symbol"||r=="boolean"?n!=="__proto__":n===null}var su=vy;function by(n,r){var e=n.__data__;return su(r)?e[typeof r=="string"?"string":"hash"]:e.map}var Hr=by;function Sy(n){var r=Hr(this,n).delete(n);return this.size-=r?1:0,r}var au=Sy;function wy(n){return Hr(this,n).get(n)}var lu=wy;function Ty(n){return Hr(this,n).has(n)}var cu=Ty;function Ny(n,r){var e=Hr(this,n),t=e.size;return e.set(n,r),this.size+=e.size==t?0:1,this}var uu=Ny;function Uo(n){var r=-1,e=n==null?0:n.length;for(this.clear();++r<e;){var t=n[r];this.set(t[0],t[1])}}Uo.prototype.clear=iu;Uo.prototype.delete=au;Uo.prototype.get=lu;Uo.prototype.has=cu;Uo.prototype.set=uu;var Un=Uo;var Cy="Expected a function";function Ba(n,r){if(typeof n!="function"||r!=null&&typeof r!="function")throw new TypeError(Cy);var e=function(){var t=arguments,o=r?r.apply(this,t):t[0],i=e.cache;if(i.has(o))return i.get(o);var s=n.apply(this,t);return e.cache=i.set(o,s)||i,s};return e.cache=new(Ba.Cache||Un),e}Ba.Cache=Un;var pu=Ba;var Ly=500;function Iy(n){var r=pu(n,function(t){return e.size===Ly&&e.clear(),t}),e=r.cache;return r}var mu=Iy;var Py=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Ay=/\\(\\)?/g,My=mu(function(n){var r=[];return n.charCodeAt(0)===46&&r.push(""),n.replace(Py,function(e,t,o,i){r.push(o?i.replace(Ay,"$1"):t||e)}),r}),du=My;function Oy(n){return n==null?"":vc(n)}var fu=Oy;function _y(n,r){return Ye(n)?n:Xc(n,r)?[n]:du(fu(n))}var jo=_y;var Dy=1/0;function Ey(n){if(typeof n=="string"||Oo(n))return n;var r=n+"";return r=="0"&&1/n==-Dy?"-0":r}var os=Ey;function By(n,r){r=jo(r,n);for(var e=0,t=r.length;n!=null&&e<t;)n=n[os(r[e++])];return e&&e==t?n:void 0}var hu=By;function Gy(n,r){for(var e=-1,t=r.length,o=n.length;++e<t;)n[o+e]=r[e];return n}var ko=Gy;var gu=xt?xt.isConcatSpreadable:void 0;function Ry(n){return Ye(n)||ao(n)||!!(gu&&n&&n[gu])}var yu=Ry;function xu(n,r,e,t,o){var i=-1,s=n.length;for(e||(e=yu),o||(o=[]);++i<s;){var a=n[i];r>0&&e(a)?r>1?xu(a,r-1,e,t,o):ko(o,a):t||(o[o.length]=a)}return o}var vu=xu;function zy(n){var r=n==null?0:n.length;return r?vu(n,1):[]}var bu=zy;function Vy(n){return Yi(Ji(n,void 0,bu),n+"")}var Su=Vy;var Fy=rs(Object.getPrototypeOf,Object),Ho=Fy;var Uy="[object Object]",jy=Function.prototype,ky=Object.prototype,wu=jy.toString,Hy=ky.hasOwnProperty,Wy=wu.call(Object);function qy(n){if(!dt(n)||Et(n)!=Uy)return!1;var r=Ho(n);if(r===null)return!0;var e=Hy.call(r,"constructor")&&r.constructor;return typeof e=="function"&&e instanceof e&&wu.call(e)==Wy}var ns=qy;function $y(n,r,e){var t=-1,o=n.length;r<0&&(r=-r>o?0:o+r),e=e>o?o:e,e<0&&(e+=o),o=r>e?0:e-r>>>0,r>>>=0;for(var i=Array(o);++t<o;)i[t]=n[t+r];return i}var Tu=$y;function Xy(){this.__data__=new jr,this.size=0}var Nu=Xy;function Yy(n){var r=this.__data__,e=r.delete(n);return this.size=r.size,e}var Cu=Yy;function Ky(n){return this.__data__.get(n)}var Lu=Ky;function Qy(n){return this.__data__.has(n)}var Iu=Qy;var Jy=200;function Zy(n,r){var e=this.__data__;if(e instanceof jr){var t=e.__data__;if(!kr||t.length<Jy-1)return t.push([n,r]),this.size=++e.size,this;e=this.__data__=new Un(t)}return e.set(n,r),this.size=e.size,this}var Pu=Zy;function Wo(n){var r=this.__data__=new jr(n);this.size=r.size}Wo.prototype.clear=Nu;Wo.prototype.delete=Cu;Wo.prototype.get=Lu;Wo.prototype.has=Iu;Wo.prototype.set=Pu;var is=Wo;function ex(n,r){return n&&Ft(r,zo(r),n)}var Au=ex;function tx(n,r){return n&&Ft(r,ir(r),n)}var Mu=tx;var Eu=typeof exports=="object"&&exports&&!exports.nodeType&&exports,Ou=Eu&&typeof module=="object"&&module&&!module.nodeType&&module,rx=Ou&&Ou.exports===Eu,_u=rx?Xe.Buffer:void 0,Du=_u?_u.allocUnsafe:void 0;function ox(n,r){if(r)return n.slice();var e=n.length,t=Du?Du(e):new n.constructor(e);return n.copy(t),t}var ss=ox;function nx(n,r){for(var e=-1,t=n==null?0:n.length,o=0,i=[];++e<t;){var s=n[e];r(s,e,n)&&(i[o++]=s)}return i}var Bu=nx;function ix(){return[]}var as=ix;var sx=Object.prototype,ax=sx.propertyIsEnumerable,Gu=Object.getOwnPropertySymbols,lx=Gu?function(n){return n==null?[]:(n=Object(n),Bu(Gu(n),function(r){return ax.call(n,r)}))}:as,qo=lx;function cx(n,r){return Ft(n,qo(n),r)}var Ru=cx;var ux=Object.getOwnPropertySymbols,px=ux?function(n){for(var r=[];n;)ko(r,qo(n)),n=Ho(n);return r}:as,ls=px;function mx(n,r){return Ft(n,ls(n),r)}var zu=mx;function dx(n,r,e){var t=r(n);return Ye(n)?t:ko(t,e(n))}var cs=dx;function fx(n){return cs(n,zo,qo)}var Vu=fx;function hx(n){return cs(n,ir,ls)}var us=hx;var gx=Lt(Xe,"DataView"),ps=gx;var yx=Lt(Xe,"Promise"),ms=yx;var xx=Lt(Xe,"Set"),ds=xx;var Fu="[object Map]",vx="[object Object]",Uu="[object Promise]",ju="[object Set]",ku="[object WeakMap]",Hu="[object DataView]",bx=Pr(ps),Sx=Pr(kr),wx=Pr(ms),Tx=Pr(ds),Nx=Pr($i),lo=Et;(ps&&lo(new ps(new ArrayBuffer(1)))!=Hu||kr&&lo(new kr)!=Fu||ms&&lo(ms.resolve())!=Uu||ds&&lo(new ds)!=ju||$i&&lo(new $i)!=ku)&&(lo=function(n){var r=Et(n),e=r==vx?n.constructor:void 0,t=e?Pr(e):"";if(t)switch(t){case bx:return Hu;case Sx:return Fu;case wx:return Uu;case Tx:return ju;case Nx:return ku}return r});var $o=lo;var Cx=Object.prototype,Lx=Cx.hasOwnProperty;function Ix(n){var r=n.length,e=new n.constructor(r);return r&&typeof n[0]=="string"&&Lx.call(n,"index")&&(e.index=n.index,e.input=n.input),e}var Wu=Ix;var Px=Xe.Uint8Array,Ga=Px;function Ax(n){var r=new n.constructor(n.byteLength);return new Ga(r).set(new Ga(n)),r}var Xo=Ax;function Mx(n,r){var e=r?Xo(n.buffer):n.buffer;return new n.constructor(e,n.byteOffset,n.byteLength)}var qu=Mx;var Ox=/\w*$/;function _x(n){var r=new n.constructor(n.source,Ox.exec(n));return r.lastIndex=n.lastIndex,r}var $u=_x;var Xu=xt?xt.prototype:void 0,Yu=Xu?Xu.valueOf:void 0;function Dx(n){return Yu?Object(Yu.call(n)):{}}var Ku=Dx;function Ex(n,r){var e=r?Xo(n.buffer):n.buffer;return new n.constructor(e,n.byteOffset,n.length)}var fs=Ex;var Bx="[object Boolean]",Gx="[object Date]",Rx="[object Map]",zx="[object Number]",Vx="[object RegExp]",Fx="[object Set]",Ux="[object String]",jx="[object Symbol]",kx="[object ArrayBuffer]",Hx="[object DataView]",Wx="[object Float32Array]",qx="[object Float64Array]",$x="[object Int8Array]",Xx="[object Int16Array]",Yx="[object Int32Array]",Kx="[object Uint8Array]",Qx="[object Uint8ClampedArray]",Jx="[object Uint16Array]",Zx="[object Uint32Array]";function e0(n,r,e){var t=n.constructor;switch(r){case kx:return Xo(n);case Bx:case Gx:return new t(+n);case Hx:return qu(n,e);case Wx:case qx:case $x:case Xx:case Yx:case Kx:case Qx:case Jx:case Zx:return fs(n,e);case Rx:return new t;case zx:case Ux:return new t(n);case Vx:return $u(n);case Fx:return new t;case jx:return Ku(n)}}var Qu=e0;function t0(n){return typeof n.constructor=="function"&&!Bo(n)?Cc(Ho(n)):{}}var hs=t0;var r0="[object Map]";function o0(n){return dt(n)&&$o(n)==r0}var Ju=o0;var Zu=Ar&&Ar.isMap,n0=Zu?Ro(Zu):Ju,ep=n0;var i0="[object Set]";function s0(n){return dt(n)&&$o(n)==i0}var tp=s0;var rp=Ar&&Ar.isSet,a0=rp?Ro(rp):tp,op=a0;var l0=1,c0=2,u0=4,np="[object Arguments]",p0="[object Array]",m0="[object Boolean]",d0="[object Date]",f0="[object Error]",ip="[object Function]",h0="[object GeneratorFunction]",g0="[object Map]",y0="[object Number]",sp="[object Object]",x0="[object RegExp]",v0="[object Set]",b0="[object String]",S0="[object Symbol]",w0="[object WeakMap]",T0="[object ArrayBuffer]",N0="[object DataView]",C0="[object Float32Array]",L0="[object Float64Array]",I0="[object Int8Array]",P0="[object Int16Array]",A0="[object Int32Array]",M0="[object Uint8Array]",O0="[object Uint8ClampedArray]",_0="[object Uint16Array]",D0="[object Uint32Array]",Oe={};Oe[np]=Oe[p0]=Oe[T0]=Oe[N0]=Oe[m0]=Oe[d0]=Oe[C0]=Oe[L0]=Oe[I0]=Oe[P0]=Oe[A0]=Oe[g0]=Oe[y0]=Oe[sp]=Oe[x0]=Oe[v0]=Oe[b0]=Oe[S0]=Oe[M0]=Oe[O0]=Oe[_0]=Oe[D0]=!0;Oe[f0]=Oe[ip]=Oe[w0]=!1;function gs(n,r,e,t,o,i){var s,a=r&l0,l=r&c0,c=r&u0;if(e&&(s=o?e(n,t,o,i):e(n)),s!==void 0)return s;if(!ft(n))return n;var u=Ye(n);if(u){if(s=Wu(n),!a)return Xi(n,s)}else{var m=$o(n),p=m==ip||m==h0;if(Go(n))return ss(n,a);if(m==sp||m==np||p&&!o){if(s=l||p?{}:hs(n),!a)return l?zu(n,Mu(s,n)):Ru(n,Au(s,n))}else{if(!Oe[m])return o?n:{};s=Qu(n,m,a)}}i||(i=new is);var d=i.get(n);if(d)return d;i.set(n,s),op(n)?n.forEach(function(x){s.add(gs(x,r,e,x,n,i))}):ep(n)&&n.forEach(function(x,y){s.set(y,gs(x,r,e,y,n,i))});var f=c?l?us:Vu:l?ir:zo,g=u?void 0:f(n);return Mc(g||n,function(x,y){g&&(y=x,x=n[y]),Qi(s,y,gs(x,r,e,y,n,i))}),s}var ys=gs;var E0=1,B0=4;function G0(n){return ys(n,E0|B0)}var jn=G0;function R0(n){return function(r,e,t){for(var o=-1,i=Object(r),s=t(r),a=s.length;a--;){var l=s[n?a:++o];if(e(i[l],l,i)===!1)break}return r}}var ap=R0;var z0=ap(),lp=z0;function V0(n,r,e){(e!==void 0&&!Vr(n[r],e)||e===void 0&&!(r in n))&&Eo(n,r,e)}var kn=V0;function F0(n){return dt(n)&&Fr(n)}var cp=F0;function U0(n,r){if(!(r==="constructor"&&typeof n[r]=="function")&&r!="__proto__")return n[r]}var Hn=U0;function j0(n){return Ft(n,ir(n))}var up=j0;function k0(n,r,e,t,o,i,s){var a=Hn(n,e),l=Hn(r,e),c=s.get(l);if(c){kn(n,e,c);return}var u=i?i(a,l,e+"",n,r,s):void 0,m=u===void 0;if(m){var p=Ye(l),d=!p&&Go(l),f=!p&&!d&&es(l);u=l,p||d||f?Ye(a)?u=a:cp(a)?u=Xi(a):d?(m=!1,u=ss(l,!0)):f?(m=!1,u=fs(l,!0)):u=[]:ns(l)||ao(l)?(u=a,ao(a)?u=up(a):(!ft(a)||_o(a))&&(u=hs(l))):m=!1}m&&(s.set(l,u),o(u,l,t,i,s),s.delete(l)),kn(n,e,u)}var pp=k0;function mp(n,r,e,t,o){n!==r&&lp(r,function(i,s){if(o||(o=new is),ft(i))pp(n,r,s,e,mp,t,o);else{var a=t?t(Hn(n,s),i,s+"",n,r,o):void 0;a===void 0&&(a=i),kn(n,s,a)}},ir)}var dp=mp;function H0(n){var r=n==null?0:n.length;return r?n[r-1]:void 0}var fp=H0;function W0(n,r){return r.length<2?n:hu(n,Tu(r,0,-1))}var hp=W0;var q0=Ec(function(n,r,e){dp(n,r,e)}),co=q0;function $0(n,r){return r=jo(r,n),n=hp(n,r),n==null||delete n[os(fp(r))]}var gp=$0;function X0(n){return ns(n)?void 0:n}var yp=X0;var Y0=1,K0=2,Q0=4,J0=Su(function(n,r){var e={};if(n==null)return e;var t=!1;r=Hi(r,function(i){return i=jo(i,n),t||(t=i.length>1),i}),Ft(n,us(n),e),t&&(e=ys(e,Y0|K0|Q0,yp));for(var o=r.length;o--;)gp(e,r[o]);return e}),Yo=J0;var Ko;(e=>{e.all=["PerspectiveCamera","OrthographicCamera"];function r(t){return e.all.includes(t)}e.is=r})(Ko||(Ko={}));var uo;(o=>{o.DefaultUp=[0,1,0],o.DefaultTargetOffset=1e3,o.defaultData={far:1e5,type:"OrthographicCamera",perspective:{near:5,fov:45,zoom:1},orthographic:{near:-1e5,zoom:1},up:o.DefaultUp,isUpVectorFlipped:!1,targetOffset:o.DefaultTargetOffset};function t(i){return i.type==="PerspectiveCamera"?i.perspective.zoom:i.orthographic.zoom}o.getZoom=t})(uo||(uo={}));var xp;(e=>{function n(t,o){return t[0]===o[0]&&t[1]===o[1]}e.isEqual=n;function r(t,o,i){return[t[0]+(o[0]-t[0])*i,t[1]+(o[1]-t[1])*i]}e.lerp=r})(xp||(xp={}));var Qo;(o=>{function n(i,s){return i[0]===s[0]&&i[1]===s[1]&&i[2]===s[2]}o.isEqual=n;function r(i,s){return[i[0]+s[0],i[1]+s[1],i[2]+s[2]]}o.add=r;function e(i,s){return[i[0]-s[0],i[1]-s[1],i[2]-s[2]]}o.sub=e;function t(i,s,a){return[i[0]+(s[0]-i[0])*a,i[1]+(s[1]-i[1])*a,i[2]+(s[2]-i[2])*a]}o.lerp=t})(Qo||(Qo={}));var vp;(e=>{function n(t,o){return t[0]===o[0]&&t[1]===o[1]&&t[2]===o[2]&&t[3]===o[3]}e.isEqual=n;function r(t,o,i){return[t[0]+(o[0]-t[0])*i,t[1]+(o[1]-t[1])*i,t[2]+(o[2]-t[2])*i,t[3]+(o[3]-t[3])*i]}e.lerp=r})(vp||(vp={}));var Wr;(o=>{o.identity=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];function r(i,s){for(let a=0;a<16;a++)if(i[a]!==s[a])return!1;return!0}o.isEqual=r;function e(i){return i??o.identity}o.simplify=e;function t(i,s){let a=s.slice(0);for(var l=0,c=s.length;l<c;l+=3){let u=i[3]*s[l]+i[7]*s[l+1]+i[11]*s[l+2]+i[15];a[l]=(i[0]*s[l]+i[4]*s[l+1]+i[8]*s[l+2]+i[12])/u,a[l+1]=(i[1]*s[l]+i[5]*s[l+1]+i[9]*s[l+2]+i[13])/u,a[l+2]=(i[2]*s[l]+i[6]*s[l+1]+i[10]*s[l+2]+i[14])/u}return a}o.applyMatrix4=t})(Wr||(Wr={}));var Bt;(l=>{l.white={r:1,g:1,b:1},l.red={r:1,g:0,b:0},l.black={r:0,g:0,b:0};function t(c){return{r:Math.round(c.r*255),g:Math.round(c.g*255),b:Math.round(c.b*255),a:1}}l.toRgb255a1=t;function o(c){return{r:c.r,g:c.g,b:c.b}}l.clone=o;function i(c){return c=Math.floor(c),{r:(c>>16&255)/255,g:(c>>8&255)/255,b:(c&255)/255}}l.fromHex=i;function s(c,u){return c.r===u.r&&c.g===u.g&&c.b===u.b}l.equals=s;function a(c,u,m){return{r:c.r+(u.r-c.r)*m,g:c.g+(u.g-c.g)*m,b:c.b+(u.b-c.b)*m}}l.lerp=a})(Bt||(Bt={}));var Gt;(s=>{s.white={...Bt.white,a:1};function r(a){return{r:a[0],g:a[1],b:a[2],a:a[3]}}s.from0to1=r;function e(a,l){return{...Bt.fromHex(a),a:l}}s.fromHexAndA=e;function t(a){return{r:Math.round(a.r*255),g:Math.round(a.g*255),b:Math.round(a.b*255),a:a.a}}s.toRgb255a1=t;function o(a,l){return Bt.equals(a,l)&&a.a===l.a}s.equals=o;function i(a,l,c){return{r:a.r+(l.r-a.r)*c,g:a.g+(l.g-a.g)*c,b:a.b+(l.b-a.b)*c,a:a.a+(l.a-a.a)*c}}s.lerp=i})(Gt||(Gt={}));var xs;(r=>r.identity={position:[0,0,0],rotation:[0,0,0],scale:[1,1,1]})(xs||(xs={}));var bp;(r=>r.defaultData={mass:1,stiffness:80,damping:10,velocity:0})(bp||(bp={}));var Sp;(r=>r.defaultData={control1:[.5,.05],control2:[.1,.3]})(Sp||(Sp={}));var vs;(r=>{function n(e,t=.1){return{type:"radial",hideBase:!1,count:3,radial:{radius:Math.max(e[0],e[1])*2,start:0,end:360,alignment:!1,axis:"y",scale:[1,1,1],rotation:[0,0,0],position:[0,0,0]},linear:{scale:[1,1,1],rotation:[0,0,0],position:[e[0]+e[0]*t,0,0]},grid:{count:[2,2,2],size:e.map(o=>o*(1+t)),useCenter:!0}}}r.defaultData=n})(vs||(vs={}));var Je=class{modifyById(r,e){let t=this;if(t[r]===void 0)throw new Error("not expected");{let i={...t,[r]:e};return Object.setPrototypeOf(i,Je.prototype),i}}add(r,e){return this.runOp({type:1,id:r,data:e})?.data??this}runOp(r){let e=this;if(r.type===1){let t=e[r.id],o;t===void 0?o={type:2,id:r.id}:o={type:1,id:r.id,data:t};let{id:i,data:s}=r,a={...e,[i]:s};return Object.setPrototypeOf(a,Je.prototype),{data:a,actual:r,reverse:o}}else if(r.type===2){let{id:t}=r,o=e[t];if(o===void 0)return null;{let i={...e};return Object.setPrototypeOf(i,Je.prototype),delete i[t],{data:i,actual:r,reverse:{type:1,id:t,data:o}}}}throw new Error("illegal arg")}};function Wn(n){if(n.deepFreeze!==void 0){n.deepFreeze(n);return}let r=Object.getOwnPropertyNames(n);for(let e of r){let t=n[e];t&&typeof t=="object"&&Wn(t)}return Object.freeze(n)}function wp(n,r){let e=0;for(;e<n.length&&e<r.length;){if(n[e]<r[e])return-1;if(n[e]>r[e])return 1;e+=1}return e!==r.length?-1:e!==n.length?1:0}var bs=class extends Error{};function sr(n,r,e){if(n===void 0?r===void 0?(n=0,r=10):n=r-10:r===void 0&&(r=n+10),n>r){let i=n;n=r,r=i}let t=[],o=1/(e+1);for(let i=0;i<e;i++){let s=n+(r-n)*(i+.75+Math.random()*.5)*o;t.push(s)}return t}function Ss(n){return n instanceof Uint8Array||n instanceof Uint16Array||n instanceof Uint32Array||n instanceof Int8Array||n instanceof Int16Array||n instanceof Int32Array||n instanceof Float32Array||n instanceof Float64Array}function Tp(){return typeof process<"u"}function Np(n,r){for(let e of n)r(e.id,e.data),Np(e.children,r)}function Cp(n,r){r(n.id,n.data);for(let e of n.children)Cp(e,r)}var Ut=class extends Array{constructor(...e){super(...e);Object.setPrototypeOf(this,Ut.prototype)}deepFreeze(){let e=0;for(;e<this.length;)Wn(this[e]),e++}fillCaches0(e,t){this.objCaches.set(e.id,e),this.parentCaches.set(e.id,t);for(let o of e.children)this.fillCaches0(o,e.id)}fillCaches(){if(this.objCaches===void 0){this.objCaches=new Map,this.parentCaches=new Map;for(let e of this)this.fillCaches0(e,null)}}randomId(){this.fillCaches();let e=Array.from(this.objCaches.keys());if(e.length!==0)return e[Math.max(0,Math.floor(Math.random()*e.length)-1)]}isDescendantOf(e,t){for(;e;){let o=this.parent(e);if(o===t)return!0;e=o}return!1}data(e){return this.get(e)?.data}has(e){return this.childrenOf(e)!==void 0}get(e){return this.fillCaches(),this.objCaches.get(e)}childrenOf(e){return e===null?this:this.get(e)?.children}traverseFrom(e,t){if(e===null)this.traverse(t);else{let o=this.get(e);o&&Cp(o,t)}}traverse(e){Np(this,e)}totalSize(){return this.fillCaches(),this.objCaches.size}parent(e){return this.fillCaches(),this.parentCaches.get(e)}childrenArray(e){return e===null?this:this.get(e).children}modifyById(e,t){if(this.get(e)===void 0)throw new Error("not expected");{let i=this.parent(e),s=this.childrenArray(i),a=s.findIndex(u=>u.id===e);if(a<0)throw new Error("not expected");let l=s[a];return s=[...s],s[a]={...l,data:t},this.modifyArrayBy(i,s)}}modifyArrayBy(e,t){let o=e,i=t;for(;o!==null;){let a=i,l=o;if(o=this.parent(o),o===void 0)throw new Error;i=this.childrenArray(o);let c=i.findIndex(u=>u.id===l);if(c<0)throw new Error;i=[...i],i[c]={...i[c],children:a}}Object.setPrototypeOf(i,Ut.prototype);let s=i;return s.fillCaches(),s}runOp(e){switch(e.type){case 7:return this.addOp(e);case 8:return this.deleteOp(e);case 9:return this.moveOp(e)}}checkDuplicatedIdRec({id:e,children:t}){if(this.get(e)!==void 0)return!0;for(let o of t)if(this.checkDuplicatedIdRec(o))return!0;return!1}addOp(e){let{parent:t,fi:o,id:i,data:s,children:a}=e;if(t!==null&&this.get(t)===void 0)return null;if(this.checkDuplicatedIdRec(e))return null;{let l=t,c=this.childrenArray(l),u={fi:o,id:i,data:s,children:a};return c=[...c,u],c.sort((p,d)=>p.fi-d.fi),e.localIndex=c.indexOf(u),{data:this.modifyArrayBy(l,c),actual:e,reverse:{type:8,id:i}}}}deleteOp(e){let{id:t}=e;if(this.get(t)===null)return null;{let o=this.parent(t);if(o===void 0)return null;let i=this.childrenArray(o),s=i.findIndex(c=>c.id===t);e.localIndex=s,i=[...i];let a=i.splice(s,1)[0];return{data:this.modifyArrayBy(o,i),actual:e,reverse:{type:7,...a,parent:o}}}}moveOp(e){let{parent:t,fi:o,id:i}=e;if(t!==null&&this.get(t)===void 0)return this.deleteOp({type:8,id:i});if(t!==null){let d=t;for(;d!==null;){if(d===void 0)throw new Error;if(d===i)throw new bs("cyclic tree");d=this.parent(d)}}let s=this.parent(i);if(s===void 0)return null;let a=s,l=this.childrenArray(s),c=l.findIndex(d=>d.id===i);l=[...l];let u=l.splice(c,1)[0],m=this.modifyArrayBy(s,l);s=t,l=m.childrenArray(s);let p=u.fi;return u={...u,fi:o},l=[...l,u],l.sort((d,f)=>d.fi-f.fi),e.localIndex=l.indexOf(u),m=m.modifyArrayBy(s,l),{data:m,actual:e,reverse:{type:9,parent:a,fi:p,id:i}}}previous(e,t){if(t===null){let i=this.childrenArray(e);return i.length===0?null:i[i.length-1].id}let o=null;for(let i of this.childrenArray(e)){if(i.id===t)return o;o=i.id}return null}traverseSortNext(e){let t=this.parent(e);if(t!==void 0){let o=this.childrenArray(t),i=o.findIndex(s=>s.id===e)+1;if(i<o.length)return o[i].id;if(t)return this.traverseSortNext(t)}}sortNext(e){let t=this.childrenArray(e);return t.length>0?t[0].id:this.traverseSortNext(e)}traverseSortPrevious(e){let t=this.childrenArray(e);return t.length>0?this.traverseSortPrevious(t[t.length-1].id):e}sortPrevious(e){let t=this.parent(e);if(t!==void 0){let o=this.childrenArray(t),i=o.findIndex(s=>s.id===e)-1;return i>=0?this.traverseSortPrevious(o[i].id):t}}getAllSorted(e){let t=[];for(let o of e){let i=this.getWithSortKey(o.id);i!==void 0&&t.push({...o,...i})}t.sort((o,i)=>wp(o.sortKey,i.sortKey));for(let o of t)delete o.sortKey;return t}getWithSortKey(e){var t=e;let o=[],i=this.get(t),s=i;if(i!==void 0){for(;t;)o.splice(0,0,i.fi),t=this.parent(t),t!==null&&(i=this.get(t));return{...s,sortKey:o}}}insertBeforeHelper(e,t,o){return this.insertAfterHelper(e,this.previous(e,t),o)}insertAfterHelper(e,t,o){let i=this.childrenArray(e);if(t===null){if(i.length===0)return sr(0,o,o);{let s=i[0].fi;return sr(s-o,s,o)}}else{let s=this.get(t);if(s===void 0||this.parent(t)!==e)throw new Error("illegal args");let a=i.find(l=>l.fi>s.fi);if(a===void 0){let l=i[i.length-1].fi;return sr(l,l+o,o)}else return sr(s.fi,a.fi,o)}}};var ws;(r=>{function n(e,t){if(Array.isArray(e)){let o=t.props,i={},s=[...e],a=!1;if(o)for(let l of Object.keys(o)){let c=parseInt(l);if(isNaN(c))throw new Error("wrong index");i[l]=s[c],s[c]=o[l],a=!0}return a?{data:s,actual:t,reverse:{type:0,props:i}}:null}else{let o=t.props,i={},s={...e},a=!1;if(o)for(let l of Object.keys(o)){i[l]=s[l];let c=o[l];c===void 0?delete s[l]:s[l]=c,a=!0}return a?{data:s,actual:t,reverse:{type:0,props:i}}:null}}r.runOp=n})(ws||(ws={}));var Ge=class extends Array{constructor(...e){super(...e);Object.setPrototypeOf(this,Ge.prototype)}deepFreeze(){let e=0;for(;e<this.length;)Wn(this[e]),e++}fillCaches0(e){this.objCaches.set(e.id,e)}fillCaches(){if(this.objCaches===void 0){this.objCaches=new Map,Object.getOwnPropertyDescriptor(this,"objCaches").enumerable=!1;for(let e of this)this.fillCaches0(e)}}randomId(){this.fillCaches();let e=Array.from(this.objCaches.keys());if(e.length!==0)return e[Math.max(0,Math.floor(Math.random()*e.length)-1)]}data(e){return this.get(e)?.data}get(e){return this.fillCaches(),this.objCaches.get(e)}modifyById(e,t){if(this.get(e)===void 0)throw new Error("not expected");{let i=this,s=i.findIndex(c=>c.id===e);if(s<0)throw new Error("not expected");let a=i[s];return i=[...i],i[s]={...a,data:t},this.modifyArrayBy(i)}}modifyArrayBy(e){Object.setPrototypeOf(e,Ge.prototype);let t=e;return Tp()||t.fillCaches(),t}runOp(e){switch(e.type){case 4:return this.addOp(e);case 5:return this.deleteOp(e);case 6:return this.moveOp(e)}}addOp(e){let{fi:t,id:o,data:i}=e,s=this,a={fi:t,id:o,data:i};return s=[...s,a],s.sort((c,u)=>c.fi-u.fi),e.localIndex=s.indexOf(a),{data:this.modifyArrayBy(s),actual:e,reverse:{type:5,id:o}}}deleteOp(e){let{id:t}=e,o=this,i=o.findIndex(l=>l.id===t);if(i===-1)return null;e.localIndex=i,o=[...o];let s=o.splice(i,1)[0];return{data:this.modifyArrayBy(o),actual:e,reverse:{type:4,...s}}}moveOp(e){let{fi:t,id:o}=e,i=this;i=[...i];let s=i.findIndex(u=>u.id===o);if(s===-1)return null;let a=i[s].fi,l={...i[s],fi:t};return i[s]=l,i.sort((u,m)=>u.fi-m.fi),e.localIndex=i.indexOf(l),{data:this.modifyArrayBy(i),actual:e,reverse:{type:6,fi:a,id:o}}}previous(e){if(e===null)return this.length===0?null:this[this.length-1].id;let t=null;for(let o of this){if(o.id===e)return t;t=o.id}return null}insertBeforeHelper(e,t){return this.insertAfterHelper(this.previous(e),t)}insertAfterHelper(e,t){let o=this;if(e===null){if(o.length===0)return sr(0,t,t);{let i=o[0].fi;return sr(i-t,i,t)}}else{let i=this.get(e);if(i===void 0)throw new Error("illegal args");let s=o.find(a=>a.fi>i.fi);if(s===void 0){let a=o[o.length-1].fi;return sr(a,a+t,t)}else return sr(i.fi,s.fi,t)}}};var Lp=Symbol(),Ns=Symbol(),Jo=class{reportOp(r,e){let t=this;if(e===null)return;t._current=e.data;let o=[];for(;!(t instanceof Ts);){let i=t._path,s=t._current;if(i!==""&&o.splice(0,0,i),t=t._parent,t===null)return;t.update(i,s)}t.push(o,r,e.actual,e.reverse)}deleteChildren(r){if(this._children){let e=this._children[r];if(e){let t=e[Ns];t&&t(),delete this._children[r]}}}},za=class extends Jo{constructor(r,e,t){super(),this._parent=r,this._path=e,this._current=t}update(r,e){if(Array.isArray(this._current)){if(typeof r=="string"&&(r=parseInt(r),isNaN(r)))throw new Error("Invalid path");this._current=[...this._current],this._current[r]=e}else this._current={...this._current,[r]:e}}runOp(r){this.reportOp(r,ws.runOp(this._current,r))}},Va=class extends Jo{constructor(r,e,t){super(),this._parent=r,this._path=e,this._current=t}update(r,e){this._current={...this._current,[r]:e},Object.setPrototypeOf(this._current,Je.prototype)}runOp(r){this.reportOp(r,this._current.runOp(r))}},Ip={get(n,r){if(r===Ns)return()=>{n._parent=null};if(r===Lp)return n._current;let{_current:e,_children:t}=n;if(r==="push"&&Array.isArray(e))throw new Error("not supported to expand array");let o=t===void 0?void 0:t[r];if(o!==void 0)return o;let i=e[r],s=Cs(n,r,i);return s!==i?(t===void 0&&(t={},n._children=t),t[r]=s,s):i},has(n,r){return r in n._current},ownKeys(n){return Reflect.ownKeys(n._current)},defineProperty(){throw Error("not supported")},getPrototypeOf(n){return Object.getPrototypeOf(n._current)},setPrototypeOf(){throw Error("not supported")},getOwnPropertyDescriptor(n,r){let e=n._current,t=Reflect.getOwnPropertyDescriptor(e,r);return t&&{writable:!0,configurable:!0,enumerable:t.enumerable,value:e[r]}}},Z0={...Ip,set(n,r,e){let t={type:0,props:{[r]:ja(e)??e}};return n.deleteChildren(r),n.runOp(t),!0},deleteProperty(n,r){let e={type:0,props:{[r]:void 0}};return n.deleteChildren(r),n.runOp(e),!0}},ev={...Ip,set(n,r,e){return e===void 0?this.deleteProperty(n,r):(n.deleteChildren(r),n.runOp({type:1,id:r,data:e})),!0},deleteProperty(n,r){return n.runOp({type:2,id:r}),!0}},Zo=class extends Jo{constructor(r,e,t){super(),this._children={},this._parent=r,this._path=e,this._current=t,this[Ns]=()=>{this._parent=null}}unproxy(){return this._current}update(r,e){this._current=this._current.modifyById(r,e)}runOp(r){this.reportOp(r,this._current.runOp(r))}randomId(){return this._current.randomId()}isDescendantOf(r,e){return this._current.isDescendantOf(r,e)}childrenOf(r){return this._current.childrenOf(r)}traverse(r){return this._current.traverse(r)}get(r){return this._current.get(r)}parent(r){return this._current.parent(r)}traverse(r){this._current.traverse((e,t)=>{r(e,this.data(e))})}data(r){let{_current:e,_children:t}=this,o=t===void 0?void 0:t[r];if(o!==void 0)return o;let i=e.get(r)?.data,s=Cs(this,r,i);return s!==i?(t===void 0&&(t={},this._children=t),t[r]=s,s):i}add(r,e,t,o,i){this.runOp({type:7,parent:r,fi:e,id:t,data:o,children:i})}move(r,e,t){this.runOp({type:9,parent:r,fi:e,id:t})}insertAfter(r,e,t){let o=this._current.insertAfterHelper(r,e,t.length);for(let i=0;i<t.length;i++){let s=t[i];this.add(r,o[i],s.id,s.data,s.children)}}insertBefore(r,e,t){let o=this._current.insertBeforeHelper(r,e,t.length);for(let i=0;i<t.length;i++){let s=t[i];this.add(r,o[i],s.id,s.data,s.children)}}moveAfter(r,e,t){let o=this._current.insertAfterHelper(r,e,t.length);for(let i=0;i<t.length;i++){let s=t[i];this.move(r,o[i],s)}}moveBefore(r,e,t){let o=this._current.insertBeforeHelper(r,e,t.length);for(let i=0;i<t.length;i++){let s=t[i];this.move(r,o[i],s)}}delete(r){this.deleteChildren(r),this.runOp({type:8,id:r})}sortNext(r){return this._current.sortNext(r)}sortPrevious(r){return this._current.sortPrevious(r)}getAllSorted(r){return this._current.getAllSorted(r)}},en=class extends Jo{constructor(r,e,t){super(),this._children={},this._parent=r,this._path=e,this._current=t,this[Ns]=()=>{this._parent=null}}unproxy(){return this._current}get length(){return this._current.length}forEach(r){let e=this.length;for(let t=0;t<e;t++){let o=this._current[t].id;r(this.data(this._current[t].id),o)}}update(r,e){this._current=this._current.modifyById(r,e)}randomId(){return this._current.randomId()}get(r){return{...this._current.get(r),data:this.data(r)}}data(r){let{_current:e,_children:t}=this,o=t===void 0?void 0:t[r];if(o!==void 0)return o;let i=e.get(r)?.data,s=Cs(this,r,i);return s!==i?(t===void 0&&(t={},this._children=t),t[r]=s,s):i}runOp(r){this.reportOp(r,this._current.runOp(r))}add(r,e,t){this.runOp({type:4,fi:r,id:e,data:t})}move(r,e){this.runOp({type:6,fi:r,id:e})}insertAfter(r,e){let t=this._current.insertAfterHelper(r,e.length);for(let o=0;o<e.length;o++){let i=e[o];this.add(t[o],i.id,i.data)}}insertBefore(r,e){let t=this._current.insertBeforeHelper(r,e.length);for(let o=0;o<e.length;o++){let i=e[o];this.add(t[o],i.id,i.data)}}moveAfter(r,e){let t=this._current.insertAfterHelper(r,e.length);for(let o=0;o<e.length;o++){let i=e[o];this.move(t[o],i)}}moveBefore(r,e){let t=this._current.insertBeforeHelper(r,e.length);for(let o=0;o<e.length;o++){let i=e[o];this.move(t[o],i)}}delete(r){this.deleteChildren(r),this.runOp({type:5,id:r})}};function Ra(n,r,e){if(n.length>0){let t=n[n.length-1];if(t.type===0&&r.type===0&&Ls.equal(t.path,e)){Object.assign(t.props,r.props);return}}n.push({...r,path:e})}var Ts=class{constructor(r){this.ts=[],this.actual=[],this.reverse=[],this._current=r}update(r,e){if(r!=="")throw new Error("");this._current=e}push(r,e,t,o){Ra(this.ts,e,r),Ra(this.actual,t,r),Ra(this.reverse,o,r)}result(){return{data:this._current,ts:this.ts,actual:this.actual,reverse:this.reverse.reverse()}}};function Cs(n,r,e){return e instanceof Ut?new Zo(n,r,e):e instanceof Ge?new en(n,r,e):e instanceof Je?new Proxy(new Va(n,r,e),ev):e!==null&&typeof e=="object"?Ss(e)?e:new Proxy(new za(n,r,e),Z0):e}function Fa(n){let r=new Ts(n);return[Cs(r,"",n),r]}function Ua(n,r){let[e,t]=Fa(n);return r(e),t.result()}function ja(n){return n instanceof Zo||n instanceof en?n._current:n!==null&&typeof n=="object"?n[Lp]:n}var Ls;(t=>{function n(o,i){if(i.length===o.length)for(var s=0;s<o.length;){if(o[s]!==i[s])return!1;s+=1}else return!1;return!0}t.equal=n;function r(o,i,s){let a=e(s,o);if(a!==void 0&&typeof a=="object"&&a!==null){let l={...i};return Object.keys(a).forEach(c=>{delete l[c]}),l}else return i}t.removeOverridden=r;function e(o,i,s=0){if(i.length<=s)return o;if((o instanceof Ut||o instanceof Zo)&&typeof i[s]=="string")return e(o.data(i[s]),i,s+1);if((o instanceof Ge||o instanceof en)&&typeof i[s]=="string")return e(o.data(i[s]),i,s+1);if(typeof i[s]=="number"&&Array.isArray(o))return e(o[i[s]],i,s+1);if(typeof i[s]=="string"&&typeof o=="object")return e(o[i[s]],i,s+1)}t.zoom=e})(Ls||(Ls={}));var Is=class{},qn=class extends Is{constructor(e){super();this.id=e}},$n=class extends Is{constructor(e){super();this.data=e}};var Ha;try{Ha=new TextDecoder}catch{}var te,$r,T=0;var Bp=[],Wa=Bp,qa=0,It={},Te,qr,jt=0,ar=0,Rt,Or,vt=[],Pe,Pp={useRecords:!1,mapsAsObjects:!0},Xn=class{},Xa=new Xn;Xa.name="MessagePack 0xC1";var tn=!1,lr=class{constructor(r){r&&(r.useRecords===!1&&r.mapsAsObjects===void 0&&(r.mapsAsObjects=!0),r.structures?r.structures.sharedLength=r.structures.length:r.getStructures&&((r.structures=[]).uninitialized=!0,r.structures.sharedLength=0)),Object.assign(this,r)}unpack(r,e){if(te)return Fp(()=>(As(),this?this.unpack(r,e):lr.prototype.unpack.call(Pp,r,e)));$r=e>-1?e:r.length,T=0,qa=0,ar=0,qr=null,Wa=Bp,Rt=null,te=r;try{Pe=r.dataView||(r.dataView=new DataView(r.buffer,r.byteOffset,r.byteLength))}catch(t){throw te=null,r instanceof Uint8Array?t:new Error("Source must be a Uint8Array or Buffer but was a "+(r&&typeof r=="object"?r.constructor.name:typeof r))}if(this instanceof lr){if(It=this,this.structures)return Te=this.structures,Ps();(!Te||Te.length>0)&&(Te=[])}else It=Pp,(!Te||Te.length>0)&&(Te=[]);return Ps()}unpackMultiple(r,e){let t,o=0;try{tn=!0;let i=r.length,s=this?this.unpack(r,i):_s.unpack(r,i);if(e){for(e(s);T<i;)if(o=T,e(Ps())===!1)return}else{for(t=[s];T<i;)o=T,t.push(Ps());return t}}catch(i){throw i.lastPosition=o,i.values=t,i}finally{tn=!1,As()}}_mergeStructures(r,e){r=r||[];for(let t=0,o=r.length;t<o;t++){let i=r[t];i&&(i.isShared=!0,t>=32&&(i.highByte=t-32>>5))}r.sharedLength=r.length;for(let t in e||[])if(t>=0){let o=r[t],i=e[t];i&&(o&&((r.restoreStructures||(r.restoreStructures=[]))[t]=o),r[t]=i)}return this.structures=r}decode(r,e){return this.unpack(r,e)}};function Ps(){try{if(!It.trusted&&!tn){let r=Te.sharedLength||0;r<Te.length&&(Te.length=r)}let n=Ve();if(T==$r)Te.restoreStructures&&Ap(),Te=null,te=null,Or&&(Or=null);else if(T>$r){let r=new Error("Unexpected end of MessagePack data");throw r.incomplete=!0,r}else if(!tn)throw new Error("Data read, but end of buffer not reached");return n}catch(n){throw Te.restoreStructures&&Ap(),As(),(n instanceof RangeError||n.message.startsWith("Unexpected end of buffer"))&&(n.incomplete=!0),n}}function Ap(){for(let n in Te.restoreStructures)Te[n]=Te.restoreStructures[n];Te.restoreStructures=null}function Ve(){let n=te[T++];if(n<160)if(n<128){if(n<64)return n;{let r=Te[n&63]||It.getStructures&&Gp()[n&63];return r?(r.read||(r.read=Ya(r,n&63)),r.read()):n}}else if(n<144)if(n-=128,It.mapsAsObjects){let r={};for(let e=0;e<n;e++)r[zp()]=Ve();return r}else{let r=new Map;for(let e=0;e<n;e++)r.set(Ve(),Ve());return r}else{n-=144;let r=new Array(n);for(let e=0;e<n;e++)r[e]=Ve();return r}else if(n<192){let r=n-160;if(ar>=T)return qr.slice(T-jt,(T+=r)-jt);if(ar==0&&$r<140){let e=r<16?Ka(r):Rp(r);if(e!=null)return e}return $a(r)}else{let r;switch(n){case 192:return null;case 193:return Rt?(r=Ve(),r>0?Rt[1].slice(Rt.position1,Rt.position1+=r):Rt[0].slice(Rt.position0,Rt.position0-=r)):Xa;case 194:return!1;case 195:return!0;case 196:return ka(te[T++]);case 197:return r=Pe.getUint16(T),T+=2,ka(r);case 198:return r=Pe.getUint32(T),T+=4,ka(r);case 199:return po(te[T++]);case 200:return r=Pe.getUint16(T),T+=2,po(r);case 201:return r=Pe.getUint32(T),T+=4,po(r);case 202:if(r=Pe.getFloat32(T),It.useFloat32>2){let e=Os[(te[T]&127)<<1|te[T+1]>>7];return T+=4,(e*r+(r>0?.5:-.5)>>0)/e}return T+=4,r;case 203:return r=Pe.getFloat64(T),T+=8,r;case 204:return te[T++];case 205:return r=Pe.getUint16(T),T+=2,r;case 206:return r=Pe.getUint32(T),T+=4,r;case 207:return It.int64AsNumber?(r=Pe.getUint32(T)*4294967296,r+=Pe.getUint32(T+4)):r=Pe.getBigUint64(T),T+=8,r;case 208:return Pe.getInt8(T++);case 209:return r=Pe.getInt16(T),T+=2,r;case 210:return r=Pe.getInt32(T),T+=4,r;case 211:return It.int64AsNumber?(r=Pe.getInt32(T)*4294967296,r+=Pe.getUint32(T+4)):r=Pe.getBigInt64(T),T+=8,r;case 212:if(r=te[T++],r==114)return Ep(te[T++]&63);{let e=vt[r];if(e)return e.read?(T++,e.read(Ve())):e.noBuffer?(T++,e()):e(te.subarray(T,++T));throw new Error("Unknown extension "+r)}case 213:return r=te[T],r==114?(T++,Ep(te[T++]&63,te[T++])):po(2);case 214:return po(4);case 215:return po(8);case 216:return po(16);case 217:return r=te[T++],ar>=T?qr.slice(T-jt,(T+=r)-jt):rv(r);case 218:return r=Pe.getUint16(T),T+=2,ar>=T?qr.slice(T-jt,(T+=r)-jt):ov(r);case 219:return r=Pe.getUint32(T),T+=4,ar>=T?qr.slice(T-jt,(T+=r)-jt):nv(r);case 220:return r=Pe.getUint16(T),T+=2,Op(r);case 221:return r=Pe.getUint32(T),T+=4,Op(r);case 222:return r=Pe.getUint16(T),T+=2,_p(r);case 223:return r=Pe.getUint32(T),T+=4,_p(r);default:if(n>=224)return n-256;if(n===void 0){let e=new Error("Unexpected end of MessagePack data");throw e.incomplete=!0,e}throw new Error("Unknown MessagePack token "+n)}}}var tv=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;function Ya(n,r){function e(){if(e.count++>2){let o=n.read=new Function("r","return function(){return {"+n.map(i=>tv.test(i)?i+":r()":"["+JSON.stringify(i)+"]:r()").join(",")+"}}")(Ve);return n.highByte===0&&(n.read=Mp(r,n.read)),o()}let t={};for(let o=0,i=n.length;o<i;o++){let s=n[o];t[s]=Ve()}return t}return e.count=0,n.highByte===0?Mp(r,e):e}var Mp=(n,r)=>function(){let e=te[T++];if(e===0)return r();let t=n<32?-(n+(e<<5)):n+(e<<5),o=Te[t]||Gp()[t];if(!o)throw new Error("Record id is not defined for "+t);return o.read||(o.read=Ya(o,n)),o.read()};function Gp(){let n=Fp(()=>(te=null,It.getStructures()));return Te=It._mergeStructures(n,Te)}var $a=Ms,rv=Ms,ov=Ms,nv=Ms;function Ms(n){let r;if(n<16&&(r=Ka(n)))return r;if(n>64&&Ha)return Ha.decode(te.subarray(T,T+=n));let e=T+n,t=[];for(r="";T<e;){let o=te[T++];if((o&128)===0)t.push(o);else if((o&224)===192){let i=te[T++]&63;t.push((o&31)<<6|i)}else if((o&240)===224){let i=te[T++]&63,s=te[T++]&63;t.push((o&31)<<12|i<<6|s)}else if((o&248)===240){let i=te[T++]&63,s=te[T++]&63,a=te[T++]&63,l=(o&7)<<18|i<<12|s<<6|a;l>65535&&(l-=65536,t.push(l>>>10&1023|55296),l=56320|l&1023),t.push(l)}else t.push(o);t.length>=4096&&(r+=it.apply(String,t),t.length=0)}return t.length>0&&(r+=it.apply(String,t)),r}function Op(n){let r=new Array(n);for(let e=0;e<n;e++)r[e]=Ve();return r}function _p(n){if(It.mapsAsObjects){let r={};for(let e=0;e<n;e++)r[zp()]=Ve();return r}else{let r=new Map;for(let e=0;e<n;e++)r.set(Ve(),Ve());return r}}var it=String.fromCharCode;function Rp(n){let r=T,e=new Array(n);for(let t=0;t<n;t++){let o=te[T++];if((o&128)>0){T=r;return}e[t]=o}return it.apply(String,e)}function Ka(n){if(n<4)if(n<2){if(n===0)return"";{let r=te[T++];if((r&128)>1){T-=1;return}return it(r)}}else{let r=te[T++],e=te[T++];if((r&128)>0||(e&128)>0){T-=2;return}if(n<3)return it(r,e);let t=te[T++];if((t&128)>0){T-=3;return}return it(r,e,t)}else{let r=te[T++],e=te[T++],t=te[T++],o=te[T++];if((r&128)>0||(e&128)>0||(t&128)>0||(o&128)>0){T-=4;return}if(n<6){if(n===4)return it(r,e,t,o);{let i=te[T++];if((i&128)>0){T-=5;return}return it(r,e,t,o,i)}}else if(n<8){let i=te[T++],s=te[T++];if((i&128)>0||(s&128)>0){T-=6;return}if(n<7)return it(r,e,t,o,i,s);let a=te[T++];if((a&128)>0){T-=7;return}return it(r,e,t,o,i,s,a)}else{let i=te[T++],s=te[T++],a=te[T++],l=te[T++];if((i&128)>0||(s&128)>0||(a&128)>0||(l&128)>0){T-=8;return}if(n<10){if(n===8)return it(r,e,t,o,i,s,a,l);{let c=te[T++];if((c&128)>0){T-=9;return}return it(r,e,t,o,i,s,a,l,c)}}else if(n<12){let c=te[T++],u=te[T++];if((c&128)>0||(u&128)>0){T-=10;return}if(n<11)return it(r,e,t,o,i,s,a,l,c,u);let m=te[T++];if((m&128)>0){T-=11;return}return it(r,e,t,o,i,s,a,l,c,u,m)}else{let c=te[T++],u=te[T++],m=te[T++],p=te[T++];if((c&128)>0||(u&128)>0||(m&128)>0||(p&128)>0){T-=12;return}if(n<14){if(n===12)return it(r,e,t,o,i,s,a,l,c,u,m,p);{let d=te[T++];if((d&128)>0){T-=13;return}return it(r,e,t,o,i,s,a,l,c,u,m,p,d)}}else{let d=te[T++],f=te[T++];if((d&128)>0||(f&128)>0){T-=14;return}if(n<15)return it(r,e,t,o,i,s,a,l,c,u,m,p,d,f);let g=te[T++];if((g&128)>0){T-=15;return}return it(r,e,t,o,i,s,a,l,c,u,m,p,d,f,g)}}}}}function ka(n){return It.copyBuffers?Uint8Array.prototype.slice.call(te,T,T+=n):te.subarray(T,T+=n)}function po(n){let r=te[T++];if(vt[r])return vt[r](te.subarray(T,T+=n));throw new Error("Unknown extension type "+r)}var Dp=new Array(4096);function zp(){let n=te[T++];if(n>=160&&n<192){if(n=n-160,ar>=T)return qr.slice(T-jt,(T+=n)-jt);if(!(ar==0&&$r<180))return $a(n)}else return T--,Ve();let r=(n<<5^(n>1?Pe.getUint16(T):n>0?te[T]:0))&4095,e=Dp[r],t=T,o=T+n-3,i,s=0;if(e&&e.bytes==n){for(;t<o;){if(i=Pe.getUint32(t),i!=e[s++]){t=1879048192;break}t+=4}for(o+=3;t<o;)if(i=te[t++],i!=e[s++]){t=1879048192;break}if(t===o)return T=t,e.string;o-=3,t=T}for(e=[],Dp[r]=e,e.bytes=n;t<o;)i=Pe.getUint32(t),e.push(i),t+=4;for(o+=3;t<o;)i=te[t++],e.push(i);let a=n<16?Ka(n):Rp(n);return a!=null?e.string=a:e.string=$a(n)}var Ep=(n,r)=>{var e=Ve();let t=n;r!==void 0&&(n=n<32?-((r<<5)+n):(r<<5)+n,e.highByte=r);let o=Te[n];return o&&o.isShared&&((Te.restoreStructures||(Te.restoreStructures=[]))[n]=o),Te[n]=e,e.read=Ya(e,t),e.read()},Vp=typeof self=="object"?self:global;vt[0]=()=>{};vt[0].noBuffer=!0;vt[101]=()=>{let n=Ve();return(Vp[n[0]]||Error)(n[1])};vt[105]=n=>{let r=Pe.getUint32(T-4);Or||(Or=new Map);let e=te[T],t;e>=144&&e<160||e==220||e==221?t=[]:t={};let o={target:t};Or.set(r,o);let i=Ve();return o.used?Object.assign(t,i):(o.target=i,i)};vt[112]=n=>{let r=Pe.getUint32(T-4),e=Or.get(r);return e.used=!0,e.target};vt[115]=()=>new Set(Ve());var Qa=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(n=>n+"Array");vt[116]=n=>{let r=n[0],e=Qa[r];if(!e)throw new Error("Could not find typed array for code "+r);return new Vp[e](Uint8Array.prototype.slice.call(n,1).buffer)};vt[120]=()=>{let n=Ve();return new RegExp(n[0],n[1])};vt[98]=n=>{let r=(n[0]<<24)+(n[1]<<16)+(n[2]<<8)+n[3],e=T;T+=r-4,Rt=[Ve(),Ve()],Rt.position0=0,Rt.position1=0;let t=T;T=e;try{return Ve()}finally{T=t}};vt[255]=n=>n.length==4?new Date((n[0]*16777216+(n[1]<<16)+(n[2]<<8)+n[3])*1e3):n.length==8?new Date(((n[0]<<22)+(n[1]<<14)+(n[2]<<6)+(n[3]>>2))/1e6+((n[3]&3)*4294967296+n[4]*16777216+(n[5]<<16)+(n[6]<<8)+n[7])*1e3):n.length==12?new Date(((n[0]<<24)+(n[1]<<16)+(n[2]<<8)+n[3])/1e6+((n[4]&128?-281474976710656:0)+n[6]*1099511627776+n[7]*4294967296+n[8]*16777216+(n[9]<<16)+(n[10]<<8)+n[11])*1e3):new Date("invalid");function Fp(n){let r=$r,e=T,t=qa,o=jt,i=ar,s=qr,a=Wa,l=Or,c=Rt,u=new Uint8Array(te.slice(0,$r)),m=Te,p=Te.slice(0,Te.length),d=It,f=tn,g=n();return $r=r,T=e,qa=t,jt=o,ar=i,qr=s,Wa=a,Or=l,Rt=c,te=u,tn=f,Te=m,Te.splice(0,Te.length,...p),It=d,Pe=new DataView(te.buffer,te.byteOffset,te.byteLength),g}function As(){te=null,Or=null,Te=null}function Up(n){n.unpack?vt[n.type]=n.unpack:vt[n.type]=n}var Os=new Array(147);for(let n=0;n<256;n++)Os[n]=+("1e"+Math.floor(45.15-n*.30103));var _s=new lr({useRecords:!1}),iv=_s.unpack,sv=_s.unpackMultiple,av=_s.unpack,Ds={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4},lv=new Float32Array(1),LP=new Uint8Array(lv.buffer,0,4);var Es;try{Es=new TextEncoder}catch{}var Bs,Za,Gs=typeof Buffer<"u",Ja=Gs?Buffer.allocUnsafeSlow:Uint8Array,Wp=Gs?Buffer:Uint8Array,jp=Gs?4294967296:2144337920,R,He,C=0,cr,ur=null,cv=/[\u0080-\uFFFF]/,Yn=Symbol("record-id"),mo=class extends lr{constructor(r){super(r),this.offset=0;let e,t,o,i,s,a,l=0,c=Wp.prototype.utf8Write?function(h,_,N){return R.utf8Write(h,_,N)}:Es&&Es.encodeInto?function(h,_){return Es.encodeInto(h,R.subarray(_)).written}:!1,u=this;r||(r={});let m=r&&r.sequential,p=r.structures||r.saveStructures,d=r.maxSharedStructures;if(d==null&&(d=p?32:0),d>8160)throw new Error("Maximum maxSharedStructure is 8160");let f=r.maxOwnStructures;f==null&&(f=p?32:64),m&&!r.saveStructures&&(this.structures=[]);let g=d>32||f+d>64,x=d+64,y=d+f+64;if(y>8256)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let v=[],P=0,S=0;this.pack=this.encode=function(h,_){if(R||(R=new Ja(8192),He=new DataView(R.buffer,0,8192),C=0),cr=R.length-10,cr-C<2048?(R=new Ja(R.length),He=new DataView(R.buffer,0,R.length),cr=R.length-10,C=0):C=C+7&2147483640,t=C,a=u.structuredClone?new Map:null,u.bundleStrings?(ur=["",""],R[C++]=214,R[C++]=98,ur.position=C-t,C+=4):ur=null,o=u.structures,o){o.uninitialized&&(o=u._mergeStructures(u.getStructures()));let N=o.sharedLength||0;if(N>d)throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+o.sharedLength);if(!o.transitions){o.transitions=Object.create(null);for(let I=0;I<N;I++){let L=o[I];if(!L)continue;let A,k=o.transitions;for(let q=0,ne=L.length;q<ne;q++){let ue=L[q];A=k[ue],A||(A=k[ue]=Object.create(null)),k=A}k[Yn]=I+64}l=N}m||(o.nextId=N+64)}i&&(i=!1),s=o||[];try{if(b(h),ur){He.setUint32(ur.position+t,C-ur.position-t);let N=ur;ur=null,b(N[0]),b(N[1])}if(u.offset=C,a&&a.idsToInsert){C+=a.idsToInsert.length*6,C>cr&&w(C),u.offset=C;let N=pv(R.subarray(t,C),a.idsToInsert);return a=null,N}return _&$p?(R.start=t,R.end=C,R):R.subarray(t,C)}finally{if(o){if(S<10&&S++,P>1e4)o.transitions=null,S=0,P=0,v.length>0&&(v=[]);else if(v.length>0&&!m){for(let N=0,I=v.length;N<I;N++)v[N][Yn]=0;v=[]}if(i&&u.saveStructures){let N=o.sharedLength||d;o.length>N&&(o=o.slice(0,N));let I=R.subarray(t,C);return u.saveStructures(o,l)===!1?(u._mergeStructures(u.getStructures()),u.pack(h)):(l=N,I)}}_&xv&&(C=t)}};let b=h=>{C>cr&&(R=w(C));var _=typeof h,N;if(_==="string"){let I=h.length;if(ur&&I>=8&&I<4096){let k=cv.test(h);ur[k?0:1]+=h,R[C++]=193,b(k?-I:I);return}let L;I<32?L=1:I<256?L=2:I<65536?L=3:L=5;let A=I*3;if(C+A>cr&&(R=w(C+A)),I<64||!c){let k,q,ne,ue=C+L;for(k=0;k<I;k++)q=h.charCodeAt(k),q<128?R[ue++]=q:q<2048?(R[ue++]=q>>6|192,R[ue++]=q&63|128):(q&64512)===55296&&((ne=h.charCodeAt(k+1))&64512)===56320?(q=65536+((q&1023)<<10)+(ne&1023),k++,R[ue++]=q>>18|240,R[ue++]=q>>12&63|128,R[ue++]=q>>6&63|128,R[ue++]=q&63|128):(R[ue++]=q>>12|224,R[ue++]=q>>6&63|128,R[ue++]=q&63|128);N=ue-C-L}else N=c(h,C+L,A);N<32?R[C++]=160|N:N<256?(L<2&&R.copyWithin(C+2,C+1,C+1+N),R[C++]=217,R[C++]=N):N<65536?(L<3&&R.copyWithin(C+3,C+2,C+2+N),R[C++]=218,R[C++]=N>>8,R[C++]=N&255):(L<5&&R.copyWithin(C+5,C+3,C+3+N),R[C++]=219,He.setUint32(C,N),C+=4),C+=N}else if(_==="number")if(h>>>0===h)h<64?R[C++]=h:h<256?(R[C++]=204,R[C++]=h):h<65536?(R[C++]=205,R[C++]=h>>8,R[C++]=h&255):(R[C++]=206,He.setUint32(C,h),C+=4);else if(h>>0===h)h>=-32?R[C++]=256+h:h>=-128?(R[C++]=208,R[C++]=h+256):h>=-32768?(R[C++]=209,He.setInt16(C,h),C+=2):(R[C++]=210,He.setInt32(C,h),C+=4);else{let I;if((I=this.useFloat32)>0&&h<4294967296&&h>=-2147483648){R[C++]=202,He.setFloat32(C,h);let L;if(I<4||(L=h*Os[(R[C]&127)<<1|R[C+1]>>7])>>0===L){C+=4;return}else C--}R[C++]=203,He.setFloat64(C,h),C+=8}else if(_==="object")if(!h)R[C++]=192;else{if(a){let L=a.get(h);if(L){if(!L.id){let A=a.idsToInsert||(a.idsToInsert=[]);L.id=A.push(L)}R[C++]=214,R[C++]=112,He.setUint32(C,L.id),C+=4;return}else a.set(h,{offset:C-t})}let I=h.constructor;if(I===Object)E(h,!0);else if(I===Array){N=h.length,N<16?R[C++]=144|N:N<65536?(R[C++]=220,R[C++]=N>>8,R[C++]=N&255):(R[C++]=221,He.setUint32(C,N),C+=4);for(let L=0;L<N;L++)b(h[L])}else if(I===Map){N=h.size,N<16?R[C++]=128|N:N<65536?(R[C++]=222,R[C++]=N>>8,R[C++]=N&255):(R[C++]=223,He.setUint32(C,N),C+=4);for(let[L,A]of h)b(L),b(A)}else{for(let L=0,A=Bs.length;L<A;L++){let k=Za[L];if(h instanceof k){let q=Bs[L];if(q.write){q.type&&(R[C++]=212,R[C++]=q.type,R[C++]=0),b(q.write.call(this,h));return}let ne=R,ue=He,se=C;R=null;let K;try{K=q.pack.call(this,h,U=>(R=ne,ne=null,C+=U,C>cr&&w(C),{target:R,targetView:He,position:C-U}),b)}finally{ne&&(R=ne,He=ue,C=se,cr=R.length-10)}K&&(K.length+C>cr&&w(K.length+C),C=uv(K,R,C,q.type));return}}E(h,!h.hasOwnProperty)}}else if(_==="boolean")R[C++]=h?195:194;else if(_==="bigint"){if(h<BigInt(1)<<BigInt(63)&&h>=-(BigInt(1)<<BigInt(63)))R[C++]=211,He.setBigInt64(C,h);else if(h<BigInt(1)<<BigInt(64)&&h>0)R[C++]=207,He.setBigUint64(C,h);else if(this.largeBigIntToFloat)R[C++]=203,He.setFloat64(C,Number(h));else throw new RangeError(h+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");C+=8}else if(_==="undefined")this.encodeUndefinedAsNil?R[C++]=192:(R[C++]=212,R[C++]=0,R[C++]=0);else if(_==="function")b(this.writeFunction&&this.writeFunction());else throw new Error("Unknown type: "+_)},E=this.useRecords===!1?this.variableMapSize?h=>{let _=Object.keys(h),N=_.length;N<16?R[C++]=128|N:N<65536?(R[C++]=222,R[C++]=N>>8,R[C++]=N&255):(R[C++]=223,He.setUint32(C,N),C+=4);let I;for(let L=0;L<N;L++)b(I=_[L]),b(h[I])}:(h,_)=>{R[C++]=222;let N=C-t;C+=2;let I=0;for(let L in h)(_||h.hasOwnProperty(L))&&(b(L),b(h[L]),I++);R[N+++t]=I>>8,R[N+t]=I&255}:h=>{let _=Object.keys(h),N,I=s.transitions||(s.transitions=Object.create(null)),L=0;for(let k=0,q=_.length;k<q;k++){let ne=_[k];N=I[ne],N||(N=I[ne]=Object.create(null),L++),I=N}let A=I[Yn];if(A)A>=96&&g?(R[C++]=((A-=96)&31)+96,R[C++]=A>>5):R[C++]=A;else{A=s.nextId,A||(A=64),A<x&&this.shouldShareStructure&&!this.shouldShareStructure(_)?(A=s.nextOwnId,A<y||(A=x),s.nextOwnId=A+1):(A>=y&&(A=x),s.nextId=A+1);let k=_.highByte=A>=96&&g?A-96>>5:-1;I[Yn]=A,s[A-64]=_,A<x?(_.isShared=!0,s.sharedLength=A-63,i=!0,k>=0?(R[C++]=(A&31)+96,R[C++]=k):R[C++]=A):(k>=0?(R[C++]=213,R[C++]=114,R[C++]=(A&31)+96,R[C++]=k):(R[C++]=212,R[C++]=114,R[C++]=A),L&&(P+=S*L),v.length>=f&&(v.shift()[Yn]=0),v.push(I),b(_))}for(let k=0,q=_.length;k<q;k++)b(h[_[k]])},w=h=>{let _;if(h>16777216){if(h-t>jp)throw new Error("Packed buffer would be larger than maximum buffer size");_=Math.min(jp,Math.round(Math.max((h-t)*(h>67108864?1.25:2),4194304)/4096)*4096)}else _=(Math.max(h-t<<2,R.length-1)>>12)+1<<12;let N=new Ja(_);return He=new DataView(N.buffer,0,_),R.copy?R.copy(N,0,t,h):N.set(R.slice(t,h)),C-=t,t=0,cr=N.length-10,R=N}}useBuffer(r){R=r,He=new DataView(R.buffer,R.byteOffset,R.byteLength),C=0}};Za=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor,Xn];Bs=[{pack(n,r,e){let t=n.getTime()/1e3;if((this.useTimestamp32||n.getMilliseconds()===0)&&t>=0&&t<4294967296){let{target:o,targetView:i,position:s}=r(6);o[s++]=214,o[s++]=255,i.setUint32(s,t)}else if(t>0&&t<17179869184){let{target:o,targetView:i,position:s}=r(10);o[s++]=215,o[s++]=255,i.setUint32(s,n.getMilliseconds()*4e6+(t/1e3/4294967296>>0)),i.setUint32(s+4,t)}else if(isNaN(t)){if(this.onInvalidDate)return r(0),e(this.onInvalidDate());let{target:o,targetView:i,position:s}=r(3);o[s++]=212,o[s++]=255,o[s++]=255}else{let{target:o,targetView:i,position:s}=r(15);o[s++]=199,o[s++]=12,o[s++]=255,i.setUint32(s,n.getMilliseconds()*1e6),i.setBigInt64(s+4,BigInt(Math.floor(t)))}}},{pack(n,r,e){let t=Array.from(n),{target:o,position:i}=r(this.structuredClone?3:0);this.structuredClone&&(o[i++]=212,o[i++]=115,o[i++]=0),e(t)}},{pack(n,r,e){let{target:t,position:o}=r(this.structuredClone?3:0);this.structuredClone&&(t[o++]=212,t[o++]=101,t[o++]=0),e([n.name,n.message])}},{pack(n,r,e){let{target:t,position:o}=r(this.structuredClone?3:0);this.structuredClone&&(t[o++]=212,t[o++]=120,t[o++]=0),e([n.source,n.flags])}},{pack(n,r){this.structuredClone?kp(n,16,r):Hp(Gs?Buffer.from(n):new Uint8Array(n),r)}},{pack(n,r){let e=n.constructor;e!==Wp&&this.structuredClone?kp(n,Qa.indexOf(e.name),r):Hp(n,r)}},{pack(n,r){let{target:e,position:t}=r(1);e[t]=193}}];function kp(n,r,e,t){let o=n.byteLength;if(o+1<256){var{target:i,position:s}=e(4+o);i[s++]=199,i[s++]=o+1}else if(o+1<65536){var{target:i,position:s}=e(5+o);i[s++]=200,i[s++]=o+1>>8,i[s++]=o+1&255}else{var{target:i,position:s,targetView:a}=e(7+o);i[s++]=201,a.setUint32(s,o+1),s+=4}i[s++]=116,i[s++]=r,i.set(new Uint8Array(n.buffer,n.byteOffset,n.byteLength),s)}function Hp(n,r){let e=n.byteLength;var t,o;if(e<256){var{target:t,position:o}=r(e+2);t[o++]=196,t[o++]=e}else if(e<65536){var{target:t,position:o}=r(e+3);t[o++]=197,t[o++]=e>>8,t[o++]=e&255}else{var{target:t,position:o,targetView:i}=r(e+5);t[o++]=198,i.setUint32(o,e),o+=4}t.set(n,o)}function uv(n,r,e,t){let o=n.length;switch(o){case 1:r[e++]=212;break;case 2:r[e++]=213;break;case 4:r[e++]=214;break;case 8:r[e++]=215;break;case 16:r[e++]=216;break;default:o<256?(r[e++]=199,r[e++]=o):o<65536?(r[e++]=200,r[e++]=o>>8,r[e++]=o&255):(r[e++]=201,r[e++]=o>>24,r[e++]=o>>16&255,r[e++]=o>>8&255,r[e++]=o&255)}return r[e++]=t,r.set(n,e),e+=o,e}function pv(n,r){let e,t=r.length*6,o=n.length-t;for(r.sort((i,s)=>i.offset>s.offset?1:-1);e=r.pop();){let i=e.offset,s=e.id;n.copyWithin(i+t,i,o),t-=6;let a=i+t;n[a++]=214,n[a++]=105,n[a++]=s>>24,n[a++]=s>>16&255,n[a++]=s>>8&255,n[a++]=s&255,o=i}return n}function fo(n){if(n.Class){if(!n.pack&&!n.write)throw new Error("Extension has no pack or write function");if(n.pack&&!n.type)throw new Error("Extension has no type (numeric code to identify the extension)");Za.unshift(n.Class),Bs.unshift(n)}Up(n)}var qp=new mo({useRecords:!1}),mv=qp.pack,dv=qp.pack;var{NEVER:fv,ALWAYS:hv,DECIMAL_ROUND:gv,DECIMAL_FIT:yv}=Ds,$p=512,xv=1024;var Xp=new mo({structuredClone:!0});fo({Class:Je.prototype.constructor,type:1,write(n){return{...n}},read(n){return Object.setPrototypeOf(n,Je.prototype),n}});fo({Class:Ge.prototype.constructor,type:2,write(n){return[...n]},read(n){return Object.setPrototypeOf(n,Ge.prototype),n}});fo({Class:Ut.prototype.constructor,type:3,write(n){return[...n]},read(n){return Object.setPrototypeOf(n,Ut.prototype),n}});fo({Class:qn.prototype.constructor,type:4,write(n){return n.id},read(n){return new qn(n)}});fo({Class:$n.prototype.constructor,type:5,write(n){return n.data},read(n){return new $n(n)}});function vv(n){var r=0;if(n.length===0)return r;for(let e=0;e<n.length;e++){let t=n[e];r=(r<<5)-r+t,r=r&r}return r}function el(n){if(Ss(n))return n;if(Array.isArray(n))return n.map(el);if(typeof n=="object"&&n!==null){let r={};for(let e of Object.keys(n).sort())r[e]=el(n[e]);return Object.setPrototypeOf(r,Object.getPrototypeOf(n)),r}else return n}var Rs;(t=>{function n(o){return Xp.pack(o)}t.serialize=n;function r(o){return Xp.unpack(o)}t.deserialize=r;function e(o){return vv(n(el(o))).toString()}t.checksum=e})(Rs||(Rs={}));var zs;(e=>{e.all=["PointLight","SpotLight","DirectionalLight","HemisphereLight"];function r(t){return e.all.includes(t)}e.is=r})(zs||(zs={}));var Vs;(e=>{function n(t){return r(t)}e.defaultData=n;function r(t){if(t==="PointLight")return{type:t,color:Gt.white,intensity:1,distance:2e3,decay:1,shadows:!0,shadowResolution:1024,shadowRadius:1,depth:1e5,helper:!0};if(t==="SpotLight")return{type:t,color:Gt.white,intensity:1,distance:2e3,decay:1,shadows:!0,penumbra:0,angle:30/180*Math.PI,depth:1e5,helper:!0,shadowResolution:1024,shadowRadius:1};if(t==="DirectionalLight")return{type:t,color:Gt.white,intensity:1,shadows:!0,size:1e3,depth:1e5,shadowResolution:1024,helper:!0,shadowRadius:1};throw new Error("not implemented")}})(Vs||(Vs={}));var tl;(e=>{e.defaultData={castShadow:!0,receiveShadow:!0};function r(t,o){return t.castShadow===o.castShadow&&t.receiveShadow===o.receiveShadow}e.equals=r})(tl||(tl={}));var rl;(e=>{e.defaultData={flatShading:!1,wireframe:!1,side:0};function r(t,o){return t.flatShading===o.flatShading&&t.side===o.side&&t.wireframe===o.wireframe}e.equals=r})(rl||(rl={}));var Fs;(r=>r.defaultData={...rl.defaultData,...tl.defaultData,cloner:null,booleanExclude:null})(Fs||(Fs={}));var ol=(o=>(o[o.Left=1]="Left",o[o.Right=2]="Right",o[o.Center=3]="Center",o[o.Justify=4]="Justify",o))(ol||{}),nl=(t=>(t[t.Top=1]="Top",t[t.Center=2]="Center",t[t.Bottom=3]="Bottom",t))(nl||{}),il=(t=>(t[t.None=1]="None",t[t.Upper=2]="Upper",t[t.Lower=3]="Lower",t))(il||{}),Us;(r=>r.defaultData={width:100,height:100,horizontalAlign:1,verticalAlign:1,fontSize:16,lineHeight:1.5,letterSpacing:1,text:"",textTransform:1,color:Gt.fromHexAndA(6974058,1),alpha:1,font:"roboto_regular"})(Us||(Us={}));var Xr;(t=>{function n(o,i){return o==="light"&&i?r(i):e(o)}t.defaultData=n;function r(o){switch(o){case"basic":return{type:"light",category:"basic",alpha:1,visible:!0,mode:0};case"phong":return{category:"phong",specular:{r:.2,g:.2,b:.2},shininess:10,type:"light",alpha:1,visible:!0,mode:0};case"toon":return{category:"toon",specular:{r:.2,g:.2,b:.2},shininess:10,type:"light",alpha:1,visible:!0,mode:0};case"lambert":return{category:"lambert",emissive:{r:0,g:0,b:0,a:1},type:"light",alpha:1,visible:!0,mode:0};case"physical":return{category:"physical",roughness:.2,metalness:.2,reflectivity:.2,type:"light",alpha:1,visible:!0,mode:0}}}function e(o){switch(o){case"texture":return{alpha:1,visible:!0,size:[128,128],mode:0,axis:"x",side:2,type:"texture",projection:0,texture:{image:"image_0",wrapping:1001,repeat:[1,1],offset:[0,0]},crop:!0};case"color":return{type:"color",alpha:1,visible:!0,mode:0,color:Bt.fromHex(4737101)};case"depth":return{type:"depth",alpha:1,visible:!0,mode:0,gradientType:1,smooth:!1,isVector:!0,isWorldSpace:!1,origin:[0,0,0],direction:[1,0,0],colors:[[1,1,1,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]],steps:[0,1,1,1,1,1,1,1,1,1,1],num:2,near:50,far:200};case"normal":return{type:"normal",alpha:1,visible:!0,mode:0,cnormal:[1,1,1]};case"gradient":return{type:"gradient",alpha:1,visible:!0,mode:0,gradientType:0,smooth:!1,colors:[[0,0,0,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]],steps:[0,1,1,1,1,1,1,1,1,1],num:2,angle:0,offset:[0,0],morph:[0,0]};case"noise":return{type:"noise",alpha:1,visible:!0,mode:0,size:[100,100,100],noiseType:0,scale:1,move:1,colorA:{...Bt.fromHex(6710886),a:1},colorB:{...Bt.fromHex(6710886),a:1},colorC:{...Bt.fromHex(16777215),a:1},colorD:{...Bt.fromHex(16777215),a:1},distortion:[1,1],fA:[1.7,9.2],fB:[8.3,2.8]};case"fresnel":return{type:"fresnel",alpha:1,visible:!0,mode:0,color:Gt.fromHexAndA(16777215,1),bias:.1,scale:1,intensity:2,factor:1};case"rainbow":return{type:"rainbow",alpha:1,visible:!0,mode:0,filmThickness:30,movement:0,wavelengths:[0,0,0],noiseStrength:0,noiseScale:1,offset:[0,0,0]};case"toon":return{type:"toon",alpha:1,visible:!0,mode:0,positioning:2,colors:[[0,0,0,1],[.5,.5,.5,1],[.5,.5,.5,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]],steps:[0,.475,.525,1,1,1,1,1,1,1],num:4,source:[0,1e3,0],isWorldSpace:!0,noiseStrength:0,noiseScale:1,shadowColor:Gt.fromHexAndA(0,0),offset:[0,0,0]};case"outline":return{type:"outline",alpha:1,visible:!0,mode:0,outlineColor:Gt.fromHexAndA(0,1),contourColor:Gt.fromHexAndA(0,1),outlineWidth:2,contourWidth:5,outlineThreshold:.4,contourThreshold:0,outlineSmoothing:0,contourFrequency:10,contourDirection:[0,1,0],positionalLines:!1,compensation:!0};case"matcap":return{type:"matcap",alpha:1,visible:!0,mode:0,texture:{image:"matcap_0",wrapping:1001,repeat:[1,1],offset:[0,0]}};case"transmission":return{type:"transmission",alpha:1,visible:!0,mode:0,thickness:10,ior:1.5,roughness:1};case"displace":return{type:"displace",displacementType:"noise",noiseType:0,scale:10,movement:1,offset:[0,0,0],intensity:8,visible:!0}}}})(Xr||(Xr={}));var _r;(a=>{function n(l){return!l.layers.some(u=>{if(u.data.type==="texture"&&u.data.projection!==0||u.data.type==="depth"&&!u.data.isWorldSpace||u.data.type==="noise"||u.data.type==="displace")return!0})&&!e(l)}a.isMergable=n;function r(l){let c="";return l.layers.forEach(u=>{Object.entries(u.data).forEach(([m,p])=>{c+=`${m}${p}`,Array.isArray(p)?p.forEach(d=>c+=`${d}`):typeof p=="object"?Object.values(p).forEach(d=>{typeof d=="number"?c+=`${d.toFixed(4)}`:c+=`${d}`}):c+=`${p}`})}),c}a.getHash=r;function e(l){let c=0;for(let u of l.layers)"alpha"in u.data&&u.data.type!=="light"&&u.data.type!=="fresnel"&&(c+=(1-c)*u.data.alpha);return c<1}a.isTransparent=e;function t(){return{layers:new Ge}}a.defaultEmptyData=t;function o(l="layer1",c="layer2"){return i("phong",l,c)}a.defaultData=o;function i(l,c="layer1",u="layer2"){let m=new Ge;return m.push({fi:0,data:Xr.defaultData("light",l),id:c}),m.push({fi:1,data:Xr.defaultData("color"),id:u}),{layers:m}}a.defaultTwoLayerData=i;function s(l,c="basic",u="layer1",m="layer2"){let p=Xr.defaultData("texture");Object.assign(p.texture,{image:l});let d=new Ge;return d.push({fi:0,data:p,id:u}),d.push({fi:1,data:Xr.defaultData("light",c),id:m}),{layers:d}}a.defaultTwoLayerTextureData=s})(_r||(_r={}));var rn;(r=>{function n(){return{points:new Ge,roundness:0,shapeHoles:[],isClosed:!1}}r.defaultData=n})(rn||(rn={}));var js;(r=>{function n(e){return e==="PolygonGeometry"||e==="RectangleGeometry"||e==="StarGeometry"||e==="TriangleGeometry"||e==="EllipseGeometry"}r.is2DParametricMesh=n})(js||(js={}));var Kn;(r=>{function n(e){if(e==="RectangleGeometry")return{width:320,height:320,type:e,cornerRadius:[0,0,0,0],cornerType:0,depth:0,extrudeBevelSize:0,extrudeBevelSegments:1};if(e==="VectorGeometry")return{width:1,height:1,type:e,subdivisions:12,shape:rn.defaultData(),depth:0,extrudeBevelSize:0,extrudeBevelSegments:1};if(e==="BooleanGeometry")return{type:e,operation:2,width:0,height:0,depth:0,phongAngle:35};throw new Error("not implemented")}r.defaultData=n})(Kn||(Kn={}));var Qn;(o=>{o.identity={...xs.identity,hiddenMatrix:Wr.identity};function r(i){return{position:i.position,rotation:i.rotation,scale:i.scale,hiddenMatrix:i.hiddenMatrix}}o.fromObject=r;function e(i,s){return{position:s?.position||i.position,rotation:s?.rotation||i.rotation,scale:s?.scale||i.scale,hiddenMatrix:s?.hiddenMatrix||i.hiddenMatrix}}o.merge=e;function t(i,s){return{position:Qo.isEqual(i.position,s.position)?null:s.position,rotation:Qo.isEqual(i.rotation,s.rotation)?null:s.rotation,scale:Qo.isEqual(i.scale,s.scale)?null:s.scale,hiddenMatrix:Wr.isEqual(i.hiddenMatrix,s.hiddenMatrix)?null:s.hiddenMatrix}}o.diff=t})(Qn||(Qn={}));var Dr;(r=>r.defaultData={states:new Ge,events:new Ge,visible:!0,raycastLock:!1,...Qn.identity})(Dr||(Dr={}));var Yp;(r=>r.defaultData={type:"Empty",...Dr.defaultData})(Yp||(Yp={}));var ks;(r=>r.defaultData={type:"Mesh",...Dr.defaultData,...Fs.defaultData})(ks||(ks={}));var Kp;(r=>r.defaultData={type:"TextFrame",...Dr.defaultData,...Us.defaultData})(Kp||(Kp={}));var Hs;(r=>r.defaultData={...Dr.defaultData,...Qn.identity,...uo.defaultData})(Hs||(Hs={}));var Qp;(r=>{function n(e){return{...Dr.defaultData,...Vs.defaultData(e)}}r.defaultData=n})(Qp||(Qp={}));var Jp;(t=>(t.defaultCamera={position:[0,0,1e3],scale:[1,1,1],rotation:[0,0,0],hiddenMatrix:Wr.identity,name:"Play Camera",visible:!0,raycastLock:!1,states:new Ge,events:new Ge,...uo.defaultData},t.defaultMeshObject={name:"Rectangle",...Dr.defaultData,...ks.defaultData,geometry:Kn.defaultData("RectangleGeometry"),material:_r.defaultTwoLayerData("basic","layer1","layer2")},t.defaultBooleanObject={name:"Boolean",...Dr.defaultData,...ks.defaultData,geometry:Kn.defaultData("BooleanGeometry"),material:_r.defaultTwoLayerData("phong","layer1","layer2")}))(Jp||(Jp={}));var Zp;(e=>{function n(t,o){if(o===void 0)return t;let i={...t};return"material"in i&&"material"in o&&o.material&&(i.material=Ua(i.material,s=>{if(typeof s!="string")for(let[a,l]of Object.entries(o.material.layers)){let c=s.layers.data(a);c&&co(c,l)}}).data),i.materials&&o.materials&&(i.materials=Ua(i.materials,s=>{for(let a=0;a<i.materials.length;a++){let l=o.materials[a];if(typeof l!="string")for(let[c,u]of Object.entries(l.layers)){let m=s[a]?.layers?.data(c);m&&co(m,u)}}}).data),i}e.patchMaterialState=n;function r(t,o){if(o===void 0)return t;let i={...t};if(Object.assign(i,Qn.merge(i,o)),Ko.is(t.type)){i.orthographic={...i.orthographic},i.perspective={...i.perspective};let s=o;s.orthographic?.zoom!==void 0&&(i.orthographic.zoom=s.orthographic.zoom),s.perspective?.zoom!==void 0&&(i.perspective.zoom=s.perspective.zoom),s.isUpVectorFlipped!==void 0&&(i.isUpVectorFlipped=s.isUpVectorFlipped),s.targetOffset!==void 0&&(i.targetOffset=s.targetOffset)}else if(t.type==="Mesh")i.geometry={...i.geometry},Object.assign(i.geometry,o.geometry),i=n(i,o);else if(zs.is(t.type)){let s=o;s.intensity!==void 0&&(i.intensity=s.intensity),s.color!==void 0&&(typeof s.color=="string"?i.color=s.color:i.color=Bt.clone(s.color))}return i}e.patch=r})(Zp||(Zp={}));var Ws;(s=>{let n=["/_assets/_textures/texture_checkboard_default.png","/_assets/_textures/texture_dots_01.png","/_assets/_textures/texture_wood_01.jpg","/_assets/_textures/texture_wood_02.jpg","/_assets/_textures/texture_rock_01.jpg","/_assets/_textures/texture_rock_02.jpg","/_assets/_textures/texture_grass_01.jpg","/_assets/_textures/texture_grass_02.jpg","/_assets/_textures/texture_concrete_01.jpg","/_assets/_textures/texture_concrete_02.jpg","/_assets/_textures/texture_paper_01.jpg","/_assets/_textures/texture_roof_01.jpg","/_assets/_textures/texture_wall_02.jpg","/_assets/_textures/texture_planet_earth_color.jpg","/_assets/_textures/texture_planet_earth_clouds.jpg","/_assets/_textures/texture_planet_mars.jpg","/_assets/_textures/texture_space.jpg"],r=["/_assets/_textures/matcap_5_18.png","/_assets/_textures/matcap_5_1.png","/_assets/_textures/matcap_4_3.png","/_assets/_textures/matcap_2_7.png","/_assets/_textures/matcap_2_4.png","/_assets/_textures/matcap_1_11.png"];function e(){let a={},l=0;for(let c of n)a[`image_${l}`]={data:c,name:`Image ${l}`,asset:!1},l++;l=0;for(let c of r)a[`matcap_${l}`]={data:c,name:`Matcap ${l}`,asset:!1},l++;return a}s.defaultImages=e;function t(){let a={};return a["89b10010-844c-11ec-a8a3-0242ac120002"]={r:.5,g:.5,b:.5,a:1,name:"Default Color"},a}s.defaultColors=t;function o(){return{materials:new Je,images:new Je,colors:new Je,penumbraSize:[.5,.5,.5]}}s.emptyData=o;function i(){return{materials:new Je,images:Oa(e(),Je.prototype),colors:Oa(t(),Je.prototype),penumbraSize:new Array(5).fill(.5)}}s.defaultData=i})(Ws||(Ws={}));var qs;(r=>r.emptyImage={data:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=",asset:!1})(qs||(qs={}));var em=require("three"),ut=class extends em.Color{constructor(e,t,o,i){super(e,t,o);this.isColorA=!0;this.a=i}setRGBA(e,t,o,i){super.setRGB(e,t,o),this.a=i}copy(e){return super.copy(e),this.a="a"in e?e.a:1,this}clone(){return new this.constructor(this.r,this.g,this.b,this.a)}get x(){return this.r}get y(){return this.g}get z(){return this.b}get w(){return this.a}set x(e){this.r=e}set y(e){this.g=e}set z(e){this.b=e}set w(e){this.a=e}};var om=require("three");var De=require("three"),rm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,radialSegments:64,heightSegments:1,openEnded:!1,thetaStart:0,thetaLength:360,cornerRadius:0,cornerSegments:8,hollow:0},n.parameters),t=e.width/2,o=e.radiusTop??t,i=e.radiusBottom??t;return o===i?(o=t,i=t):o>i?(o=t,i=i*t/o):(o=o*t/i,i=t),{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??e.width),radiusTop:o,radiusBottom:i})}}static build(n){let{width:r,depth:e,height:t,radialSegments:o,heightSegments:i,openEnded:s,thetaStart:a,thetaLength:l,radiusTop:c,radiusBottom:u,cornerRadius:m,cornerSegments:p,hollow:d}=n.parameters,f;return m||d?f=new Jn(c,u,t,o,i,s,a,l*Math.PI/180,m,m,p,d):f=new De.CylinderBufferGeometry(c,u,t,o,i,s,a,l*Math.PI/180),f.scale(1,1,e/r),Object.assign(f,{userData:{...n,type:"CylinderGeometry"}})}};function Yr(n,r,e){e.x=n.x*r.x,e.y=n.y,e.z=n.x*r.y}function tm(n){return new De.Vector2(n.y,-n.x)}var Jn=class extends De.BufferGeometry{constructor(r,e,t,o,i,s,a,l,c,u,m,p,d=!1){super(),this.type="RoundedCylinderBufferGeometry",r=r!==void 0?r:1,e=e!==void 0?e:1,t=t||1,o=Math.floor(o)||8,i=Math.floor(i)||1,s=s!==void 0?s:!1,a=a!==void 0?a:0,l=l!==void 0?l:Math.PI*2,s&&(c=0,u=0);let f=[],g=[],x=[],y=[],v=0,P=t/2,S=new De.Vector3,b=new De.Vector3;d&&r==0&&(r=c),d&&e==0&&(e=u);let E=new De.Vector2(r,P),w=new De.Vector2(e,-P),h=null,_=null,N=null,I=null,L=E.clone().sub(w),A=0,k=0,q=0;p>0&&(A=Math.min(r,e)*(1-p),k=r-A,q=e-A);let ne=E.clone();ne.x-=A;let ue=Math.PI-L.angle(),se=L.angle(),K=Math.tan(se/2),U=Math.tan(ue/2),z=K+U,B=p?z:U,D=p?z:K;if(c=Math.min(c,(r-k)/B,L.length()/z),u=Math.min(u,(e-q)/D,L.length()/z),c>0){let F=c/K;h=E.clone().sub(new De.Vector2(F,c)),p&&(N=h.clone(),N.x-=A-z*c),E.sub(L.clone().setLength(F))}if(u>0){let F=u/U;_=w.clone().sub(new De.Vector2(F,-u)),w.add(L.clone().setLength(F)),p&&(I=_.clone(),I.x-=A-z*u,ne.sub(L.clone().setLength(F)))}L=E.clone().sub(w);let M=L.length()<.5,G=[];for(let F=0;F<=o;F++){let O=[],$=F/o,Z=$*l+a,ee=new De.Vector2(Math.sin(Z),Math.cos(Z));I&&_?(Q(O,$,ee,ue,u,I,-1,!0),Q(O,$,ee,se,u,_,-1,!1)):_?(j(O,ee,_.x,0,-1),Q(O,$,ee,se,u,_,-1,!1)):s||j(O,ee,e,q,-1);let H=tm(L).normalize();if(Yr(H,ee,S),!M)for(let J=0;J<=i;J++){let X=J/i,re=L.clone().multiplyScalar(X).add(w);Yr(re,ee,b),g.push(b.x,b.y,b.z),x.push(S.x,S.y,S.z),y.push($,.5+b.y/t),O.push(v++)}if(N&&h?(Q(O,$,ee,ue,c,h,1,!1),Q(O,$,ee,se,c,N,1,!0)):h?(Q(O,$,ee,ue,c,h,1,!1),j(O,ee,h.x,0,1)):s||j(O,ee,r,k,1),p&&!M){let J=tm(L).multiplyScalar(-1).normalize();Yr(J,ee,S);for(let X=0;X<=i;X++){let re=X/i,ce=L.clone().multiplyScalar(-re).add(ne);Yr(ce,ee,b),g.push(b.x,b.y,b.z),x.push(S.x,S.y,S.z),y.push($,.5+b.y/t),O.push(v++)}}p&&!s&&O.push(O[0]),G.push(O)}for(let F=0;F<G.length-1;F++)for(let O=0;O<G[0].length-1;O++){if(s&&p&&O==i)continue;let $=G[F][O],Z=G[F+1][O],ee=G[F+1][O+1],H=G[F][O+1],J=g[ee*3+0],X=g[ee*3+2];f.push($,Z,H),(J!=0||X!=0)&&f.push(Z,ee,H)}l<Math.PI*2&&(V(-1,G[0],a),V(1,G[G.length-1],a+l)),this.setIndex(f),this.setAttribute("position",new De.Float32BufferAttribute(g,3)),this.setAttribute("normal",new De.Float32BufferAttribute(x,3)),this.setAttribute("uv",new De.Float32BufferAttribute(y,2));function Q(F,O,$,Z,ee,H,J,X){for(let re=0;re<m+1;re++){let ce=re/m,ie=J<0?ce:1-ce;X&&(ie-=1),ie*=Z;let fe=new De.Vector2(Math.sin(ie),Math.cos(ie)*J),ze=fe.clone().multiplyScalar(ee).add(H);Yr(ze,$,b),g.push(b.x,b.y,b.z),Yr(fe,$,S),x.push(S.x,S.y,S.z),y.push(O,.5+b.y/t),F.push(v++)}}function j(F,O,$,Z,ee){let H=new De.Vector3,J=new De.Vector2,X=[$,Z];ee<0&&X.reverse();for(let re of X)J.set(re,P*ee),Yr(J,O,H),g.push(H.x,H.y,H.z),x.push(0,ee,0),y.push(.5,.5),F.push(v++)}function V(F,O,$){let Z=new De.Vector2(Math.sin($),Math.cos($)),ee=new De.Vector2(-Math.cos($),Math.sin($)),H=new De.Vector3,J=F<0?(ce,ie,fe)=>f.push(ce,ie,fe):(ce,ie,fe)=>f.push(ce,fe,ie),X=new De.Vector2((r+e+k+q)/4,0);Yr(X,Z,H),g.push(H.x,H.y,H.z),x.push(ee.x,0,ee.y),y.push(.5,.5);let re=v++;for(let ce of O){let ie=g.slice(ce*3,ce*3+3);g.push(...ie),x.push(ee.x,0,ee.y);let fe=y.slice(ce*2,ce*2+2);y.push(...fe),v++}for(let ce=re+1;ce<v-1;ce++)J(re,ce,ce+1);J(re,v-1,re+1)}}};var nm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,radialSegments:32,heightSegments:8,openEnded:!1,thetaStart:0,thetaLength:360,cornerRadiusTop:0,cornerRadiusBottom:0,cornerSegments:8},n.parameters);return{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??e.width)})}}static build(n){let{width:r,depth:e,height:t,radialSegments:o,heightSegments:i,openEnded:s,thetaStart:a,thetaLength:l,cornerRadiusTop:c,cornerRadiusBottom:u,cornerSegments:m}=n.parameters,p;return c>0||u>0||l<360?p=new Jn(0,r/2,t,o,i,s,a,l*Math.PI/180,c,u,m,0,!0):p=new om.ConeBufferGeometry(r/2,t,o,i,s),p.scale(1,1,e/r),Object.assign(p,{userData:{...n,type:"ConeGeometry"}})}};var Pt=require("three"),im=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,widthSegments:1,heightSegments:1,depthSegments:1,cornerRadius:0,cornerSegments:8},n.parameters);return{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??e.width)})}}static build(n){let{width:r,height:e,depth:t,widthSegments:o,heightSegments:i,depthSegments:s,cornerRadius:a,cornerSegments:l}=n.parameters,c;return a==0?c=new Pt.BoxBufferGeometry(r,e,t,o,i,s):c=new al(r,e,t,o,i,s,a,l),Object.assign(c,{userData:{...n,type:"CubeGeometry"}})}},sl=Math.PI/2,al=class extends Pt.BufferGeometry{constructor(r=1,e=1,t=1,o=1,i=1,s=1,a=0,l=4){super(),this.type="BoxBufferGeometry";let c=this;o=Math.floor(o),i=Math.floor(i),s=Math.floor(s),l=Math.floor(l),a=Math.min(a,r/2,e/2,t/2);let u=[],m=[],p=[],d=[],f=0,g=0;x("z","y","x",-1,-1,t,e,r,s,i,0),x("z","y","x",1,-1,t,e,-r,s,i,1),x("x","z","y",1,1,r,t,e,o,s,2),x("x","z","y",1,-1,r,t,-e,o,s,3),x("x","y","z",1,-1,r,e,t,o,i,4),x("x","y","z",-1,-1,r,e,-t,o,i,5),a>0&&(y("z","y","x",-1,-1,1,t,e,r,s,0),y("z","y","x",1,-1,-1,t,e,r,s,1),y("z","y","x",-1,1,-1,t,e,r,s,1),y("z","y","x",1,1,1,t,e,r,s,0),y("x","y","z",-1,-1,-1,r,e,t,o,0),y("x","y","z",1,-1,1,r,e,t,o,1),y("x","y","z",-1,1,1,r,e,t,o,0),y("x","y","z",1,1,-1,r,e,t,o,1),y("y","x","z",-1,-1,1,e,r,t,i,0),y("y","x","z",1,-1,-1,e,r,t,i,1),y("y","x","z",1,1,1,e,r,t,i,1),y("y","x","z",-1,1,-1,e,r,t,i,0),v(1,1,1),v(-1,1,1),v(1,-1,1),v(-1,-1,1),v(1,1,-1),v(-1,1,-1),v(1,-1,-1),v(-1,-1,-1)),this.setIndex(u),this.setAttribute("position",new Pt.Float32BufferAttribute(m,3)),this.setAttribute("normal",new Pt.Float32BufferAttribute(p,3)),this.setAttribute("uv",new Pt.Float32BufferAttribute(d,2));function x(P,S,b,E,w,h,_,N,I,L,A){let k=(h-2*a)/I,q=(_-2*a)/L,ne=h/2-a,ue=_/2-a,se=N/2,K=I+1,U=L+1,z=0,B=0,D=new Pt.Vector3;for(let M=0;M<U;M++){let G=M*q-ue;for(let Q=0;Q<K;Q++){let j=Q*k-ne;D[P]=j*E,D[S]=G*w,D[b]=se,m.push(D.x,D.y,D.z),D[P]=0,D[S]=0,D[b]=N>0?1:-1,p.push(D.x,D.y,D.z),d.push(Q/I),d.push(1-M/L),z+=1}}for(let M=0;M<L;M++)for(let G=0;G<I;G++){let Q=f+G+K*M,j=f+G+K*(M+1),V=f+(G+1)+K*(M+1),F=f+(G+1)+K*M;u.push(Q,j,F),u.push(j,V,F),B+=6}c.addGroup(g,B,A),g+=B,f+=z}function y(P,S,b,E,w,h,_,N,I,L,A){let k=(_-2*a)/L,q=_/2-a,ne=N/2-a,ue=I/2,se=L+1,K=0,U=0,z=new Pt.Vector3,B=new Pt.Vector3;for(let D=0;D<l+1;D++){let M=D/l*sl,G=Math.sin(M)*a,Q=(1-Math.cos(M))*a,j=Math.sin(M),V=Math.cos(M);z[S]=(ne+G)*w,z[b]=(ue-Q)*h,B[P]=0,B[S]=j*Math.sign(z[S]),B[b]=V*Math.sign(z[b]);for(let F=0;F<se;F++){let O=F*k-q;z[P]=O*E,m.push(z.x,z.y,z.z),p.push(B.x,B.y,B.z),d.push(F/L),d.push(0),K+=1}}for(let D=0;D<l;D++)for(let M=0;M<L;M++){let G=f+M+se*D,Q=f+M+se*(D+1),j=f+(M+1)+se*(D+1),V=f+(M+1)+se*D;u.push(G,Q,V),u.push(Q,j,V),U+=6}c.addGroup(g,U,A),g+=U,f+=K}function v(P,S,b){let E=new Pt.Vector3,w=new Pt.Vector3(r/2,e/2,t/2);w.subScalar(a);let h=[],_=P*S*b>0?(I,L,A)=>u.push(I,L,A):(I,L,A)=>u.push(I,A,L);for(let I=0;I<=l;I++){let L=[],A=sl*(1-I/l),k=Math.cos(A),q=Math.sin(A),ne=0;for(let ue=0;ue<=I;ue++){let se=Math.cos(ne),K=Math.sin(ne);E.x=k*se,E.y=q,E.z=k*K;let U=w.clone().addScaledVector(E,a);m.push(P*U.x,S*U.y,b*U.z),p.push(P*E.x,S*E.y,b*E.z),d.push(0,0),L.push(f++),ne+=sl/I}h.push(L)}let N=h.length-1;for(let I=0;I<N;I++){let L=h[I],A=h[I+1],k=L.length-1;_(L[0],A[1],A[0]);for(let q=1;q<=k;q++)_(L[q-1],L[q],A[q]),_(L[q],A[q+1],A[q])}}}};var Fe=require("three"),Kr=class extends Fe.BufferGeometry{constructor(r=[],e=[],t="",o=1,i=.2,s=4){super(),this.type="PolyhedronGeometryRound";let a=[],l=[],c=[];u(),m(),this.setAttribute("position",new Fe.Float32BufferAttribute(a,3)),this.setAttribute("normal",new Fe.Float32BufferAttribute(c,3)),this.setAttribute("uv",new Fe.Float32BufferAttribute(l,2));return;function u(){i=Math.min(1-1e-5,i),i==0&&(s=0);let d={IcosahedronGeometry:5,DodecahedronGeometry:3,HexahedronGeometry:3,OctahedronGeometry:4,TetrahedronGeometry:3}[t],f=new Fe.Vector3,g=f.clone(),x=new Fe.Triangle,y=i*o,v=o-y,P=s+1,S=new Fe.Vector3,b=(K,U)=>S.subVectors(K,U).normalize(),E=(K,U)=>Array(K).fill(void 0).map(U),w=E(r.length/3,(K,U)=>new Fe.Vector3().fromArray(r,U*3).setLength(o)),h=[],_=1e6;for(let K=0;K<w.length;K++){let U=w[K],z=[],B,D,M,G=1e10,Q=-1;for(;(Q=e.indexOf(K,Q+1))!=-1;){let O=Q-Q%3;B=e[O+(Q+1)%3],D=e[O+(Q+2)%3],M=U.distanceToSquared(w[B]),G=Math.min(G,M),z.push([B,D,M])}G+=1e-6;let j=[],V=0,F=z.length;for(let O=0;O<F;O++){[B,D,M]=z[V];let $=h[B]?.includes(K)==!0;M<=G&&j.push(B+ +$*_),V=z.findIndex(Z=>Z[0]==D)}h.push(j)}let N=[];{let K=0,U=0,z,B,D=d==3;for(let M=0;M<=s;M++){z=M*(M+1)/2,B=(M+1)*(M+2)/2;for(let G=0;G<s-M;G++)[K,U]=[z+G+M+2,B+G+M+3],N.push(z,B,...D?[U,z]:[K,B],U,K),[z,B]=[K,U];N.push(z,B,z+s+2)}}let I=f.clone(),L=f.clone(),A=f.clone(),k=f.clone(),q=f.clone(),ne=[],ue=E(w.length,()=>E(d,()=>f.clone()));for(let K=0;K<w.length;K++){f.copy(w[K]).normalize(),I.copy(f).multiplyScalar(v);let U=h[K];for(let j=0;j<U.length;j++){let V=U[j],F=U[(j+1)%d];x.setFromPointsAndIndices(w,K,V%_,F%_),x.b.sub(x.a).setLength(1e10).add(x.a),x.c.sub(x.a).setLength(1e10).add(x.a),x.closestPointToPoint(I,ue[K][j])}let z=[],B=[],D=[],M=new Fe.Vector3;s==0&&[...ue[K]].reduce((j,V)=>j.add(V),M).multiplyScalar(1/d);for(let j=0;j<d;j++){let V=[],F=(j-1+d)%d,O=ue[K][F],$=ue[K][j];f.copy(O).sub(I),g.copy($).sub(I);let Z=I.angleTo(f),ee=f.angleTo(g),H=Math.cos(Z)*y;s==0?L.copy(M):L.copy(I).setLength(v+H),B.push(H);let J=[L,O,$];for(let X=0;X<2;X++){let re=J[X],ce=J[X+1];k.subVectors(re,I),q.subVectors(ce,I),A.crossVectors(k,q).normalize();for(let ie=0;ie<P;ie++){let fe=[Z,ee][X]*ie/P;f.copy(k).applyAxisAngle(A,fe).add(I),z.push(f.clone()),X&&(b(f,I),V.push([ie==0?re:f.clone(),S.clone()]))}X&&(b(ce,I),V.push([ce,S.clone()]))}D.push(V)}ne.push(D);let G=2*P,Q=2;for(let j=0;j<d;j++){let V=G*j,F=G*((j+1)%d),O=[z[V]];for(let Z=1;Z<P;Z++){k=z[V+Z],q=z[F+Z],O.push(k);for(let ee=1,H=Z-Q+1;ee<=H;ee++)f.lerpVectors(k,q,ee/(H+1)),f.sub(I).setLength(B[j]).add(I),O.push(f.clone());O.push(q)}for(let Z=0;Z<P;Z++)O.push(z[Z+P+V]);O.push(z[F+P]);let $=N.map(Z=>O[Z]);a.push(...$.map(Z=>[Z.x,Z.y,Z.z]).flat()),c.push(...$.map(Z=>(b(Z,I),[S.x,S.y,S.z])).flat())}}let se=[];for(let K=0;K<h.length;K++)for(let U=0;U<d;U++){let z=h[K][U];if(z<_){let B=h[z].findIndex(G=>G%_==K),D=ne[K][U],M=ne[z][B];for(let G=0;G<P;G++){let Q=D[G],j=M[P-G],V=D[G+1],F=M[P-(G+1)];[Q,j,V,V,j,F].forEach(O=>{a.push(O[0].x,O[0].y,O[0].z),c.push(O[1].x,O[1].y,O[1].z)})}se.push(D[0][0],M[P][0],D[P][0],M[0][0])}}for(;se.length;){let K,U,z,B;[K,U]=se.splice(0,2);let D=[K];for(;K!=U;)D.push(U),z=se.indexOf(U),B=z%2,U=se.splice(z-B,2)[1-B];S.subVectors(D[0],D[1]).cross(f.subVectors(D[0],D[2])).normalize();let M=S.dot(D[0])<0;M&&S.negate();for(let G=1;G<=D.length-2;G++)[D[G+ +M],D[G+1-+M],D[0]].forEach(Q=>{a.push(Q.x,Q.y,Q.z),c.push(S.x,S.y,S.z)})}}function m(){let p=new Fe.Vector3;for(let w=0;w<a.length;w+=3){p.x=a[w+0],p.y=a[w+1],p.z=a[w+2];let h=b(p)/2/Math.PI+.5,_=E(p)/Math.PI+.5;l.push(h,1-_)}let d=new Fe.Vector3,f=new Fe.Vector3,g=new Fe.Vector3,x=new Fe.Vector3,y=new Fe.Vector2,v=new Fe.Vector2,P=new Fe.Vector2,S=(w,h,_,N)=>{N<0&&w.x===1&&(l[h]=w.x-1),_.x===0&&_.z===0&&(l[h]=N/2/Math.PI+.5)};for(let w=0,h=0;w<a.length;w+=9,h+=6){d.set(a[w+0],a[w+1],a[w+2]),f.set(a[w+3],a[w+4],a[w+5]),g.set(a[w+6],a[w+7],a[w+8]),y.set(l[h+0],l[h+1]),v.set(l[h+2],l[h+3]),P.set(l[h+4],l[h+5]),x.copy(d).add(f).add(g).divideScalar(3);let _=b(x);S(y,h+0,d,_),S(v,h+2,f,_),S(P,h+4,g,_)}for(let w=0;w<l.length;w+=6){let h=l[w+0],_=l[w+2],N=l[w+4],I=Math.max(h,_,N),L=Math.min(h,_,N);I>.9&&L<.1&&(h<.2&&(l[w+0]+=1),_<.2&&(l[w+2]+=1),N<.2&&(l[w+4]+=1))}function b(w){return Math.atan2(w.z,-w.x)}function E(w){return Math.atan2(-w.y,Math.sqrt(w.x*w.x+w.z*w.z))}}}static fromJSON(r){return new Kr(r.vertices,r.indices,r.radius,r.corner,r.cornerSides)}};var sm=require("three"),am=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,detail:0,corner:0,cornerSides:4},n.parameters);return{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??e.width)})}}static build(n){let{width:r,height:e,depth:t,detail:o,corner:i,cornerSides:s}=n.parameters,a=o===0&&i!==0?new Zn(r*.5,i,s):new sm.DodecahedronBufferGeometry(r*.5,o);return a.scale(1,e/r,t/r),Object.assign(a,{userData:{...n,type:"DodecahedronGeometry"}})}},Zn=class extends Kr{constructor(r=1,e=.2,t=4){let o=(1+Math.sqrt(5))/2,i=1/o,s=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-o,0,-i,o,0,i,-o,0,i,o,-i,-o,0,-i,o,0,i,-o,0,i,o,0,-o,0,-i,o,0,-i,-o,0,i,o,0,i],a=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],l="DodecahedronGeometry";super(s,a,l,r,e,t),this.type=l}static fromJSON(r){return new Zn(r.radius,r.corner,r.cornerSides)}};var Se=require("three");var he=require("three"),ei=1e-12,on=class{constructor(r){this.position=new he.Vector2;this.startPosition=new he.Vector2;this.uuid=he.MathUtils.generateUUID();this.position=r.clone()}start(){this.reset()}reset(){this.startPosition.copy(this.position)}applyOffset(r){this.position.copy(this.startPosition).add(r)}copy(r){return this.position.copy(r.position),this.startPosition.copy(r.startPosition),this}clone(){return new on(this.position).copy(this)}toJSON(){return[this.position.x,this.position.y]}},nn=class extends on{constructor(e){super(e.position);this.parent=e}copy(e){return super.copy(e),this}clone(){return new nn(this.parent).copy(this)}},Xt=class extends on{constructor(e,t){super(t);this.controls=[];this.roundness=0;this.areControlsDirectionsMirrored=!0;this.uuid=e,this.controls.push(new nn(this),new nn(this))}static create(e,t){let o=new Xt(e,new he.Vector2(...t.position));return o.controls[0].position.set(...t.controlPrevious.position),o.controls[1].position.set(...t.controlNext.position),o.roundness=t.roundness,o.areControlsDirectionsMirrored=t.areControlsDirectionsMirrored,o}getOppositeControl(e){let t=this.controls.indexOf(e);return t===0?this.controls[1]:t===1?this.controls[0]:null}applyOffsetToControls(e,t=1){for(let o=0,i=this.controls.length;o<i;o++){let s=this.controls[o];this.position.distanceTo(s.position)<=t?s.position.copy(this.position):s.applyOffset(e)}}controlsMoved(){return!(this.position.equals(this.controls[0].position)&&this.position.equals(this.controls[1].position))}copy(e){return super.copy(e),this.controls[0].copy(e.controls[0]),this.controls[1].copy(e.controls[1]),this.roundness=e.roundness,this.uuid=e.uuid,this}clone(){return new Xt(this.uuid,this.position).copy(this)}toJSON(){return super.toJSON().concat(this.controls[0].toJSON(),this.controls[1].toJSON(),[this.roundness])}computeTangents(){let e=this.curveBefore?.getTangentAt(1),t=this.curveAfter?.getTangentAt(0);return[e,t]}computeNormals(e=new he.Vector2,t=new he.Vector2){let[o,i]=this.computeTangents();return o&&i&&(lm(o,e),lm(i,t)),[e,t]}computeTangent(e=new he.Vector2){let[t,o]=this.computeTangents();return t&&o&&e.copy(t).add(o).normalize(),e}computeNormal(e=new he.Vector2){let[t,o]=this.computeNormals();return e.copy(t).add(o).normalize(),e}};function lm(n,r=new he.Vector2){let e=n.length();return r.set(-n.y/e,n.x/e)}var cl=n=>n,sn=new he.Vector2,$s=new he.Vector2,bv=new he.Vector2,Sv=new he.Vector2,wv=new he.Vector2,Tv=new he.Vector2,um=new he.Vector3,pm=new he.Vector3;function mm(n){let r=new he.Vector2;r.addVectors(n.v0,sn.subVectors(n.v1,n.v0).multiplyScalar(2/3));let e=new he.Vector2;return e.addVectors(n.v2,$s.subVectors(n.v1,n.v2).multiplyScalar(2/3)),new he.CubicBezierCurve(n.v0,r,e,n.v2)}function ti(n,r,e=Number.EPSILON){return Math.abs(n-r)<e}function Nv(n,r,e=Number.EPSILON){return n.distanceTo(r)<e}function Cv(n,r,e=Number.EPSILON){return n.distanceTo(r)<e}function ul(n,r,e){let t=Math.sqrt(Math.pow(r.x-n.x,2)+Math.pow(r.y-n.y,2)),o=Math.sqrt(Math.pow(r.x-e.x,2)+Math.pow(r.y-e.y,2)),i=Math.sqrt(Math.pow(e.x-n.x,2)+Math.pow(e.y-n.y,2));return Math.acos((o*o+t*t-i*i)/(2*o*t))}function dm(n,r,e){return cm(n,r)&&cm(r,e)&&ll(n.position,r.position,e.position)}function ll(n,r,e){return sn.copy(r).sub(n).cross($s.copy(e).sub(n))===0}function fm(n,r,e,t,o){let i=Math.sqrt(Math.pow(r.x-n.x,2)+Math.pow(r.y-n.y,2)),s=(n.y+r.y)/2,a=(n.x+r.x)/2,l=Math.sqrt(Math.pow(e,2)-Math.pow(i/2,2))*(n.y-r.y)/i,c=Math.sqrt(Math.pow(e,2)-Math.pow(i/2,2))*(r.x-n.x)/i;return t.set(a+l,s+c),o.set(a-l,s-c),[t,o]}function hm(n,r,e){let t=n.distanceTo(e),o=r.distanceTo(e);return t<o?r:n}function gm(n,r,e,t,o,i){let s=r.x-n.x,a=r.y-n.y,l=e.x-n.x,c=e.y-n.y,u=Math.sqrt((s+l)*(s+l)+(a+c)*(a+c)),m;return ul(r,n,e)>Math.PI&&(u*=-1),ti(c,a)?m=(a+c)*(t/u-.5)*8/3/(s-l):m=(s+l)*(t/u-.5)*8/3/(c-a),o.set(r.x-m*a,r.y+m*s),i.set(e.x+m*c,e.y-m*l),[o,i]}function pl(n,r){return n.position.equals(n.controls[1].position)&&r.position.equals(r.controls[0].position)}function cm(n,r){return ll(n.position,n.controls[1].position,r.position)&&ll(n.position,r.controls[0].position,r.position)}function ym(n,r,e,t,o=.5){let i=sn.subVectors(r,n).multiplyScalar(o).add(n),s=$s.subVectors(e,r).multiplyScalar(o).add(r),a=bv.subVectors(t,e).multiplyScalar(o).add(e),l=i,c=Sv.subVectors(s,i).multiplyScalar(o).add(i),u=wv.subVectors(a,s).multiplyScalar(o).add(s),m=a,p=Tv.subVectors(u,c).multiplyScalar(o).add(c);return[n.x,n.y,l.x,l.y,c.x,c.y,p.x,p.y,u.x,u.y,m.x,m.y,t.x,t.y]}function xm(n,r,e=12,t=!0){let o=pm.set(0,0,0),i,s=0,a=[];for(let l=0;l<r.length;l++){let c=cl(r[l]),u=sn,m=Qr(c,e);a.push(m);for(let p=0;p<=m;p++)if(c instanceof he.CubicBezierCurve||c instanceof he.QuadraticBezierCurve||c instanceof he.LineCurve){if(c.getPoint(p/m,u),o.set(u.x,u.y,0),i!==void 0&&Cv(i,o))continue;i===void 0&&(i=um),i.copy(o),n.setXYZ(s,o.x,o.y,o.z),s++}}return t&&s>1&&!(n.getX(s-1)===n.getX(0)&&n.getY(s-1)===n.getY(0)&&n.getZ(s-1)===n.getZ(0))&&(n.setXYZ(s,n.getX(0),n.getY(0),n.getZ(0)),s++),n}function vm(n,r,e,t=12,o=!0){let i=pm.set(0,0,0),s=0,a=[];for(let l=0;l<r.length;l++){if(e[l]===!1)continue;let c,u=cl(r[l]),m=sn,p=Qr(u,t);a.push(p);for(let d=0;d<=p;d++)if(u instanceof he.CubicBezierCurve||u instanceof he.QuadraticBezierCurve||u instanceof he.LineCurve){if(u.getPoint(d/p,m),i.set(m.x,m.y,0),c?.equals(i))continue;c===void 0?c=um:(n.setXYZ(s,c.x,c.y,c.z),s++,n.setXYZ(s,i.x,i.y,i.z),s++),c.copy(i)}}return o&&s>1&&!(n.getX(s-1)===n.getX(0)&&n.getY(s-1)===n.getY(0)&&n.getZ(s-1)===n.getZ(0))&&(n.setXYZ(s,n.getX(0),n.getY(0),n.getZ(0)),s++),a}function ml(n,r=12,e=!1){let t=[];for(let o=0,i=n.length;o<i;o++){let s=n[o],a=0;if(e&&s.roundedCurveCorner!==void 0){let l=Qr(s.roundedCurveCorner,r)*.5;o>0&&(t[o-1]+=l),a+=l}s.curveAfter!==void 0&&(a+=Qr(s.curveAfter,r)),t.push(a)}return n.length>0&&e&&n[0].roundedCurveCorner!==void 0&&(t[n.length-1]+=Qr(n[0].roundedCurveCorner,r)*.5),t}function Qr(n,r=12){return n&&n instanceof he.EllipseCurve?r*2:n&&(n instanceof he.LineCurve||n instanceof he.LineCurve3)?1:n&&n instanceof he.SplineCurve?r*n.points.length:r}function bm(n,r,e=12,t=!0){let o,i=0;for(let s=0;s<r.length;s++){let a=cl(r[s]),l=Qr(a,e),c=sn;for(let u=0;u<=l;u++)if(a instanceof he.CubicBezierCurve||a instanceof he.QuadraticBezierCurve||a instanceof he.LineCurve){if(a.getPoint(u/l,c),o!==void 0&&Nv(o,c,ei))continue;o===void 0&&(o=$s),o.copy(c),n.push(c.x,c.y),i++}}return ti(n[0],n[n.length-2],ei)&&ti(n[1],n[n.length-1],ei)&&(n.pop(),n.pop()),t&&i>1&&!(ti(n[i-1],n[1],ei)&&ti(n[i-2],n[0],ei))&&(n.push(n[0],n[1]),i++),n}var dl=new Se.Vector2,Lv=new Se.Vector2,Iv=new Se.Vector2,Pv=new Se.Vector2,Av=new Se.Vector2,Mv=new Se.Vector2,Le=class extends Se.Shape{constructor(e=100,t=100){super();this.points=[];this.shapeHoles=[];this.eventDispatcher=new Se.EventDispatcher;this.plane=new Se.Plane(new Se.Vector3(0,0,-1));this.subdivision=0;this.controlSnapDistance=4;this.pointIDs=0;this.isMesh2D=!1;this._roundness=0;this.isClosed=!1;this.useCubicForRoundedCorners=!0;this.uuid=Se.MathUtils.generateUUID();this.needsUpdate=!1;this.roundedCurves=[];this._width=e,this._height=t}static createFromState(e,t,o){let i=new Le;return i.isClosed=e.isClosed,i.points=e.points.map(s=>Xt.create(s.id,s.data)),typeof e.roundness=="number"&&(i.roundness=e.roundness),i.shapeHoles=e.shapeHoles.map(s=>Le.createFromState(s)),t!==void 0&&o!==void 0&&i.applySize(t,o),i.update(),i}get width(){return this._width}get height(){return this._height}get roundness(){return this._roundness}set roundness(e){if(this._roundness!==e){this._roundness=e;for(let t=0,o=this.points.length;t<o;t++)this.points[t].roundness=e;this.needsUpdate=!0}}getPointsIndexesByIds(e){return e.map(t=>this.getPointIndexById(t)).filter(t=>t>=0)}getPointIndexById(e){let t=this.points.length,o=this.points.findIndex(i=>i.uuid===e);if(o<0){let i=t;for(let s=0,a=this.shapeHoles.length;s<a;s++){let l=this.shapeHoles[s],c=l.points.length-1,u=l.getPointIndexById(e);if(u<0)i+=c;else return u+i}}return o}getLineIndexById(e){return this.getPointIndexById(e)}getBezierPoint(e){if(e<=this.points.length-1)return this.points[e];if(this.shapeHoles.length>0)for(let t=0,o=this.shapeHoles.length;t<o;t++){let i=this.shapeHoles[t],s=e-this.points.length;if(s<=i.points.length-1)return i.points[s]}throw new Error("This shape does not have a point for this index: "+e)}getBezierPointIndex(e){let t=this.points.indexOf(e);if(t>=0)return t;if(t=this.points.length,this.shapeHoles.length>0)for(let o=0,i=this.shapeHoles.length;o<i;o++){let s=this.shapeHoles[o],a=s.points.indexOf(e);if(a>=0)return t+a;t+=s.points.length}return-1}getAllPoints(){let e=[].concat(...this.shapeHoles.map(t=>t.points));return[...this.points,...e]}applySize(e,t){e===0&&(e=.001),t===0&&(t=.001),this._width=e,this._height=t}applyScale(e,t){let o=dl.set(e,t);for(let i=0,s=this.points.length;i<s;i++){let a=this.points[i];a.position.multiply(o),a.controls[0].position.multiply(o),a.controls[1].position.multiply(o)}for(let i=0,s=this.shapeHoles.length;i<s;i++)this.shapeHoles[i].applyScale(e,t);this._update(!1)}createPoint(e,t=0,o=Se.MathUtils.generateUUID()){let i;e instanceof Se.Vector2?i=e:i=new Se.Vector2(e,t);let s=new Xt(o,i);return s.roundness=this.roundness,s}addPoint(e){this.points.push(e),this.needsUpdate=!0}addPointAt(e,t){this.points.splice(t,0,e),this.needsUpdate=!0}getPointByUuid(e){for(let t=0,o=this.points.length;t<o;t++){let i=this.points[t];if(i.uuid===e)return i}for(let t=0,o=this.shapeHoles.length;t<o;t++){let s=this.shapeHoles[t].getPointByUuid(e);if(s)return s}}getFirstPoint(){return this.points[0]}getLastPoint(){return this.points[this.points.length-1]}removePoint(e){let t=this.points.indexOf(e);t>=0&&this.points.splice(t,1),this.needsUpdate=!0}removePointById(e){let t=this.points.find(o=>o.uuid===e);t&&this.removePoint(t)}update(e=!0){for(let t=0,o=this.shapeHoles.length;t<o;t++)this.shapeHoles[t].update(!1);this._update(e)}extractShapePointsToBuffer(e,t=12,o=!1){this.subdivision=t,this.curveDivisions===void 0&&this.computeCurveDivisions(t);let i=o?this.roundedCurveDivisions:this.curveDivisions;return xm(e,o?this.roundedCurves:this.curves,t,this.autoClose),i.reduce((s,a)=>s+a,0)+1}computeCurveDivisions(e=12){return this.curveDivisions=ml(this.points,e,!1),this.roundedCurveDivisions=ml(this.points,e,!0),this.curveDivisions}extractFilteredShapePointsToBuffer(e,t,o=12){return vm(e,this.curves,t,o,this.autoClose).reduce((s,a)=>s+a,0)*2}extractShapePointsToFlatArray(e,t=12){return this.subdivision=t,this.curveDivisions===void 0&&this.computeCurveDivisions(t),bm(e,this.roundedCurves,t,this.autoClose)}getCurveIndexFromVertexId(e,t=!1){let o=0;this.curveDivisions===void 0&&this.computeCurveDivisions(this.subdivision);let i=t?this.roundedCurveDivisions:this.curveDivisions,s=0;t&&this.points[0].roundedCurveCorner!==void 0&&(s=Qr(this.points[0].roundedCurveCorner,this.subdivision)*.5);let a=e-s;a<0&&(a+=i.reduce((l,c)=>l+c,0));for(let l=0,c=i.length;l<c;l++){let u=i[l];if(a<o+u)return[l,(a-o+1)/u];o+=u}return[0,1]}getCurveT(e,t,o){let i=this.points[e],s=this.points[e>=this.points.length-1?0:e+1],a=this.curveDivisions,l=a[e];if(pl(i,s)){let m=i.position.distanceTo(s.position);return i.position.distanceTo(dl.set(o.x,o.y))/m}let c=0;for(let m=0;m<e;m++)c+=a[m];return(t-c)/l}dispose(){this.eventDispatcher=null}_applyCurveForPoint(e,t){pl(t,e)?this.lineTo(e.position.x,e.position.y):this.bezierCurveTo(t.controls[1].position.x,t.controls[1].position.y,e.controls[0].position.x,e.controls[0].position.y,e.position.x,e.position.y);let o=this.curves[this.curves.length-1];e.curveBefore=o,t.curveAfter=o;let i=o.clone();e.roundedCurveBefore=i,t.roundedCurveAfter=i,e.roundedCurveCorner=void 0,this.roundedCurves.push(i)}_update(e=!0){if(this.curves=[],this.roundedCurves=[],!this.points.length)return;for(let o=0,i=this.points.length;o<i;o++){let s=this.points[o];if(o===0)this.moveTo(s.position.x,s.position.y);else{let a=this.points[o-1];this._applyCurveForPoint(s,a)}}let t=this.getLastPoint();if(t?.curveAfter&&(t.curveAfter=void 0),this.isClosed){let o=this.points[0],i=this.points[this.points.length-1];this._applyCurveForPoint(o,i)}if(this.points.length>2){let o=0;for(let i=0,s=this.points.length;i<s;i++){let a=this.points[i],l=this.points[i-1]??this.points[this.points.length-1],c=this.points[i+1]??this.points[0],u=a.roundness,m=l&&c&&dm(l,a,c);if(!a.controlsMoved()&&u>0&&!m){let p=a.curveBefore,d=a.curveAfter;if(p===void 0||d===void 0)continue;let f=a.roundedCurveBefore,g=a.roundedCurveAfter,x=p.getLength(),y=d.getLength(),v=Math.min(u,x*.499),P=Math.min(u,y*.499),S=Math.min(v,P),b=1-S/x,E=S/y,w=p.getPointAt(b,dl),h=d.getPointAt(E,Lv);this._subSplitCurve(p,f,b,w,void 0),this._subSplitCurve(d,g,E,void 0,h);let _;if(this.useCubicForRoundedCorners){let N=ul(w,a.position,h)/2,I=Math.tan(N)*w.distanceTo(a.position),[L,A]=fm(w,h,I,Iv,Pv),k=hm(L,A,a.position),[q,ne]=gm(k,w,h,I,Av,Mv);_=new Se.CubicBezierCurve(w.clone(),q.clone(),ne.clone(),h.clone())}else _=new Se.QuadraticBezierCurve(w.clone(),a.position.clone(),h.clone());a.roundedCurveCorner=_,this.roundedCurves.splice(i+o,0,_),o++}}}e&&this.eventDispatcher?.dispatchEvent({type:"update"})}_subSplitCurve(e,t,o,i,s){if(e instanceof Se.LineCurve)i!==void 0&&t.v2.copy(i),s!==void 0&&t.v1.copy(s);else{let a=e,l=t,c=a.getUtoTmapping(o,0),u=ym(a.v0,a.v1,a.v2,a.v3,c);return i!==void 0&&(l.v0.set(u[0],u[1]),l.v1.set(u[2],u[3]),l.v2.set(u[4],u[5]),l.v3.set(u[6],u[7])),s!==void 0&&(l.v0.set(u[6],u[7]),l.v1.set(u[8],u[9]),l.v2.set(u[10],u[11]),l.v3.set(u[12],u[13])),l}return t}clone(){let e=new Le(this._width,this._height);return e.points=this.points.map(t=>t.clone()),e.isClosed=this.isClosed,e.roundness=this.roundness,e.isMesh2D=this.isMesh2D,e.shapeHoles=this.shapeHoles.map(t=>t.clone()),e}toJSON(){return{points:this.points.reduce((e,t)=>e.concat(t.toJSON()),[]),shapeHoles:this.shapeHoles.map(e=>e.toJSON()),isClosed:this.isClosed,roundness:this.roundness}}fromJSON(e){this.points=[],this.pointIDs=0;let t=e.points.length/7;for(let o=0;o<t;o++){let i=o*7,s=e.points[i+0],a=e.points[i+1],l=e.points[i+2],c=e.points[i+3],u=e.points[i+4],m=e.points[i+5],p=e.points[i+6],d=new Xt(Se.MathUtils.generateUUID(),new Se.Vector2(s,a));d.controls[0].position.set(l,c),d.controls[1].position.set(u,m),d.roundness=p,this.points.push(d)}return this.shapeHoles=e.shapeHoles?.length?e.shapeHoles.map(o=>{let i=new Le;return i.fromJSON(o),i}):[],this.isClosed=e.isClosed,this._roundness=e.roundness,this._update(),this}fromShape(e){let t=(i,s)=>{s instanceof Se.CubicBezierCurve&&s.v3.equals(i.position)&&i.controls[0].position.copy(s.v2)},o=i=>{let s=[],a,l;for(a=0,l=i.length;a<l;a++)i[a]instanceof Se.QuadraticBezierCurve&&(i[a]=mm(i[a]));for(a=0,l=i.length;a<l;a++){let m=i[a],p=a>0?i[a-1]:null,d;m instanceof Se.CubicBezierCurve?(d=this.createPoint(m.v0),d.controls[1].position.copy(m.v1)):m instanceof Se.LineCurve&&(d=this.createPoint(m.v1)),d!==void 0&&(p!==null&&t(d,p),s.push(d))}let c=i[i.length-1],u=!1;return c instanceof Se.CubicBezierCurve?c.v3.equals(s[0].position)&&(s[0].controls[0].position.copy(c.v2),u=!0):c instanceof Se.LineCurve&&c.v2.equals(s[0].position)&&(u=!0),this.isClosed=u,s};return this.points=o(e.curves),e instanceof Se.Shape&&(this.shapeHoles=e.holes.map(i=>{let s=new Le;return s.fromShape(i),s})),this.update(),this}};var hl=Math.PI*2;function fl({x:n,y:r},e,t,o,i){return{x:n*e+o,y:r*t+i}}function Ov(n,r){let e=r===1.5707963267948966?.551915024494:r===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(r/4),t=Math.cos(n),o=Math.sin(n),i=Math.cos(n+r),s=Math.sin(n+r);return[{x:t-o*e,y:o+t*e},{x:i+s*e,y:s-i*e},{x:i,y:s}]}function Sm(n,r,e,t){let o=n*t-r*e<0?-1:1,i=Math.min(1,Math.max(-1,n*e+r*t));return o*Math.acos(i)}function _v(n,r,e,t,o,i,s,a,l,c){let u=Math.pow(o,2),m=Math.pow(i,2),p=Math.pow(s,2),d=Math.pow(a,2),f=u*m-u*d-m*p;f<0&&(f=0),f/=u*d+m*p,f=Math.sqrt(f)*(l===c?-1:1);let g=f*o/i*a,x=f*-i/o*s,y=g+(n+e)/2,v=x+(r+t)/2,P=(s-g)/o,S=(a-x)/i,b=(-s-g)/o,E=(-a-x)/i,w=Sm(1,0,P,S),h=Sm(P,S,b,E);return!c&&h>0&&(h-=hl),c&&h<0&&(h+=hl),{centerx:y,centery:v,ang1:w,ang2:h}}function wm({px:n,py:r,cx:e,cy:t,rx:o,ry:i,largeArcFlag:s,sweepFlag:a}){let l=[];if(o===0||i===0)return[];let c=(n-e)/2,u=(r-t)/2;if(c===0&&u===0)return[];o=Math.abs(o),i=Math.abs(i);let m=Math.pow(c,2)/Math.pow(o,2)+Math.pow(u,2)/Math.pow(i,2);m>1&&(o*=Math.sqrt(m),i*=Math.sqrt(m));let p=_v(n,r,e,t,o,i,c,u,s,a),{ang1:d,ang2:f}=p,{centerx:g,centery:x}=p,y=Math.abs(f)/(hl/4);Math.abs(1-y)<1e-7&&(y=1);let v=Math.max(Math.ceil(y),1);f/=v;for(let P=0;P<v;P++)l.push(Ov(d,f)),d+=f;return l.map(P=>{let{x:S,y:b}=fl(P[0],o,i,g,x),{x:E,y:w}=fl(P[1],o,i,g,x),{x:h,y:_}=fl(P[2],o,i,g,x);return{x1:S,y1:b,x2:E,y2:w,x:h,y:_}})}var go=require("three");var Be;(function(n){n[n.ODD=0]="ODD",n[n.NONZERO=1]="NONZERO",n[n.POSITIVE=2]="POSITIVE",n[n.NEGATIVE=3]="NEGATIVE",n[n.ABS_GEQ_TWO=4]="ABS_GEQ_TWO"})(Be||(Be={}));var Ze;(function(n){n[n.POLYGONS=0]="POLYGONS",n[n.CONNECTED_POLYGONS=1]="CONNECTED_POLYGONS",n[n.BOUNDARY_CONTOURS=2]="BOUNDARY_CONTOURS"})(Ze||(Ze={}));function pe(n,r){if(!n)throw r||"Assertion Failed!"}var ae=function(){function n(){}return n.vertEq=function(r,e){return r.s===e.s&&r.t===e.t},n.vertLeq=function(r,e){return r.s<e.s||r.s===e.s&&r.t<=e.t},n.transLeq=function(r,e){return r.t<e.t||r.t===e.t&&r.s<=e.s},n.edgeGoesLeft=function(r){return n.vertLeq(r.Dst,r.Org)},n.edgeGoesRight=function(r){return n.vertLeq(r.Org,r.Dst)},n.vertL1dist=function(r,e){return Math.abs(r.s-e.s)+Math.abs(r.t-e.t)},n.edgeEval=function(r,e,t){pe(n.vertLeq(r,e)&&n.vertLeq(e,t));var o=e.s-r.s,i=t.s-e.s;return o+i>0?o<i?e.t-r.t+(r.t-t.t)*(o/(o+i)):e.t-t.t+(t.t-r.t)*(i/(o+i)):0},n.edgeSign=function(r,e,t){pe(n.vertLeq(r,e)&&n.vertLeq(e,t));var o=e.s-r.s,i=t.s-e.s;return o+i>0?(e.t-t.t)*o+(e.t-r.t)*i:0},n.transEval=function(r,e,t){pe(n.transLeq(r,e)&&n.transLeq(e,t));var o=e.t-r.t,i=t.t-e.t;return o+i>0?o<i?e.s-r.s+(r.s-t.s)*(o/(o+i)):e.s-t.s+(t.s-r.s)*(i/(o+i)):0},n.transSign=function(r,e,t){pe(n.transLeq(r,e)&&n.transLeq(e,t));var o=e.t-r.t,i=t.t-e.t;return o+i>0?(e.s-t.s)*o+(e.s-r.s)*i:0},n.vertCCW=function(r,e,t){return r.s*(e.t-t.t)+e.s*(t.t-r.t)+t.s*(r.t-e.t)>=0},n.interpolate=function(r,e,t,o){return r=r<0?0:r,t=t<0?0:t,r<=t?t===0?(e+o)/2:e+(o-e)*(r/(r+t)):o+(e-o)*(t/(r+t))},n.intersect=function(r,e,t,o,i){var s,a,l;n.vertLeq(r,e)||(l=r,r=e,e=l),n.vertLeq(t,o)||(l=t,t=o,o=l),n.vertLeq(r,t)||(l=r,r=t,t=l,l=e,e=o,o=l),n.vertLeq(t,e)?n.vertLeq(e,o)?(s=n.edgeEval(r,t,e),a=n.edgeEval(t,e,o),s+a<0&&(s=-s,a=-a),i.s=n.interpolate(s,t.s,a,e.s)):(s=n.edgeSign(r,t,e),a=-n.edgeSign(r,o,e),s+a<0&&(s=-s,a=-a),i.s=n.interpolate(s,t.s,a,o.s)):i.s=(t.s+e.s)/2,n.transLeq(r,e)||(l=r,r=e,e=l),n.transLeq(t,o)||(l=t,t=o,o=l),n.transLeq(r,t)||(l=r,r=t,t=l,l=e,e=o,o=l),n.transLeq(t,e)?n.transLeq(e,o)?(s=n.transEval(r,t,e),a=n.transEval(t,e,o),s+a<0&&(s=-s,a=-a),i.t=n.interpolate(s,t.t,a,e.t)):(s=n.transSign(r,t,e),a=-n.transSign(r,o,e),s+a<0&&(s=-s,a=-a),i.t=n.interpolate(s,t.t,a,o.t)):i.t=(t.t+e.t)/2},n}(),ri=function(){function n(){this.next=null,this.prev=null,this.anEdge=null,this.trail=null,this.n=0,this.marked=!1,this.inside=!1}return n}(),Xs=function(){function n(r){this.side=r,this.next=null,this.Org=null,this.Sym=null,this.Onext=null,this.Lnext=null,this.Lface=null,this.activeRegion=null,this.winding=0}return Object.defineProperty(n.prototype,"Rface",{get:function(){return this.Sym.Lface},set:function(r){this.Sym.Lface=r},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"Dst",{get:function(){return this.Sym.Org},set:function(r){this.Sym.Org=r},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"Oprev",{get:function(){return this.Sym.Lnext},set:function(r){this.Sym.Lnext=r},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"Lprev",{get:function(){return this.Onext.Sym},set:function(r){this.Onext.Sym=r},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"Dprev",{get:function(){return this.Lnext.Sym},set:function(r){this.Lnext.Sym=r},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"Rprev",{get:function(){return this.Sym.Onext},set:function(r){this.Sym.Onext=r},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"Dnext",{get:function(){return this.Sym.Onext.Sym},set:function(r){this.Sym.Onext.Sym=r},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"Rnext",{get:function(){return this.Sym.Lnext.Sym},set:function(r){this.Sym.Lnext.Sym=r},enumerable:!0,configurable:!0}),n}(),an=function(){function n(){this.next=null,this.prev=null,this.anEdge=null,this.coords=[0,0,0],this.s=0,this.t=0,this.pqHandle=0,this.n=0,this.idx=0}return n}(),Tm=function(){function n(){var r=new an,e=new ri,t=new Xs(0),o=new Xs(1);r.next=r.prev=r,r.anEdge=null,e.next=e.prev=e,t.next=t,t.Sym=o,o.next=o,o.Sym=t,this.vHead=r,this.fHead=e,this.eHead=t,this.eHeadSym=o}return n.prototype.makeEdge_=function(r){var e=new Xs(0),t=new Xs(1);r.Sym.side<r.side&&(r=r.Sym);var o=r.Sym.next;return t.next=o,o.Sym.next=e,e.next=r,r.Sym.next=t,e.Sym=t,e.Onext=e,e.Lnext=t,e.Org=null,e.Lface=null,e.winding=0,e.activeRegion=null,t.Sym=e,t.Onext=t,t.Lnext=e,t.Org=null,t.Lface=null,t.winding=0,t.activeRegion=null,e},n.prototype.splice_=function(r,e){var t=r.Onext,o=e.Onext;t.Sym.Lnext=e,o.Sym.Lnext=r,r.Onext=o,e.Onext=t},n.prototype.makeVertex_=function(r,e,t){var o=r;pe(o,"Vertex can't be null!");var i=t.prev;o.prev=i,i.next=o,o.next=t,t.prev=o,o.anEdge=e;var s=e;do s.Org=o,s=s.Onext;while(s!==e)},n.prototype.makeFace_=function(r,e,t){var o=r;pe(o,"Face can't be null");var i=t.prev;o.prev=i,i.next=o,o.next=t,t.prev=o,o.anEdge=e,o.trail=null,o.marked=!1,o.inside=t.inside;var s=e;do s.Lface=o,s=s.Lnext;while(s!==e)},n.prototype.killEdge_=function(r){r.Sym.side<r.side&&(r=r.Sym);var e=r.next,t=r.Sym.next;e.Sym.next=t,t.Sym.next=e},n.prototype.killVertex_=function(r,e){var t=r.anEdge,o=t;do o.Org=e,o=o.Onext;while(o!==t);var i=r.prev,s=r.next;s.prev=i,i.next=s},n.prototype.killFace_=function(r,e){var t=r.anEdge,o=t;do o.Lface=e,o=o.Lnext;while(o!==t);var i=r.prev,s=r.next;s.prev=i,i.next=s},n.prototype.makeEdge=function(){var r=new an,e=new an,t=new ri,o=this.makeEdge_(this.eHead);return this.makeVertex_(r,o,this.vHead),this.makeVertex_(e,o.Sym,this.vHead),this.makeFace_(t,o,this.fHead),o},n.prototype.splice=function(r,e){var t=!1,o=!1;if(r!==e){if(e.Org!==r.Org&&(o=!0,this.killVertex_(e.Org,r.Org)),e.Lface!==r.Lface&&(t=!0,this.killFace_(e.Lface,r.Lface)),this.splice_(e,r),!o){var i=new an;this.makeVertex_(i,e,r.Org),r.Org.anEdge=r}if(!t){var s=new ri;this.makeFace_(s,e,r.Lface),r.Lface.anEdge=r}}},n.prototype.delete=function(r){var e=r.Sym,t=!1;if(r.Lface!==r.Rface&&(t=!0,this.killFace_(r.Lface,r.Rface)),r.Onext===r)this.killVertex_(r.Org,null);else if(r.Rface.anEdge=r.Oprev,r.Org.anEdge=r.Onext,this.splice_(r,r.Oprev),!t){var o=new ri;this.makeFace_(o,r,r.Lface)}e.Onext===e?(this.killVertex_(e.Org,null),this.killFace_(e.Lface,null)):(r.Lface.anEdge=e.Oprev,e.Org.anEdge=e.Onext,this.splice_(e,e.Oprev)),this.killEdge_(r)},n.prototype.addEdgeVertex=function(r){var e=this.makeEdge_(r),t=e.Sym;this.splice_(e,r.Lnext),e.Org=r.Dst;var o=new an;return this.makeVertex_(o,t,e.Org),e.Lface=t.Lface=r.Lface,e},n.prototype.splitEdge=function(r){var e=this.addEdgeVertex(r),t=e.Sym;return this.splice_(r.Sym,r.Sym.Oprev),this.splice_(r.Sym,t),r.Dst=t.Org,t.Dst.anEdge=t.Sym,t.Rface=r.Rface,t.winding=r.winding,t.Sym.winding=r.Sym.winding,t.idx=r.idx,t.Sym.idx=r.Sym.idx,t},n.prototype.connect=function(r,e){var t=!1,o=this.makeEdge_(r),i=o.Sym;if(e.Lface!==r.Lface&&(t=!0,this.killFace_(e.Lface,r.Lface)),this.splice_(o,r.Lnext),this.splice_(i,e),o.Org=r.Dst,i.Org=e.Org,o.Lface=i.Lface=r.Lface,r.Lface.anEdge=i,!t){var s=new ri;this.makeFace_(s,o,r.Lface)}return o},n.prototype.zapFace=function(r){var e=r.anEdge,t,o,i,s,a;o=e.Lnext;do t=o,o=t.Lnext,t.Lface=null,t.Rface===null&&(t.Onext===t?this.killVertex_(t.Org,null):(t.Org.anEdge=t.Onext,this.splice_(t,t.Oprev)),i=t.Sym,i.Onext===i?this.killVertex_(i.Org,null):(i.Org.anEdge=i.Onext,this.splice_(i,i.Oprev)),this.killEdge_(t));while(t!=e);s=r.prev,a=r.next,a.prev=s,s.next=a},n.prototype.countFaceVerts_=function(r){var e=r.anEdge,t=0;do t++,e=e.Lnext;while(e!==r.anEdge);return t},n.prototype.mergeConvexFaces=function(r){var e,t,o,i,s,a,l;for(e=this.fHead.next;e!==this.fHead;e=e.next)if(!!e.inside)for(t=e.anEdge,s=t.Org;o=t.Lnext,i=t.Sym,i&&i.Lface&&i.Lface.inside&&(a=this.countFaceVerts_(e),l=this.countFaceVerts_(i.Lface),a+l-2<=r&&ae.vertCCW(t.Lprev.Org,t.Org,i.Lnext.Lnext.Org)&&ae.vertCCW(i.Lprev.Org,i.Org,t.Lnext.Lnext.Org)&&(o=i.Lnext,this.delete(i),t=null,i=null)),!(t&&t.Lnext.Org===s);)t=o;return!0},n.prototype.check=function(){var r=this.fHead,e=this.vHead,t=this.eHead,o,i,s,a,l,c;for(i=r,i=r;(o=i.next)!==r;i=o){pe(o.prev===i),l=o.anEdge;do pe(l.Sym!==l),pe(l.Sym.Sym===l),pe(l.Lnext.Onext.Sym===l),pe(l.Onext.Sym.Lnext===l),pe(l.Lface===o),l=l.Lnext;while(l!==o.anEdge)}for(pe(o.prev===i&&o.anEdge===null),a=e,a=e;(s=a.next)!==e;a=s){pe(s.prev===a),l=s.anEdge;do pe(l.Sym!==l),pe(l.Sym.Sym===l),pe(l.Lnext.Onext.Sym===l),pe(l.Onext.Sym.Lnext===l),pe(l.Org===s),l=l.Onext;while(l!==s.anEdge)}for(pe(s.prev===a&&s.anEdge===null),c=t,c=t;(l=c.next)!==t;c=l)pe(l.Sym.next===c.Sym),pe(l.Sym!==l),pe(l.Sym.Sym===l),pe(l.Org!==null),pe(l.Dst!==null),pe(l.Lnext.Onext.Sym===l),pe(l.Onext.Sym.Lnext===l);pe(l.Sym.next===c.Sym&&l.Sym===this.eHeadSym&&l.Sym.Sym===l&&l.Org===null&&l.Dst===null&&l.Lface===null&&l.Rface===null)},n}(),Nm=function(){function n(){this.handle=null}return n}(),Cm=function(){function n(){this.key=null,this.node=0}return n}(),Dv=function(){function n(r,e){this.leq=e,this.max=0,this.nodes=[],this.handles=[],this.initialized=!1,this.freeList=0,this.size=0,this.max=r,this.nodes=[],this.handles=[];for(var t=0;t<r+1;t++)this.nodes[t]=new Nm,this.handles[t]=new Cm;this.initialized=!1,this.nodes[1].handle=1,this.handles[1].key=null}return n.prototype.floatDown_=function(r){var e=this.nodes,t=this.handles,o,i,s;for(o=e[r].handle;;){if(s=r<<1,s<this.size&&this.leq(t[e[s+1].handle].key,t[e[s].handle].key)&&++s,pe(s<=this.max),i=e[s].handle,s>this.size||this.leq(t[o].key,t[i].key)){e[r].handle=o,t[o].node=r;break}e[r].handle=i,t[i].node=r,r=s}},n.prototype.floatUp_=function(r){var e=this.nodes,t=this.handles,o,i,s;for(o=e[r].handle;;){if(s=r>>1,i=e[s].handle,s===0||this.leq(t[i].key,t[o].key)){e[r].handle=o,t[o].node=r;break}e[r].handle=i,t[i].node=r,r=s}},n.prototype.init=function(){for(var r=this.size;r>=1;--r)this.floatDown_(r);this.initialized=!0},n.prototype.min=function(){return this.handles[this.nodes[1].handle].key},n.prototype.insert=function(r){var e,t;if(e=++this.size,e*2>this.max){this.max*=2;var o,i;for(i=this.nodes.length,this.nodes.length=this.max+1,o=i;o<this.nodes.length;o++)this.nodes[o]=new Nm;for(i=this.handles.length,this.handles.length=this.max+1,o=i;o<this.handles.length;o++)this.handles[o]=new Cm}return this.freeList===0?t=e:(t=this.freeList,this.freeList=this.handles[t].node),this.nodes[e].handle=t,this.handles[t].node=e,this.handles[t].key=r,this.initialized&&this.floatUp_(e),t},n.prototype.extractMin=function(){var r=this.nodes,e=this.handles,t=r[1].handle,o=e[t].key;return this.size>0&&(r[1].handle=r[this.size].handle,e[r[1].handle].node=1,e[t].key=null,e[t].node=this.freeList,this.freeList=t,--this.size,this.size>0&&this.floatDown_(1)),o},n.prototype.delete=function(r){var e=this.nodes,t=this.handles,o;pe(r>=1&&r<=this.max&&t[r].key!==null),o=t[r].node,e[o].handle=e[this.size].handle,t[e[o].handle].node=o,--this.size,o<=this.size&&(o<=1||this.leq(t[e[o>>1].handle].key,t[e[o].handle].key)?this.floatDown_(o):this.floatUp_(o)),t[r].key=null,t[r].node=this.freeList,this.freeList=r},n}(),gl=function(){function n(){this.eUp=null,this.nodeUp=null,this.windingNumber=0,this.inside=!1,this.sentinel=!1,this.dirty=!1,this.fixUpperEdge=!1}return n}(),Lm=function(){function n(){this.key=null,this.next=null,this.prev=null}return n}(),Ev=function(){function n(r,e){this.frame=r,this.leq=e,this.head=new Lm,this.head.next=this.head,this.head.prev=this.head}return n.prototype.min=function(){return this.head.next},n.prototype.max=function(){return this.head.prev},n.prototype.insert=function(r){return this.insertBefore(this.head,r)},n.prototype.search=function(r){var e=this.head;do e=e.next;while(e.key!==null&&!this.leq(this.frame,r,e.key));return e},n.prototype.insertBefore=function(r,e){do r=r.prev;while(r.key!==null&&!this.leq(this.frame,r.key,e));var t=new Lm;return t.key=e,t.next=r.next,r.next.prev=t,t.prev=r,r.next=t,t},n.prototype.delete=function(r){r.next.prev=r.prev,r.prev.next=r.next},n}(),Bv=function(){function n(){}return n.regionBelow=function(r){return r.nodeUp.prev.key},n.regionAbove=function(r){return r.nodeUp.next.key},n.debugEvent=function(r){},n.addWinding=function(r,e){r.winding+=e.winding,r.Sym.winding+=e.Sym.winding},n.edgeLeq=function(r,e,t){var o=r.event,i=e.eUp,s=t.eUp;if(i.Dst===o)return s.Dst===o?ae.vertLeq(i.Org,s.Org)?ae.edgeSign(s.Dst,i.Org,s.Org)<=0:ae.edgeSign(i.Dst,s.Org,i.Org)>=0:ae.edgeSign(s.Dst,o,s.Org)<=0;if(s.Dst===o)return ae.edgeSign(i.Dst,o,i.Org)>=0;var a=ae.edgeEval(i.Dst,o,i.Org),l=ae.edgeEval(s.Dst,o,s.Org);return a>=l},n.deleteRegion=function(r,e){e.fixUpperEdge&&pe(e.eUp.winding===0),e.eUp.activeRegion=null,r.dict.delete(e.nodeUp)},n.fixUpperEdge=function(r,e,t){pe(e.fixUpperEdge),r.mesh.delete(e.eUp),e.fixUpperEdge=!1,e.eUp=t,t.activeRegion=e},n.topLeftRegion=function(r,e){var t=e.eUp.Org,o;do e=n.regionAbove(e);while(e.eUp.Org===t);if(e.fixUpperEdge){if(o=r.mesh.connect(n.regionBelow(e).eUp.Sym,e.eUp.Lnext),o===null)return null;n.fixUpperEdge(r,e,o),e=n.regionAbove(e)}return e},n.topRightRegion=function(r){var e=r.eUp.Dst;do r=n.regionAbove(r);while(r.eUp.Dst===e);return r},n.addRegionBelow=function(r,e,t){var o=new gl;return o.eUp=t,o.nodeUp=r.dict.insertBefore(e.nodeUp,o),o.fixUpperEdge=!1,o.sentinel=!1,o.dirty=!1,t.activeRegion=o,o},n.isWindingInside=function(r,e){switch(r.windingRule){case Be.ODD:return(e&1)!==0;case Be.NONZERO:return e!==0;case Be.POSITIVE:return e>0;case Be.NEGATIVE:return e<0;case Be.ABS_GEQ_TWO:return e>=2||e<=-2}throw new Error("Invalid winding rulle")},n.computeWinding=function(r,e){e.windingNumber=n.regionAbove(e).windingNumber+e.eUp.winding,e.inside=n.isWindingInside(r,e.windingNumber)},n.finishRegion=function(r,e){var t=e.eUp,o=t.Lface;o.inside=e.inside,o.anEdge=t,n.deleteRegion(r,e)},n.finishLeftRegions=function(r,e,t){for(var o,i=null,s=e,a=e.eUp;s!==t;){if(s.fixUpperEdge=!1,i=n.regionBelow(s),o=i.eUp,o.Org!=a.Org){if(!i.fixUpperEdge){n.finishRegion(r,s);break}o=r.mesh.connect(a.Lprev,o.Sym),n.fixUpperEdge(r,i,o)}a.Onext!==o&&(r.mesh.splice(o.Oprev,o),r.mesh.splice(a,o)),n.finishRegion(r,s),a=i.eUp,s=i}return a},n.addRightEdges=function(r,e,t,o,i,s){var a,l,c,u,m=!0;c=t;do pe(ae.vertLeq(c.Org,c.Dst)),n.addRegionBelow(r,e,c.Sym),c=c.Onext;while(c!==o);for(i===null&&(i=n.regionBelow(e).eUp.Rprev),l=e,u=i;a=n.regionBelow(l),c=a.eUp.Sym,c.Org===u.Org;)c.Onext!==u&&(r.mesh.splice(c.Oprev,c),r.mesh.splice(u.Oprev,c)),a.windingNumber=l.windingNumber-c.winding,a.inside=n.isWindingInside(r,a.windingNumber),l.dirty=!0,!m&&n.checkForRightSplice(r,l)&&(n.addWinding(c,u),n.deleteRegion(r,l),r.mesh.delete(u)),m=!1,l=a,u=c;l.dirty=!0,pe(l.windingNumber-c.winding===a.windingNumber),s&&n.walkDirtyRegions(r,l)},n.spliceMergeVertices=function(r,e,t){r.mesh.splice(e,t)},n.vertexWeights=function(r,e,t){var o=ae.vertL1dist(e,r),i=ae.vertL1dist(t,r),s=.5*i/(o+i),a=.5*o/(o+i);r.coords[0]+=s*e.coords[0]+a*t.coords[0],r.coords[1]+=s*e.coords[1]+a*t.coords[1],r.coords[2]+=s*e.coords[2]+a*t.coords[2]},n.getIntersectData=function(r,e,t,o,i,s){e.coords[0]=e.coords[1]=e.coords[2]=0,e.idx=-1,n.vertexWeights(e,t,o),n.vertexWeights(e,i,s)},n.checkForRightSplice=function(r,e){var t=n.regionBelow(e),o=e.eUp,i=t.eUp;if(ae.vertLeq(o.Org,i.Org)){if(ae.edgeSign(i.Dst,o.Org,i.Org)>0)return!1;ae.vertEq(o.Org,i.Org)?o.Org!==i.Org&&(r.pq.delete(o.Org.pqHandle),n.spliceMergeVertices(r,i.Oprev,o)):(r.mesh.splitEdge(i.Sym),r.mesh.splice(o,i.Oprev),e.dirty=t.dirty=!0)}else{if(ae.edgeSign(o.Dst,i.Org,o.Org)<0)return!1;n.regionAbove(e).dirty=e.dirty=!0,r.mesh.splitEdge(o.Sym),r.mesh.splice(i.Oprev,o)}return!0},n.checkForLeftSplice=function(r,e){var t=n.regionBelow(e),o=e.eUp,i=t.eUp,s;if(pe(!ae.vertEq(o.Dst,i.Dst)),ae.vertLeq(o.Dst,i.Dst)){if(ae.edgeSign(o.Dst,i.Dst,o.Org)<0)return!1;n.regionAbove(e).dirty=e.dirty=!0,s=r.mesh.splitEdge(o),r.mesh.splice(i.Sym,s),s.Lface.inside=e.inside}else{if(ae.edgeSign(i.Dst,o.Dst,i.Org)>0)return!1;e.dirty=t.dirty=!0,s=r.mesh.splitEdge(i),r.mesh.splice(o.Lnext,i.Sym),s.Rface.inside=e.inside}return!0},n.checkForIntersect=function(r,e){var t=n.regionBelow(e),o=e.eUp,i=t.eUp,s=o.Org,a=i.Org,l=o.Dst,c=i.Dst,u,m,p=new an,d,f;if(pe(!ae.vertEq(c,l)),pe(ae.edgeSign(l,r.event,s)<=0),pe(ae.edgeSign(c,r.event,a)>=0),pe(s!==r.event&&a!==r.event),pe(!e.fixUpperEdge&&!t.fixUpperEdge),s===a||(u=Math.min(s.t,l.t),m=Math.max(a.t,c.t),u>m))return!1;if(ae.vertLeq(s,a)){if(ae.edgeSign(c,s,a)>0)return!1}else if(ae.edgeSign(l,a,s)<0)return!1;return n.debugEvent(r),ae.intersect(l,s,c,a,p),pe(Math.min(s.t,l.t)<=p.t),pe(p.t<=Math.max(a.t,c.t)),pe(Math.min(c.s,l.s)<=p.s),pe(p.s<=Math.max(a.s,s.s)),ae.vertLeq(p,r.event)&&(p.s=r.event.s,p.t=r.event.t),d=ae.vertLeq(s,a)?s:a,ae.vertLeq(d,p)&&(p.s=d.s,p.t=d.t),ae.vertEq(p,s)||ae.vertEq(p,a)?(n.checkForRightSplice(r,e),!1):!ae.vertEq(l,r.event)&&ae.edgeSign(l,r.event,p)>=0||!ae.vertEq(c,r.event)&&ae.edgeSign(c,r.event,p)<=0?c===r.event?(r.mesh.splitEdge(o.Sym),r.mesh.splice(i.Sym,o),e=n.topLeftRegion(r,e),o=n.regionBelow(e).eUp,n.finishLeftRegions(r,n.regionBelow(e),t),n.addRightEdges(r,e,o.Oprev,o,o,!0),!0):l===r.event?(r.mesh.splitEdge(i.Sym),r.mesh.splice(o.Lnext,i.Oprev),t=e,e=n.topRightRegion(e),f=n.regionBelow(e).eUp.Rprev,t.eUp=i.Oprev,i=n.finishLeftRegions(r,t,null),n.addRightEdges(r,e,i.Onext,o.Rprev,f,!0),!0):(ae.edgeSign(l,r.event,p)>=0&&(n.regionAbove(e).dirty=e.dirty=!0,r.mesh.splitEdge(o.Sym),o.Org.s=r.event.s,o.Org.t=r.event.t),ae.edgeSign(c,r.event,p)<=0&&(e.dirty=t.dirty=!0,r.mesh.splitEdge(i.Sym),i.Org.s=r.event.s,i.Org.t=r.event.t),!1):(r.mesh.splitEdge(o.Sym),r.mesh.splitEdge(i.Sym),r.mesh.splice(i.Oprev,o),o.Org.s=p.s,o.Org.t=p.t,o.Org.pqHandle=r.pq.insert(o.Org),n.getIntersectData(r,o.Org,s,l,a,c),n.regionAbove(e).dirty=e.dirty=t.dirty=!0,!1)},n.walkDirtyRegions=function(r,e){for(var t=n.regionBelow(e),o,i;;){for(;t.dirty;)e=t,t=n.regionBelow(t);if(!e.dirty&&(t=e,e=n.regionAbove(e),e===null||!e.dirty))return;if(e.dirty=!1,o=e.eUp,i=t.eUp,o.Dst!==i.Dst&&n.checkForLeftSplice(r,e)&&(t.fixUpperEdge?(n.deleteRegion(r,t),r.mesh.delete(i),t=n.regionBelow(e),i=t.eUp):e.fixUpperEdge&&(n.deleteRegion(r,e),r.mesh.delete(o),e=n.regionAbove(t),o=e.eUp)),o.Org!==i.Org)if(o.Dst!==i.Dst&&!e.fixUpperEdge&&!t.fixUpperEdge&&(o.Dst===r.event||i.Dst===r.event)){if(n.checkForIntersect(r,e))return}else n.checkForRightSplice(r,e);o.Org===i.Org&&o.Dst===i.Dst&&(n.addWinding(i,o),n.deleteRegion(r,e),r.mesh.delete(o),e=n.regionAbove(t))}},n.connectRightVertex=function(r,e,t){var o,i=t.Onext,s=n.regionBelow(e),a=e.eUp,l=s.eUp,c=!1;if(a.Dst!==l.Dst&&n.checkForIntersect(r,e),ae.vertEq(a.Org,r.event)&&(r.mesh.splice(i.Oprev,a),e=n.topLeftRegion(r,e),i=n.regionBelow(e).eUp,n.finishLeftRegions(r,n.regionBelow(e),s),c=!0),ae.vertEq(l.Org,r.event)&&(r.mesh.splice(t,l.Oprev),t=n.finishLeftRegions(r,s,null),c=!0),c){n.addRightEdges(r,e,t.Onext,i,i,!0);return}ae.vertLeq(l.Org,a.Org)?o=l.Oprev:o=a,o=r.mesh.connect(t.Lprev,o),n.addRightEdges(r,e,o,o.Onext,o.Onext,!1),o.Sym.activeRegion.fixUpperEdge=!0,n.walkDirtyRegions(r,e)},n.connectLeftDegenerate=function(r,e,t){var o,i,s,a,l;if(o=e.eUp,ae.vertEq(o.Org,t)){pe(!1),n.spliceMergeVertices(r,o,t.anEdge);return}if(!ae.vertEq(o.Dst,t)){r.mesh.splitEdge(o.Sym),e.fixUpperEdge&&(r.mesh.delete(o.Onext),e.fixUpperEdge=!1),r.mesh.splice(t.anEdge,o),n.sweepEvent(r,t);return}pe(!1),e=n.topRightRegion(e),l=n.regionBelow(e),s=l.eUp.Sym,i=a=s.Onext,l.fixUpperEdge&&(pe(i!==s),n.deleteRegion(r,l),r.mesh.delete(s),s=i.Oprev),r.mesh.splice(t.anEdge,s),ae.edgeGoesLeft(i)||(i=null),n.addRightEdges(r,e,s.Onext,a,i,!0)},n.connectLeftVertex=function(r,e){var t,o,i,s,a,l,c=new gl;if(c.eUp=e.anEdge.Sym,t=r.dict.search(c).key,o=n.regionBelow(t),!!o){if(s=t.eUp,a=o.eUp,ae.edgeSign(s.Dst,e,s.Org)===0){n.connectLeftDegenerate(r,t,e);return}if(i=ae.vertLeq(a.Dst,s.Dst)?t:o,t.inside||i.fixUpperEdge){if(i===t)l=r.mesh.connect(e.anEdge.Sym,s.Lnext);else{var u=r.mesh.connect(a.Dnext,e.anEdge);l=u.Sym}i.fixUpperEdge?n.fixUpperEdge(r,i,l):n.computeWinding(r,n.addRegionBelow(r,t,l)),n.sweepEvent(r,e)}else n.addRightEdges(r,t,e.anEdge,e.anEdge,null,!0)}},n.sweepEvent=function(r,e){r.event=e,n.debugEvent(r);for(var t=e.anEdge;t.activeRegion===null;)if(t=t.Onext,t===e.anEdge){n.connectLeftVertex(r,e);return}var o=n.topLeftRegion(r,t.activeRegion);pe(o!==null);var i=n.regionBelow(o),s=i.eUp,a=n.finishLeftRegions(r,i,null);a.Onext===s?n.connectRightVertex(r,o,a):n.addRightEdges(r,o,a.Onext,s,s,!0)},n.addSentinel=function(r,e,t,o){var i=new gl,s=r.mesh.makeEdge();s.Org.s=t,s.Org.t=o,s.Dst.s=e,s.Dst.t=o,r.event=s.Dst,i.eUp=s,i.windingNumber=0,i.inside=!1,i.fixUpperEdge=!1,i.sentinel=!0,i.dirty=!1,i.nodeUp=r.dict.insert(i)},n.initEdgeDict=function(r){r.dict=new Ev(r,n.edgeLeq);var e=r.bmax[0]-r.bmin[0],t=r.bmax[1]-r.bmin[1],o=r.bmin[0]-e,i=r.bmax[0]+e,s=r.bmin[1]-t,a=r.bmax[1]+t;n.addSentinel(r,o,i,s),n.addSentinel(r,o,i,a)},n.doneEdgeDict=function(r){for(var e,t=0;(e=r.dict.min().key)!==null;)e.sentinel||(pe(e.fixUpperEdge),pe(++t===1)),pe(e.windingNumber===0),n.deleteRegion(r,e)},n.removeDegenerateEdges=function(r){var e,t,o,i=r.mesh.eHead;for(e=i.next;e!==i;e=t)t=e.next,o=e.Lnext,ae.vertEq(e.Org,e.Dst)&&e.Lnext.Lnext!==e&&(n.spliceMergeVertices(r,o,e),r.mesh.delete(e),e=o,o=e.Lnext),o.Lnext===e&&(o!==e&&((o===t||o===t.Sym)&&(t=t.next),r.mesh.delete(o)),(e===t||e===t.Sym)&&(t=t.next),r.mesh.delete(e))},n.initPriorityQ=function(r){var e,t,o,i=0;for(o=r.mesh.vHead,t=o.next;t!==o;t=t.next)i++;for(i+=8,e=r.pq=new Dv(i,ae.vertLeq),o=r.mesh.vHead,t=o.next;t!==o;t=t.next)t.pqHandle=e.insert(t);return t!==o?!1:(e.init(),!0)},n.donePriorityQ=function(r){r.pq=null},n.removeDegenerateFaces=function(r,e){var t,o,i;for(t=e.fHead.next;t!==e.fHead;t=o)o=t.next,i=t.anEdge,pe(i.Lnext!==i),i.Lnext.Lnext===i&&(n.addWinding(i.Onext,i),r.mesh.delete(i));return!0},n.computeInterior=function(r,e){e===void 0&&(e=!0);var t,o;if(n.removeDegenerateEdges(r),!n.initPriorityQ(r))return!1;for(n.initEdgeDict(r);(t=r.pq.extractMin())!==null;){for(;o=r.pq.min(),!(o===null||!ae.vertEq(o,t));)o=r.pq.extractMin(),n.spliceMergeVertices(r,t.anEdge,o.anEdge);n.sweepEvent(r,t)}return r.event=r.dict.min().key.eUp.Org,n.debugEvent(r),n.doneEdgeDict(r),n.donePriorityQ(r),n.removeDegenerateFaces(r,r.mesh)?(e&&r.mesh.check(),!0):!1},n}(),Gv=function(){function n(){this.mesh=new Tm,this.normal=[0,0,0],this.sUnit=[0,0,0],this.tUnit=[0,0,0],this.bmin=[0,0],this.bmax=[0,0],this.windingRule=Be.ODD,this.dict=null,this.pq=null,this.event=null,this.vertexIndexCounter=0,this.vertices=[],this.vertexIndices=[],this.vertexCount=0,this.elements=[],this.elementCount=0}return n.prototype.dot_=function(r,e){return r[0]*e[0]+r[1]*e[1]+r[2]*e[2]},n.prototype.normalize_=function(r){var e=r[0]*r[0]+r[1]*r[1]+r[2]*r[2];if(!e)throw"Zero-size vector!";e=Math.sqrt(e),r[0]/=e,r[1]/=e,r[2]/=e},n.prototype.longAxis_=function(r){var e=0;return Math.abs(r[1])>Math.abs(r[0])&&(e=1),Math.abs(r[2])>Math.abs(r[e])&&(e=2),e},n.prototype.computeNormal_=function(r){var e,t,o,i,s,a,l=[0,0,0],c=[0,0,0],u=[0,0,0],m=[0,0,0],p=[0,0,0],d=[null,null,null],f=[null,null,null],g=this.mesh.vHead;e=g.next;for(var x=0;x<3;++x)i=e.coords[x],c[x]=i,f[x]=e,l[x]=i,d[x]=e;for(e=g.next;e!==g;e=e.next)for(var y=0;y<3;++y)i=e.coords[y],i<c[y]&&(c[y]=i,f[y]=e),i>l[y]&&(l[y]=i,d[y]=e);var v=0;if(l[1]-c[1]>l[0]-c[0]&&(v=1),l[2]-c[2]>l[v]-c[v]&&(v=2),c[v]>=l[v]){r[0]=0,r[1]=0,r[2]=1;return}for(a=0,t=f[v],o=d[v],u[0]=t.coords[0]-o.coords[0],u[1]=t.coords[1]-o.coords[1],u[2]=t.coords[2]-o.coords[2],e=g.next;e!==g;e=e.next)m[0]=e.coords[0]-o.coords[0],m[1]=e.coords[1]-o.coords[1],m[2]=e.coords[2]-o.coords[2],p[0]=u[1]*m[2]-u[2]*m[1],p[1]=u[2]*m[0]-u[0]*m[2],p[2]=u[0]*m[1]-u[1]*m[0],s=p[0]*p[0]+p[1]*p[1]+p[2]*p[2],s>a&&(a=s,r[0]=p[0],r[1]=p[1],r[2]=p[2]);a<=0&&(r[0]=r[1]=r[2]=0,r[this.longAxis_(u)]=1)},n.prototype.checkOrientation_=function(){for(var r=this.mesh.fHead,e,t=this.mesh.vHead,o,i=0,s=r.next;s!==r;s=s.next)if(o=s.anEdge,!(o.winding<=0))do i+=(o.Org.s-o.Dst.s)*(o.Org.t+o.Dst.t),o=o.Lnext;while(o!==s.anEdge);if(i<0){for(e=t.next;e!==t;e=e.next)e.t=-e.t;this.tUnit[0]=-this.tUnit[0],this.tUnit[1]=-this.tUnit[1],this.tUnit[2]=-this.tUnit[2]}},n.prototype.projectPolygon_=function(){var r=this.mesh.vHead,e=[0,0,0],t,o,i=!1;e[0]=this.normal[0],e[1]=this.normal[1],e[2]=this.normal[2],!e[0]&&!e[1]&&!e[2]&&(this.computeNormal_(e),i=!0),t=this.sUnit,o=this.tUnit;var s=this.longAxis_(e);t[s]=0,t[(s+1)%3]=1,t[(s+2)%3]=0,o[s]=0,o[(s+1)%3]=0,o[(s+2)%3]=e[s]>0?1:-1;for(var a=r.next;a!==r;a=a.next)a.s=this.dot_(a.coords,t),a.t=this.dot_(a.coords,o);i&&this.checkOrientation_();for(var l=!0,c=r.next;c!==r;c=c.next)l?(this.bmin[0]=this.bmax[0]=c.s,this.bmin[1]=this.bmax[1]=c.t,l=!1):(c.s<this.bmin[0]&&(this.bmin[0]=c.s),c.s>this.bmax[0]&&(this.bmax[0]=c.s),c.t<this.bmin[1]&&(this.bmin[1]=c.t),c.t>this.bmax[1]&&(this.bmax[1]=c.t))},n.prototype.addWinding_=function(r,e){r.winding+=e.winding,r.Sym.winding+=e.Sym.winding},n.prototype.tessellateMonoRegion_=function(r,e){var t,o;if(t=e.anEdge,!(t.Lnext!==t&&t.Lnext.Lnext!==t))throw"Mono region invalid";for(;ae.vertLeq(t.Dst,t.Org);t=t.Lprev);for(;ae.vertLeq(t.Org,t.Dst);t=t.Lnext);o=t.Lprev;for(var i=void 0;t.Lnext!==o;)if(ae.vertLeq(t.Dst,o.Org)){for(;o.Lnext!==t&&(ae.edgeGoesLeft(o.Lnext)||ae.edgeSign(o.Org,o.Dst,o.Lnext.Dst)<=0);)i=r.connect(o.Lnext,o),o=i.Sym;o=o.Lprev}else{for(;o.Lnext!==t&&(ae.edgeGoesRight(t.Lprev)||ae.edgeSign(t.Dst,t.Org,t.Lprev.Org)>=0);)i=r.connect(t,t.Lprev),t=i.Sym;t=t.Lnext}if(o.Lnext===t)throw"Mono region invalid";for(;o.Lnext.Lnext!==t;)i=r.connect(o.Lnext,o),o=i.Sym;return!0},n.prototype.tessellateInterior_=function(r){for(var e,t=r.fHead.next;t!==r.fHead;t=e)if(e=t.next,t.inside&&!this.tessellateMonoRegion_(r,t))return!1;return!0},n.prototype.discardExterior_=function(r){for(var e,t=r.fHead.next;t!==r.fHead;t=e)e=t.next,t.inside||r.zapFace(t)},n.prototype.setWindingNumber_=function(r,e,t){for(var o,i=r.eHead.next;i!==r.eHead;i=o)o=i.next,i.Rface.inside!==i.Lface.inside?i.winding=i.Lface.inside?e:-e:t?r.delete(i):i.winding=0},n.prototype.getNeighbourFace_=function(r){return!r.Rface||!r.Rface.inside?-1:r.Rface.n},n.prototype.outputPolymesh_=function(r,e,t,o){var i,s=0,a=0,l;t>3&&r.mergeConvexFaces(t);for(var c=r.vHead.next;c!==r.vHead;c=c.next)c.n=-1;for(var u=r.fHead.next;u!==r.fHead;u=u.next)if(u.n=-1,!!u.inside){i=u.anEdge,l=0;do{var c=i.Org;c.n===-1&&(c.n=a,a++),l++,i=i.Lnext}while(i!==u.anEdge);if(l>t)throw"Face vertex greater that support polygon";u.n=s,++s}this.elementCount=s,e===Ze.CONNECTED_POLYGONS&&(s*=2),this.elements=[],this.elements.length=s*t,this.vertexCount=a,this.vertices=[],this.vertices.length=a*o,this.vertexIndices=[],this.vertexIndices.length=a;for(var c=r.vHead.next;c!==r.vHead;c=c.next)if(c.n!==-1){var m=c.n*o;this.vertices[m+0]=c.coords[0],this.vertices[m+1]=c.coords[1],o>2&&(this.vertices[m+2]=c.coords[2]),this.vertexIndices[c.n]=c.idx}for(var p=0,u=r.fHead.next;u!==r.fHead;u=u.next)if(!!u.inside){i=u.anEdge,l=0;do{var c=i.Org;this.elements[p++]=c.n,l++,i=i.Lnext}while(i!==u.anEdge);for(var d=l;d<t;++d)this.elements[p++]=-1;if(e===Ze.CONNECTED_POLYGONS){i=u.anEdge;do this.elements[p++]=this.getNeighbourFace_(i),i=i.Lnext;while(i!==u.anEdge);for(var f=l;f<t;++f)this.elements[p++]=-1}}},n.prototype.outputContours_=function(r,e){var t,o,i=0,s=0;this.vertexCount=0,this.elementCount=0;for(var a=r.fHead.next;a!==r.fHead;a=a.next)if(!!a.inside){o=t=a.anEdge;do this.vertexCount++,t=t.Lnext;while(t!==o);this.elementCount++}this.elements=[],this.elements.length=this.elementCount*2,this.vertices=[],this.vertices.length=this.vertexCount*e,this.vertexIndices=[],this.vertexIndices.length=this.vertexCount;var l=0,c=0,u=0;i=0;for(var a=r.fHead.next;a!==r.fHead;a=a.next)if(!!a.inside){s=0,o=t=a.anEdge;do this.vertices[l++]=t.Org.coords[0],this.vertices[l++]=t.Org.coords[1],e>2&&(this.vertices[l++]=t.Org.coords[2]),this.vertexIndices[c++]=this.vertexIdCallback?this.vertexIdCallback(t):t.Org.idx,s++,t=t.Lnext;while(t!==o);this.elements[u++]=i,this.elements[u++]=s,i+=s}},n.prototype.addContour=function(r,e){this.mesh===null&&(this.mesh=new Tm),r<2&&(r=2),r>3&&(r=3);for(var t=null,o=0;o<e.length;o+=r)t===null?(t=this.mesh.makeEdge(),this.mesh.splice(t,t.Sym)):(this.mesh.splitEdge(t),t=t.Lnext),t.Org.coords[0]=e[o+0],t.Org.coords[1]=e[o+1],r>2?t.Org.coords[2]=e[o+2]:t.Org.coords[2]=0,t.Org.idx=this.vertexIndexCounter++,this.edgeCreateCallback&&this.edgeCreateCallback(t),t.winding=1,t.Sym.winding=-1},n.prototype.tesselate=function(r,e,t,o,i,s){if(r===void 0&&(r=Be.ODD),e===void 0&&(e=Ze.POLYGONS),s===void 0&&(s=!0),this.vertices=[],this.elements=[],this.vertexIndices=[],this.vertexIndexCounter=0,i&&(this.normal[0]=i[0],this.normal[1]=i[1],this.normal[2]=i[2]),this.windingRule=r,o<2&&(o=2),o>3&&(o=3),!this.mesh)return!1;this.projectPolygon_(),Bv.computeInterior(this,s);var a=this.mesh;return e===Ze.BOUNDARY_CONTOURS?this.setWindingNumber_(a,1,!0):this.tessellateInterior_(a),s&&a.check(),e===Ze.BOUNDARY_CONTOURS?this.outputContours_(a,o):this.outputPolymesh_(a,e,t,o),!0},n}();function ho(n){var r=n.windingRule,e=r===void 0?Be.ODD:r,t=n.elementType,o=t===void 0?Ze.POLYGONS:t,i=n.polySize,s=i===void 0?3:i,a=n.vertexSize,l=a===void 0?2:a,c=n.normal,u=c===void 0?[0,0,1]:c,m=n.contours,p=m===void 0?[]:m,d=n.strict,f=d===void 0?!0:d,g=n.debug,x=g===void 0?!1:g;if(!p&&f)throw new Error("Contours can't be empty");if(!!p){var y=new Gv;n.edgeCreateCallback&&(y.edgeCreateCallback=n.edgeCreateCallback),n.vertexIdCallback&&(y.vertexIdCallback=n.vertexIdCallback);for(var v=0;v<p.length;v++)y.addContour(l||2,p[v]);return y.tesselate(e,o,s,l,u,f),{vertices:y.vertices,vertexIndices:y.vertexIndices,vertexCount:y.vertexCount,elements:y.elements,elementCount:y.elementCount,mesh:x?y.mesh:void 0}}}var mM=Be.ODD,dM=Be.NONZERO,fM=Be.POSITIVE,hM=Be.NEGATIVE,gM=Be.ABS_GEQ_TWO,yM=Ze.POLYGONS,xM=Ze.CONNECTED_POLYGONS,vM=Ze.BOUNDARY_CONTOURS;var ln=class extends go.BufferGeometry{constructor(e,t=12,o={}){super();this.type="ShapeGeometry";this.windingRule=Be.ODD;this.elementType=Ze.POLYGONS;this.polySize=3;this.vertexSize=2;this.strict=!0;this._shape=e,this._curveSegments=t,this._triangulationOptions=Object.assign({windingRule:Be.ODD,elementType:Ze.POLYGONS,polySize:3,vertexSize:2,strict:!0},o);let i=this._shape.extractShapePointsToFlatArray([],this._curveSegments),s=this._shape.shapeHoles.map(f=>f.extractShapePointsToFlatArray([],this._curveSegments)),a,l=!0,c=!0,u,m;for(let f=0,g=i.length/2;f<g;f++){let x=f*2,y=i[x+0],v=i[x+1];if(u!==void 0&&y!==u&&(l=!1),m!==void 0&&v!==m&&(c=!1),u=y,m=v,!l&&!c)break}!l&&!c&&(a=ho({contours:[i,...s],windingRule:this._triangulationOptions.windingRule,elementType:this._triangulationOptions.elementType,polySize:this._triangulationOptions.polySize,vertexSize:this._triangulationOptions.vertexSize,strict:this._triangulationOptions.strict}));let p=a?.vertexCount??1,d=a?.elementCount??1;if(this._positionAttribute=new go.BufferAttribute(new Float32Array(p*3),3),this._normalAttribute=new go.BufferAttribute(new Float32Array(p*3),3),this._uvAttribute=new go.BufferAttribute(new Float32Array(p*2),2),this._indexAttribute=new go.BufferAttribute(new Uint32Array(d*3),1),a){let f=1/0,g=-1/0,x=1/0,y=-1/0;for(let S=0,b=p;S<b;S++){let E=S*2,w=a.vertices[E+0],h=a.vertices[E+1];w<f&&(f=w),w>g&&(g=w),h<x&&(x=h),h>y&&(y=h)}let v=g-f,P=y-x;for(let S=0,b=p;S<b;S++){let E=S*2,w=a.vertices[E+0],h=a.vertices[E+1],_=(w-f)/v,N=(h-x)/P;this._positionAttribute.setXYZ(S,w,h,0),this._normalAttribute.setXYZ(S,0,0,1),this._uvAttribute.setXY(S,_,N)}for(let S=0,b=d;S<b;S++){let E=S*3,w=a.elements[E+0],h=a.elements[E+1],_=a.elements[E+2];this._indexAttribute.setX(E+0,w),this._indexAttribute.setX(E+1,h),this._indexAttribute.setX(E+2,_)}}this.setAttribute("position",this._positionAttribute),this.setAttribute("normal",this._normalAttribute),this.setAttribute("uv",this._uvAttribute),this.setIndex(this._indexAttribute),this.setDrawRange(0,(a?.elementCount??1)*3)}clone(){let e=new ln(this._shape,this._curveSegments);return e.userData=jn(this.userData),e}};var yo=require("three");var Ys=class{constructor(r=256,e=!1){this.capacity=r,this.size=0,this.debug=e,this.debug&&console.log(`allocating with cap ${r}`);let t=r*Ys.eSize;this.buffer=new ArrayBuffer(t);let o=Float32Array.BYTES_PER_ELEMENT,i=0;this.positions=new Float32Array(this.buffer,i*o,3*r),i+=3*r,this.normals=new Float32Array(this.buffer,i*o,3*r),i+=3*r,this.uvs=new Float32Array(this.buffer,i*o,2*r)}realloc(r,e=!1){if(r<this.size)throw Error("cannot shrink buffer");if(r<=this.capacity&&!e)return;this.debug&&console.log(`resizing from ${this.capacity} \u2192 ${r}`);let t=r*Ys.eSize,o=new ArrayBuffer(t),i=Float32Array.BYTES_PER_ELEMENT,s=0,a=new Float32Array(o,s*i,3*r);s+=3*r;let l=new Float32Array(o,s*i,3*r);s+=3*r;let c=new Float32Array(o,s*i,2*r);a.set(this.positions.slice(0,this.size*3)),l.set(this.normals.slice(0,this.size*3)),c.set(this.uvs.slice(0,this.size*2)),this.buffer=o,this.positions=a,this.normals=l,this.uvs=c,this.capacity=r}get(r=1){let e=this.size+r;if(e>this.capacity){let o=this.capacity;for(;e>o;)o*=2;this.realloc(o)}let t=this.size;return this.size=e,t}reserve(r){let e=this.size+r;e>this.capacity&&this.realloc(e)}shrink(){this.debug&&console.log(`shrinking ${this.capacity} \u2192 ${this.size}`),this.realloc(this.size,!0)}},oi=Ys;oi.eSize=(3+3+2)*Float32Array.BYTES_PER_ELEMENT;var yl=(n,r)=>([e,t])=>(t<e&&(t+=r),(n>=e?n:n+r)<=t),cn=class extends yo.BufferGeometry{constructor(e,t,o=0,i=12,s=3){super();this.type="ShapeGeometry";this.vertexCache={};this._shape=e,this._depth=t,this._bevel=o,this._curveSegments=i,this._bevelSegmentsInput=s,o<=0?(this._bevelSize=0,this._bevelSegments=0):(this._bevelSize=Math.min(o,t/2-1e-12),this._bevelSegments=Math.floor(s));let a=this._shape.extractShapePointsToFlatArray([],i),l=this._shape.shapeHoles.map(w=>{let h=w.extractShapePointsToFlatArray([],i),_=[];for(let N=h.length-1;N>=1;N-=2){let I=h[N-1],L=h[N-0];_.push(I,L)}return _}),c=ho({windingRule:Be.ODD,elementType:Ze.BOUNDARY_CONTOURS,vertexSize:2,strict:!0,contours:[a]}),u=ho({windingRule:Be.ODD,elementType:Ze.BOUNDARY_CONTOURS,vertexSize:2,strict:!0,contours:[...l]});if(!c)throw new Error("error generating geometry");let m=c.elementCount;if(u){c.elementCount+=u.elementCount;for(let w=0;w<u.elements.length;w++){let h=u.elements[w],_=w%2===0?c.vertexCount:0;c.elements.push(h+_)}for(let w=0;w<u.vertexIndices.length;w++){let h=u.vertexIndices[w],_=c.vertexCount;c.vertexIndices.push(h+_)}for(let w=0;w<u.vertices.length;w++){let h=u.vertices[w];c.vertices.push(h)}}let p=1/0,d=-1/0,f=1/0,g=-1/0;for(let w=0,h=c.vertexCount;w<h;w++){let _=w*2,N=c.vertices[_+0],I=c.vertices[_+1];N<p&&(p=N),N>d&&(d=N),I<f&&(f=I),I>g&&(g=I)}this._minX=p,this._minY=f,this._width=d-p,this._height=g-f;let x=c.vertexCount*2*(2+this._bevelSegments);this._buffer=new oi(x);let y=[],v=[];for(let w=c.elementCount-1;w>=0;w--){let h=w>=m,_=w*2,N=c.elements[_+0],I=c.elements[_+1],L=N+I,A={start:N,count:I,normals:[],continuous:[],concave:[]},k=N,q=L-1,ne=N+1,ue=this._shape.roundedCurves.length;do{let z=k-N,B=c.vertices[q*2+0],D=c.vertices[q*2+1],M=c.vertices[k*2+0],G=c.vertices[k*2+1],Q=c.vertices[ne*2+0],j=c.vertices[ne*2+1],V=M-B,F=G-D,O=Math.sqrt(V*V+F*F);V/=O,F/=O;let $=M-Q,Z=G-j,ee=Math.sqrt($*$+Z*Z);$/=ee,Z/=ee,A.normals[z*2+0]=-Z,A.normals[z*2+1]=$,A.concave[z]=V*Z-F*$>0;let H=c.vertexIndices[k];if(Array.isArray(H))A.continuous[z]=!1;else{let[J,X]=this._shape.getCurveIndexFromVertexId(H-1,!0);if(X>0&&X<1)A.continuous[z]=!0;else{let re=X===1?J+1:J-1;re=(re+ue)%ue;let ce=X===1?0:1,ie=this._shape.roundedCurves[J].getTangent(X),fe=this._shape.roundedCurves[re].getTangent(ce);A.continuous[z]=ie.dot(fe)>.95}}h&&(A.normals[z*2+0]*=-1,A.normals[z*2+1]*=-1),[q,k,ne]=[k,ne,ne+1],ne>=L&&(ne-=I)}while(ne!==N+1);let se=[];se.push({bevelI:0,angle:0,size:0,boundary:{vertices:c.vertices.slice(N*2,L*2),vertexCount:I,vertexIndices:new Array(I).fill(!0).map((z,B)=>[B,B]),elements:[0,I],elementCount:1,mesh:null},reverseMap:[],insetPoints:c.vertices.slice(N*2,L*2)});for(let z=1;z<=this._bevelSegments;z++){let B=z/this._bevelSegments*Math.PI/2,D=(1-Math.cos(B))*this._bevelSize,M=[],G=[],Q=[],j=[],V=0;for(let O=0;O<I;O++){let $=O*2,Z=(O-1+I)%I*2,ee=c.vertices[A.start*2+$+0],H=c.vertices[A.start*2+$+1],J=-A.normals[Z+0]*D,X=-A.normals[Z+1]*D,re=-A.normals[$+0]*D,ce=-A.normals[$+1]*D;if(A.concave[O]||!A.concave[O]&&h){let ie=Math.atan2(X,J),fe=Math.atan2(ce,re);fe>ie&&(fe-=Math.PI*2);let ze=fe-ie;if(A.continuous[O]||h){let ye=ie+ze/2,$e=Math.cos(ye)*D,Ce=Math.sin(ye)*D;M[2*V+0]=ee+$e*(h?-1:1),M[2*V+1]=H+Ce*(h?-1:1),j[V]=O,V++}else{let ye=Math.max(1,Math.floor(i/4*Math.abs(ze)/Math.PI));for(let $e=0;$e<=ye;$e++){let Ce=ie+ze*($e/ye),Nt=Math.cos(Ce)*D,Vt=Math.sin(Ce)*D;M[2*V+0]=ee+Nt,M[2*V+1]=H+Vt,j[V]=O,V++}}}else M[2*V+0]=ee+J,M[2*V+1]=H+X,j[V]=O,G[O]=V,V++,M[2*V+0]=ee,M[2*V+1]=H,j[V]=O,V++,M[2*V+0]=ee+re,M[2*V+1]=H+ce,j[V]=O,Q[O]=V,V++}let F=ho({windingRule:Be.POSITIVE,elementType:Ze.BOUNDARY_CONTOURS,vertexSize:2,strict:!0,contours:[M],edgeCreateCallback:O=>{let Z=O.Org.idx,ee=j[Z],H=j[(Z+1)%j.length];O.idx=[ee,H],O.Sym.idx=[H,ee]},vertexIdCallback:O=>{let $=O.Lprev.idx;return[$?$[1]:0,O.idx[0]]}});if(!F)throw console.log("Error"),new Error(`error generating bevel geometry for ${z}'th loop`);if(!F.vertexCount)break;for(let O=0;O<F.vertexIndices.length;O++){let[$,Z]=F.vertexIndices[O];if($===Z)continue;let ee=Z;Z<$&&(ee+=I);for(let H=$;H<ee;H++){let J=H%I,X=(H+1)%I;if(!A.continuous[J]||!A.continuous[X]){F.vertexIndices[O]=[$,J],F.vertexIndices.splice(O+1,0,[X,Z]),F.vertices.splice((O+1)*2,0,F.vertices[O*2],F.vertices[O*2+1]);break}}}se.push({bevelI:z,angle:B,size:D,boundary:F,reverseMap:j,insetPoints:M})}let K=(z,B,D)=>{let M=0,G=z.boundary.vertexIndices.length;for(;M<G&&D(z.boundary.vertexIndices[B]);)B=(B+1)%G,M++;return M},U=y.length;for(let z=1;z<se.length;z++){let B=se[z-1],D=se[z],M=B.boundary.vertexIndices.length,G=D.boundary.vertexIndices.length;if(!M||!G)break;let Q=A.concave.length,j=0,V=yl(j,I);for(;!B.boundary.vertexIndices.filter(V).length||!D.boundary.vertexIndices.filter(V).length;)j++,V=yl(j,I);let F=B.boundary.vertexIndices.findIndex(V),O=D.boundary.vertexIndices.findIndex(V);do F=(F+1)%M;while(V(B.boundary.vertexIndices[F]));do O=(O+1)%G;while(V(D.boundary.vertexIndices[O]));j=(j+1)%I;let $=j,Z=this.buildBevelVert(A,B,(F-1+M)%M),ee=this.buildBevelVert(A,D,(O-1+G)%G),H=Z,J=ee,X,re,ce=!1;do{V=yl(j,I);let ie=K(B,F,V),fe=K(D,O,V),ze=ce;if(ce=!1,ie&&!fe){for(let ye=0;ye<ie;ye++)X=this.buildBevelVert(A,B,(F+ye)%M,ye/(ie-1)),y.push(H.topN,X.topP,J.topN),y.push(X.bottomP,H.bottomN,J.bottomN),H=X;ce=!0}else if(!ie&&fe)for(let ye=0;ye<fe;ye++)re=this.buildBevelVert(A,D,(O+ye)%G,ye/(fe-1)),y.push(J.topN,H.topP,re.topP),y.push(H.bottomP,J.bottomN,re.bottomP),J=re;else if(ie&&fe)if(X=this.buildBevelVert(A,B,F,0),re=this.buildBevelVert(A,D,O,0),ze?(y.push(H.topN,re.topP,J.topN),y.push(H.topN,X.topP,re.topP),y.push(re.bottomP,H.bottomN,J.bottomN),y.push(re.bottomP,X.bottomP,H.bottomN)):(y.push(J.topN,H.topN,X.topP),y.push(J.topN,X.topP,re.topP),y.push(X.bottomP,H.bottomN,J.bottomN),y.push(X.bottomP,J.bottomN,re.bottomP)),H=X,J=re,ie===fe)for(let ye=1;ye<ie;ye++)X=this.buildBevelVert(A,B,(F+ye)%M,ye/(ie-1)),re=this.buildBevelVert(A,D,(O+ye)%G,ye/(fe-1)),y.push(H.topN,X.topP,J.topN),y.push(J.topN,X.topP,re.topP),y.push(X.bottomP,H.bottomN,J.bottomN),y.push(X.bottomP,J.bottomN,re.bottomP),H=X,J=re;else if(ie>fe){let ye=ie/fe,$e=0;for(let Ce=1;Ce<ie;Ce++)X=this.buildBevelVert(A,B,(F+Ce)%M,Ce/(ie-1)),y.push(H.topN,X.topP,J.topN),y.push(X.bottomP,H.bottomN,J.bottomN),H=X,Ce>($e+1)*ye&&($e++,re=this.buildBevelVert(A,D,(O+$e)%G,$e/(fe-1)),y.push(J.topN,X.topP,re.topP),y.push(X.bottomP,J.bottomN,re.bottomP),J=re)}else{let ye=fe/ie,$e=0;for(let Ce=1;Ce<fe;Ce++)re=this.buildBevelVert(A,D,(O+Ce)%G,Ce/(fe-1)),y.push(J.topN,X.topP,re.topP),y.push(X.bottomP,J.bottomN,re.bottomP),J=re,Ce>($e+1)*ye&&($e++,X=this.buildBevelVert(A,B,(F+$e)%M,$e/(ie-1)),y.push(H.topN,X.topP,J.topN),y.push(X.bottomP,H.bottomN,J.bottomN),H=X)}F=(F+ie)%M,O=(O+fe)%G,j=(j+1)%Q}while(j!==$)}{let z=se[0];for(let B=0,D=z.boundary.vertexCount;B<D;B++){let M=this.buildBevelVert(A,z,B),G=this.buildBevelVert(A,z,(B+1)%D);y.push(G.topP,M.topN,M.bottomN),y.push(G.topP,M.bottomN,G.bottomP)}}if(h){let z=[];for(let B=y.length-1;B>=U+2;B-=3){let D=y[B-2],M=y[B-1],G=y[B-0];z.push(G,M,D)}y.splice(U,y.length-U,...z)}if(h){let z=[];for(let B=se[se.length-1].boundary.vertices.length-1;B>=1;B-=2){let D=se[se.length-1].boundary.vertices[B-1],M=se[se.length-1].boundary.vertices[B-0];z.push(D,M)}v.push(z)}if(!h){let z=se[se.length-1],B=ho({windingRule:se.length>1?Be.POSITIVE:Be.ODD,elementType:Ze.POLYGONS,vertexSize:2,strict:!0,contours:[z.insetPoints,...v]});if(!B)throw new Error("Error generating geometry for surface");l.length===0&&Object.assign(this,{capStartIndex:y.length});for(let D=0;D<B.elementCount*3;D+=3){let M=this.buildSurfaceVert(B,B.elements[D+0]),G=this.buildSurfaceVert(B,B.elements[D+1]),Q=this.buildSurfaceVert(B,B.elements[D+2]);y.push(M.top,G.top,Q.top),y.push(Q.bottom,G.bottom,M.bottom)}}this.vertexCache={}}this._buffer.shrink();let P=new yo.BufferAttribute(Uint32Array.from(y),1),S=new yo.BufferAttribute(this._buffer.positions,3),b=new yo.BufferAttribute(this._buffer.normals,3),E=new yo.BufferAttribute(this._buffer.uvs,2);S.needsUpdate=!0,b.needsUpdate=!0,E.needsUpdate=!0,P.needsUpdate=!0,this.setAttribute("position",S),this.setAttribute("normal",b),this.setAttribute("uv",E),this.setIndex(P)}buildSurfaceVert(e,t){let o=t.toString();if(o in this.vertexCache)return this.vertexCache[o];let i=e.vertices[t*2+0],s=e.vertices[t*2+1],a=(i-this._minX)/this._width,l=(s-this._minY)/this._height,c=this._buffer.get(2),u=c*3,m=c*2,p={top:c+0,bottom:c+1};return this._buffer.positions[u+0]=i,this._buffer.positions[u+1]=s,this._buffer.positions[u+2]=this._depth,this._buffer.normals[u+0]=0,this._buffer.normals[u+1]=0,this._buffer.normals[u+2]=1,this._buffer.uvs[m+0]=a,this._buffer.uvs[m+1]=l,this._buffer.positions[u+3]=i,this._buffer.positions[u+4]=s,this._buffer.positions[u+5]=0,this._buffer.normals[u+3]=0,this._buffer.normals[u+4]=0,this._buffer.normals[u+5]=-1,this._buffer.uvs[m+2]=a,this._buffer.uvs[m+3]=l,this.vertexCache[o]=p,p}buildBevelVert(e,t,o,i=1){let s=`${t.bevelI}:${o}`;if(s in this.vertexCache)return this.vertexCache[s];let[a,l]=t.boundary.vertexIndices[o],c,u,m,p;a!==l?(u=a,c=l,p=!1,m=e.continuous[u]&&e.continuous[c]):(c=a,u=(c-1+e.count)%e.count,p=e.concave[c]&&t.bevelI>0,m=e.continuous[c]||p);let d=Math.cos(t.angle),f=Math.sin(t.angle),g=o*2,x=c*2,y=u*2,v=t.boundary.vertices[g+0],P=t.boundary.vertices[g+1],S=(1-f)*this._bevelSize,b=(v-this._minX)/this._width,E=(P-this._minY)/this._height,w=e.normals[x+0],h=e.normals[x+1],_=e.normals[y+0],N=e.normals[y+1];if(p){let q=_-w,ne=N-h;w=w+q*(1-i),h=h+ne*(1-i);let ue=Math.sqrt(w*w+h*h);w/=ue,h/=ue}let I=this._buffer.get(m?2:4),L=I*3,A=I*2,k={i:o,fi:c,topP:I+0,topN:I+0,bottomP:I+1,bottomN:I+1};return this._buffer.positions[L+0]=v,this._buffer.positions[L+1]=P,this._buffer.positions[L+2]=this._depth-S,this._buffer.normals[L+0]=w*d,this._buffer.normals[L+1]=h*d,this._buffer.normals[L+2]=f,this._buffer.uvs[A+0]=b,this._buffer.uvs[A+1]=E,this._buffer.positions[L+3]=v,this._buffer.positions[L+4]=P,this._buffer.positions[L+5]=S,this._buffer.normals[L+3]=w*d,this._buffer.normals[L+4]=h*d,this._buffer.normals[L+5]=-f,this._buffer.uvs[A+2]=E,this._buffer.uvs[A+3]=b,m||(I+=2,L+=6,A+=4,k.topP=I+0,k.bottomP=I+1,this._buffer.positions[L+0]=v,this._buffer.positions[L+1]=P,this._buffer.positions[L+2]=this._depth-S,this._buffer.normals[L+0]=_*d,this._buffer.normals[L+1]=N*d,this._buffer.normals[L+2]=f,this._buffer.uvs[A+0]=b,this._buffer.uvs[A+1]=E,this._buffer.positions[L+3]=v,this._buffer.positions[L+4]=P,this._buffer.positions[L+5]=S,this._buffer.normals[L+3]=_*d,this._buffer.normals[L+4]=N*d,this._buffer.normals[L+5]=-f,this._buffer.uvs[A+2]=E,this._buffer.uvs[A+3]=b),this.vertexCache[s]=k,k}clone(){let e=new cn(this._shape,this._depth,this._bevel,this._curveSegments,this._bevelSegmentsInput);return e.userData=jn(this.userData),e}};var bt=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,subdivisions:40,roundness:0,extrudeBevelSize:0,extrudeBevelSegments:3},n.parameters),t=Math.abs(e.width),o=Math.abs(e.height??e.width),i=Math.abs(e.depth??0),s=n.shape??r?.shape,a=s?.roundness??e.roundness;s!==void 0&&(s instanceof Le?(s.width!==t||s.height!==o)&&s.applySize(t,o):s=new Le(t,o).fromJSON(s),n.parameters?.roundness!==void 0&&n.parameters?.roundness>0&&s.update(!1));let l=s??new Le(t,o);return{parameters:Object.assign(e,{width:t,height:o,depth:i,roundness:a}),shape:l}}static build(n){let{depth:r,extrudeBevelSize:e,extrudeBevelSegments:t,subdivisions:o,roundness:i}=n.parameters;n.shape.roundness=i;let s;return r<=0?s=new ln(n.shape,o):s=new cn(n.shape,r,e,o,t),Object.assign(s,{userData:{...n,type:"VectorGeometry"}})}};var pn=require("three"),Pm=Math.PI*2,Am=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,depth:0,spikes:64,angle:360,innerRadius:0,extrudeBevelSize:0,extrudeBevelSegments:1},n.parameters);return{shape:n.shape&&n.shape instanceof Le?n.shape:new Le,parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??0)})}}static build(n){let{width:r,height:e,spikes:t,angle:o,innerRadius:i,depth:s,extrudeBevelSize:a,extrudeBevelSegments:l}=n.parameters,c=n.shape,u=r*.5,m=e*.5,p=Rv(c,u,m,o*Math.PI/180,t,i);c.isClosed=!0,c.update();let d=bt.create({shape:c,parameters:{subdivisions:p,depth:s,extrudeBevelSize:a,extrudeBevelSegments:l}});return Object.assign(d,{userData:{...n,type:"EllipseGeometry"}})}};function Rv(n,r,e,t,o,i){if(t>=Pm)return o>30||o%4===0?(Vv(n,r,e,i),Math.round(o/4)):Im(n,t,o,r,e,i);let s={x:0,y:e},a=t+Math.PI*.5,l={x:Math.cos(a)*r,y:Math.sin(a)*e},c=wm({px:s.x,py:s.y,cx:l.x,cy:l.y,rx:r,ry:e,largeArcFlag:t>Math.PI,sweepFlag:!0});return o>30||o%c.length===0?zv(n,s.x,s.y,c,o,r,e,i):Im(n,t,o,r,e,i)}function zv(n,r,e,t,o,i,s,a){let l=Math.round(o/t.length);n.addPoint(un(r,e));for(let c=0,u=t.length;c<u;c++){let m=t[c],p=n.points[c],d=un(m.x,m.y);p.controls[1].position.set(m.x1,m.y1),d.controls[0].position.set(m.x2,m.y2),n.addPoint(d)}return a>0?Mm(n,i,s,a):n.addPoint(un(0,0)),l}function Im(n,r,e,t,o,i){let s=-r/e;for(let a=0;a<=e;a++){let l=s*a,c=Math.sin(l)*t,u=Math.cos(l)*o;n.addPoint(un(c,u))}return r<Pm?i>0?Mm(n,t,o,i):n.addPoint(un(0,0)):(n.removePoint(n.points[n.points.length-1]),i>0&&Om(n,t,o,i)),1}function Vv(n,r,e,t=0,o=0,i=0){let s=.5522847498,a=r*s,l=e*s;n.addPoint(Ks(o-r,i,o-r,i-l,o-r,i+l)),n.addPoint(Ks(o,i+e,o-a,i+e,o+a,i+e)),n.addPoint(Ks(o+r,i,o+r,i+l,o+r,i-l)),n.addPoint(Ks(o,i-e,o+a,i-e,o-a,i-e)),t>0&&Om(n,r,e,t)}function un(n,r){return new Xt(pn.MathUtils.generateUUID(),new pn.Vector2(n,r))}function Ks(n,r,e,t,o,i){let s=un(n,r);return s.controls[0].position.set(e,t),s.controls[1].position.set(o,i),s}function Mm(n,r,e,t){_m(n,r,e,t).forEach(i=>n.addPoint(i))}function Om(n,r,e,t){let o=_m(n,r,e,t),i=new Le;o.forEach(s=>i.addPoint(s)),i.isClosed=!0,n.shapeHoles.push(i)}function _m(n,r,e,t){let o=t*r/100,i=o*(Math.abs(e)/Math.abs(r)),s=new pn.Vector2(o/r,i/e),a=n.points.map(l=>{let c=l.clone();return c.uuid=pn.MathUtils.generateUUID(),c}).reverse();return a.forEach(l=>{l.position.multiply(s);let c=l.controls[0].position.clone().multiply(s),u=l.controls[1].position.clone().multiply(s);l.controls[0].position.copy(u),l.controls[1].position.copy(c)}),a}var Br=require("three"),Dm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,revolutions:2,segments:40,pathRadius:10,pathType:0,pathSegments:30,cornerRadius:30,cornerSegments:4},n.parameters),t=Math.abs(e.width),o=Math.abs(e.height??t),i=Math.abs(e.depth??t),s=Math.abs(Math.min(t,i))/2;return{parameters:Object.assign(e,{width:t,height:o,depth:i,radius:s,segments:Math.round(e.segments),pathSegments:Math.round(e.pathSegments),cornerSegments:Math.round(e.cornerSegments)})}}static build(n){let{width:r,height:e,depth:t,radius:o,revolutions:i,segments:s,pathRadius:a,pathType:l,pathSegments:c,cornerRadius:u,cornerSegments:m}=n.parameters,p=new ni(!1,r,e,t,o,i,s,a,l,c,u,m);return Object.assign(p,{userData:{...n,type:"HelixGeometry"}})}},ni=class extends Br.BufferGeometry{constructor(r=!0,e=1,t=1,o=1,i=1,s=1,a=1,l=1,c=1,u=1,m=1,p=1){super();let d=r&&s===1;d&&(p=0),m>100&&(m=100);let f=()=>new Br.Vector3,g=new Br.Vector3,x=f(),y=f(),v=f(),P,S,b,E,w,h,_,N,I=f(),L=f(),A=f(),k=f(),q=f(),ne=f(),ue=f(),se=f(),K=t-2*l+.001,U=K/s,z=Math.ceil(a*s),B=z+1,D=K/z,M=-K/2,G=u+1,Q=2*Math.PI/u,j=Math.PI/2/p,V=.01,F=Math.min((1-m/100)*l,l-V),O=l-F,$=0,Z=2,ee=p*Z+Z,H=G*ee/Z,J=H+G*B,X=G*(B+ee),[re,ce,ie]=[3,3,2].map(ke=>Array(X*ke).fill(0)),fe=[],ze=i-l;function ye(ke,Dt){let nr=Math.PI/2;h=Dt*D,N=2*Math.PI*(h%U)/U+nr,h+=M,_=Math.sin(N)*ze,w=Math.cos(N)*ze,r?ke.set(w,_,h):ke.set(w,h,_)}ye(g,-1e-10),ye(x,0),I.copy(g),ye(g,1);let $e=g.distanceTo(x),Ce=O+F,Nt=$e*z+2*Ce,Vt=F,Ao=Nt-Ce;for(let ke=0;ke<=z;ke++){ye(y,ke),se.subVectors(y,I).normalize(),I.copy(y),ne.copy(y).setComponent(+r+1,0).normalize(),ue.crossVectors(se,ne).normalize();let Dt=ke===0,nr=ke===z,gf=Dt?3*Math.PI/2:j,yf=Dt?Vt:Ao,xf=Dt?G:J,vf=Dt?0:X-G,bf=se.clone().multiplyScalar(Dt?-O:O).add(y),Sf=se.clone().multiplyScalar(Dt?-1:1).normalize();for(let Ir=0;Ir<G;Ir++){let lc=Ir*Q;if(L.addVectors(g.copy(ne).multiplyScalar(l*Math.cos(lc)),x.copy(ue).multiplyScalar(l*Math.sin(lc))),A.copy(L).normalize(),Dt||nr){d||($=vf+Ir,[0,1,2].forEach(Ct=>{re[$*3+Ct]=bf.getComponent(Ct),ce[$*3+Ct]=Sf.getComponent(Ct)}),ie[$*2]=+nr,ie[$*2+1]=Ir/u),x.copy(A).multiplyScalar(F),v.addVectors(y,x);for(let Ct=0;Ct<p;Ct++){let Ma=Ct*j+gf;k.addVectors(g.copy(se).multiplyScalar(O*Math.sin(Ma)),x.copy(A).multiplyScalar(O*Math.cos(Ma))),q.copy(k).normalize(),x.addVectors(v,k),k.normalize(),$=xf+Ct*G+Ir,[0,1,2].forEach(Ui=>{re[$*3+Ui]=x.getComponent(Ui),ce[$*3+Ui]=q.getComponent(Ui)});let wf=+Dt+Math.sin(Ma);ie[$*2]=(yf+O*wf)/Nt,ie[$*2+1]=Ir/u}}x.addVectors(y,L),$=H+ke*G+Ir,[0,1,2].forEach(Ct=>{re[$*3+Ct]=x.getComponent(Ct),ce[$*3+Ct]=A.getComponent(Ct)}),ie[$*2]=(Ce+ke*$e)/Nt,ie[$*2+1]=Ir/u}}let _t=B+2*p+Z,Mo=1,[Vi,Fi]=d?[Mo,Mo+B-1]:[0,_t-1];for(let ke=Vi;ke<=Fi-1;ke++){let Dt=d&&ke===Fi-1;for(let nr=0;nr<G-1;nr++)P=ke*G+nr,S=P+1,b=(Dt?nr:P)+G,E=(Dt?nr+1:S)+G,ke===0?fe.push(S,E,b):ke===_t-2?fe.push(P,S,b):fe.push(P,S,b,S,E,b)}this.setIndex(fe),this.setAttribute("position",new Br.Float32BufferAttribute(re,3)),this.setAttribute("normal",new Br.Float32BufferAttribute(ce,3)),this.setAttribute("uv",new Br.Float32BufferAttribute(ie,2))}};var Em=require("three");var Bm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,detail:0,corner:0,cornerSides:4},n.parameters);return{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??e.width)})}}static build(n){let{width:r,height:e,depth:t,detail:o,corner:i,cornerSides:s}=n.parameters,a=o===0&&i!==0?new ii(r*.5,i,s):new Em.IcosahedronBufferGeometry(r*.5,o);return a.scale(1,e/r,t/r),Object.assign(a,{userData:{...n,type:"IcosahedronGeometry"}})}},ii=class extends Kr{constructor(r=1,e=.2,t=4){let o=(1+Math.sqrt(5))/2,i=[-1,o,0,1,o,0,-1,-o,0,1,-o,0,0,-1,o,0,1,o,0,-1,-o,0,1,-o,o,0,-1,o,0,1,-o,0,-1,-o,0,1],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],a="IcosahedronGeometry";super(i,s,a,r,e,t),this.type=a}static fromJSON(r){return new ii(r.radius,r.corner,r.cornerSides)}};var Qs=require("three"),Gm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){(n.parameters?.points??[]).forEach(t=>{Array.isArray(t)&&(t.x=t[0],t.y=t[1])});let e=Object.assign({},r?.parameters??{width:100,segments:64,verticalSegments:64,points:[{x:0,y:-50,id:0},{x:50,y:-50,id:1},{x:50,y:50,id:2},{x:0,y:50,id:3}]},n.parameters);return{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??e.width)})}}static build(n){let{points:r,segments:e,verticalSegments:t}=n.parameters,o=new Qs.Shape;o.moveTo(r[0].x,r[0].y),o.bezierCurveTo(r[1].x,r[1].y,r[2].x,r[2].y,r[3].x,r[3].y);let i=new Qs.LatheBufferGeometry(o.extractPoints(t).shape,e);return i.rotateZ(Math.PI),Object.assign(i,{userData:{...n,type:"LatheGeometry"}})}};var mr=require("three");var Gr=require("three");var oe=require("three"),pr=new oe.Matrix4,xl=new oe.Object3D,Js=new oe.Vector3,Jr=class extends oe.EventDispatcher{constructor(){super(),this.uuid=oe.MathUtils.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}applyMatrix4(r){let e=new oe.Matrix3().getNormalMatrix(r);for(let t=0,o=this.vertices.length;t<o;t++)this.vertices[t].applyMatrix4(r);for(let t=0,o=this.faces.length;t<o;t++){let i=this.faces[t];i.normal.applyMatrix3(e).normalize();for(let s=0,a=i.vertexNormals.length;s<a;s++)i.vertexNormals[s].applyMatrix3(e).normalize()}return this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this}rotateX(r){return pr.makeRotationX(r),this.applyMatrix4(pr),this}rotateY(r){return pr.makeRotationY(r),this.applyMatrix4(pr),this}rotateZ(r){return pr.makeRotationZ(r),this.applyMatrix4(pr),this}translate(r,e,t){return pr.makeTranslation(r,e,t),this.applyMatrix4(pr),this}scale(r,e,t){return pr.makeScale(r,e,t),this.applyMatrix4(pr),this}lookAt(r){return xl.lookAt(r),xl.updateMatrix(),this.applyMatrix4(xl.matrix),this}fromBufferGeometry(r){let e=this,t=r.index!==null?r.index:void 0,o=r.attributes;if(o.position===void 0)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;let i=o.position,s=o.normal,a=o.color,l=o.uv,c=o.uv2;c!==void 0&&(this.faceVertexUvs[1]=[]);for(let p=0;p<i.count;p++)e.vertices.push(new oe.Vector3().fromBufferAttribute(i,p)),a!==void 0&&e.colors.push(new oe.Color().fromBufferAttribute(a,p));function u(p,d,f,g){let x=a===void 0?[]:[e.colors[p].clone(),e.colors[d].clone(),e.colors[f].clone()],y=s===void 0?[]:[new oe.Vector3().fromBufferAttribute(s,p),new oe.Vector3().fromBufferAttribute(s,d),new oe.Vector3().fromBufferAttribute(s,f)],v=new mn(p,d,f,y,x,g);e.faces.push(v),l!==void 0&&e.faceVertexUvs[0].push([new oe.Vector2().fromBufferAttribute(l,p),new oe.Vector2().fromBufferAttribute(l,d),new oe.Vector2().fromBufferAttribute(l,f)]),c!==void 0&&e.faceVertexUvs[1].push([new oe.Vector2().fromBufferAttribute(c,p),new oe.Vector2().fromBufferAttribute(c,d),new oe.Vector2().fromBufferAttribute(c,f)])}let m=r.groups;if(m.length>0)for(let p=0;p<m.length;p++){let d=m[p],f=d.start,g=d.count;for(let x=f,y=f+g;x<y;x+=3)t!==void 0?u(t.getX(x),t.getX(x+1),t.getX(x+2),d.materialIndex):u(x,x+1,x+2,d.materialIndex)}else if(t!==void 0)for(let p=0;p<t.count;p+=3)u(t.getX(p),t.getX(p+1),t.getX(p+2));else for(let p=0;p<i.count;p+=3)u(p,p+1,p+2);return this.computeFaceNormals(),r.boundingBox!==null&&(this.boundingBox=r.boundingBox.clone()),r.boundingSphere!==null&&(this.boundingSphere=r.boundingSphere.clone()),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Js).negate(),this.translate(Js.x,Js.y,Js.z),this}normalize(){this.computeBoundingSphere();let r=this.boundingSphere.center,e=this.boundingSphere.radius,t=e===0?1:1/e,o=new oe.Matrix4;return o.set(t,0,0,-t*r.x,0,t,0,-t*r.y,0,0,t,-t*r.z,0,0,0,1),this.applyMatrix4(o),this}computeFaceNormals(){let r=new oe.Vector3,e=new oe.Vector3;for(let t=0,o=this.faces.length;t<o;t++){let i=this.faces[t],s=this.vertices[i.a],a=this.vertices[i.b],l=this.vertices[i.c];r.subVectors(l,a),e.subVectors(s,a),r.cross(e),r.normalize(),i.normal.copy(r)}}computeVertexNormals(r=!0){let e=new Array(this.vertices.length);for(let t=0,o=this.vertices.length;t<o;t++)e[t]=new oe.Vector3;if(r){let t=new oe.Vector3,o=new oe.Vector3;for(let i=0,s=this.faces.length;i<s;i++){let a=this.faces[i],l=this.vertices[a.a],c=this.vertices[a.b],u=this.vertices[a.c];t.subVectors(u,c),o.subVectors(l,c),t.cross(o),e[a.a].add(t),e[a.b].add(t),e[a.c].add(t)}}else{this.computeFaceNormals();for(let t=0,o=this.faces.length;t<o;t++){let i=this.faces[t];e[i.a].add(i.normal),e[i.b].add(i.normal),e[i.c].add(i.normal)}}for(let t=0,o=this.vertices.length;t<o;t++)e[t].normalize();for(let t=0,o=this.faces.length;t<o;t++){let i=this.faces[t],s=i.vertexNormals;s.length===3?(s[0].copy(e[i.a]),s[1].copy(e[i.b]),s[2].copy(e[i.c])):(s[0]=e[i.a].clone(),s[1]=e[i.b].clone(),s[2]=e[i.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeFlatVertexNormals(){this.computeFaceNormals();for(let r=0,e=this.faces.length;r<e;r++){let t=this.faces[r],o=t.vertexNormals;o.length===3?(o[0].copy(t.normal),o[1].copy(t.normal),o[2].copy(t.normal)):(o[0]=t.normal.clone(),o[1]=t.normal.clone(),o[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeMorphNormals(){for(let e=0,t=this.faces.length;e<t;e++){let o=this.faces[e];o.__originalFaceNormal?o.__originalFaceNormal.copy(o.normal):o.__originalFaceNormal=o.normal.clone(),o.__originalVertexNormals||(o.__originalVertexNormals=[]);for(let i=0,s=o.vertexNormals.length;i<s;i++)o.__originalVertexNormals[i]?o.__originalVertexNormals[i].copy(o.vertexNormals[i]):o.__originalVertexNormals[i]=o.vertexNormals[i].clone()}let r=new Jr;r.faces=this.faces;for(let e=0,t=this.morphTargets.length;e<t;e++){if(!this.morphNormals[e]){this.morphNormals[e]={},this.morphNormals[e].faceNormals=[],this.morphNormals[e].vertexNormals=[];let i=this.morphNormals[e].faceNormals,s=this.morphNormals[e].vertexNormals;for(let a=0,l=this.faces.length;a<l;a++){let c=new oe.Vector3,u={a:new oe.Vector3,b:new oe.Vector3,c:new oe.Vector3};i.push(c),s.push(u)}}let o=this.morphNormals[e];r.vertices=this.morphTargets[e].vertices,r.computeFaceNormals(),r.computeVertexNormals();for(let i=0,s=this.faces.length;i<s;i++){let a=this.faces[i],l=o.faceNormals[i],c=o.vertexNormals[i];l.copy(a.normal),c.a.copy(a.vertexNormals[0]),c.b.copy(a.vertexNormals[1]),c.c.copy(a.vertexNormals[2])}}for(let e=0,t=this.faces.length;e<t;e++){let o=this.faces[e];o.normal=o.__originalFaceNormal,o.vertexNormals=o.__originalVertexNormals}}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new oe.Box3),this.boundingBox.setFromPoints(this.vertices)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new oe.Sphere),this.boundingSphere.setFromPoints(this.vertices)}merge(r,e,t=0){if(!(r&&r.isGeometry)){console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",r);return}let o,i=this.vertices.length,s=this.vertices,a=r.vertices,l=this.faces,c=r.faces,u=this.colors,m=r.colors;e!==void 0&&(o=new oe.Matrix3().getNormalMatrix(e));for(let p=0,d=a.length;p<d;p++){let g=a[p].clone();e!==void 0&&g.applyMatrix4(e),s.push(g)}for(let p=0,d=m.length;p<d;p++)u.push(m[p].clone());for(let p=0,d=c.length;p<d;p++){let f=c[p],g,x,y=f.vertexNormals,v=f.vertexColors,P=new mn(f.a+i,f.b+i,f.c+i);P.normal.copy(f.normal),o!==void 0&&P.normal.applyMatrix3(o).normalize();for(let S=0,b=y.length;S<b;S++)g=y[S].clone(),o!==void 0&&g.applyMatrix3(o).normalize(),P.vertexNormals.push(g);P.color.copy(f.color);for(let S=0,b=v.length;S<b;S++)x=v[S],P.vertexColors.push(x.clone());P.materialIndex=f.materialIndex+t,l.push(P)}for(let p=0,d=r.faceVertexUvs.length;p<d;p++){let f=r.faceVertexUvs[p];this.faceVertexUvs[p]===void 0&&(this.faceVertexUvs[p]=[]);for(let g=0,x=f.length;g<x;g++){let y=f[g],v=[];for(let P=0,S=y.length;P<S;P++)v.push(y[P].clone());this.faceVertexUvs[p].push(v)}}}mergeMesh(r){if(!(r&&r.isMesh)){console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",r);return}r.matrixAutoUpdate&&r.updateMatrix(),this.merge(r.geometry,r.matrix)}mergeVertices(r=4){let e={},t=[],o=[],i=Math.pow(10,r);for(let l=0,c=this.vertices.length;l<c;l++){let u=this.vertices[l],m=Math.round(u.x*i)+"_"+Math.round(u.y*i)+"_"+Math.round(u.z*i);e[m]===void 0?(e[m]=l,t.push(this.vertices[l]),o[l]=t.length-1):o[l]=o[e[m]]}let s=[];for(let l=0,c=this.faces.length;l<c;l++){let u=this.faces[l];u.a=o[u.a],u.b=o[u.b],u.c=o[u.c];let m=[u.a,u.b,u.c];for(let p=0;p<3;p++)if(m[p]===m[(p+1)%3]){s.push(l);break}}for(let l=s.length-1;l>=0;l--){let c=s[l];this.faces.splice(c,1);for(let u=0,m=this.faceVertexUvs.length;u<m;u++)this.faceVertexUvs[u].splice(c,1)}let a=this.vertices.length-t.length;return this.vertices=t,a}setFromPoints(r){this.vertices=[];for(let e=0,t=r.length;e<t;e++){let o=r[e];this.vertices.push(new oe.Vector3(o.x,o.y,o.z||0))}return this}sortFacesByMaterialIndex(){let r=this.faces,e=r.length;for(let l=0;l<e;l++)r[l]._id=l;function t(l,c){return l.materialIndex-c.materialIndex}r.sort(t);let o=this.faceVertexUvs[0],i=this.faceVertexUvs[1],s,a;o&&o.length===e&&(s=[]),i&&i.length===e&&(a=[]);for(let l=0;l<e;l++){let c=r[l]._id;s&&s.push(o[c]),a&&a.push(i[c])}s&&(this.faceVertexUvs[0]=s),a&&(this.faceVertexUvs[1]=a)}toJSON(){let r={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.parameters!==void 0){let f=this.parameters;for(let g in f)f[g]!==void 0&&(r[g]=f[g]);return r}let e=[];for(let f=0;f<this.vertices.length;f++){let g=this.vertices[f];e.push(g.x,g.y,g.z)}let t=[],o=[],i={},s=[],a={},l=[],c={};for(let f=0;f<this.faces.length;f++){let g=this.faces[f],x=!0,y=!1,v=this.faceVertexUvs[0][f]!==void 0,P=g.normal.length()>0,S=g.vertexNormals.length>0,b=g.color.r!==1||g.color.g!==1||g.color.b!==1,E=g.vertexColors.length>0,w=0;if(w=u(w,0,0),w=u(w,1,x),w=u(w,2,y),w=u(w,3,v),w=u(w,4,P),w=u(w,5,S),w=u(w,6,b),w=u(w,7,E),t.push(w),t.push(g.a,g.b,g.c),t.push(g.materialIndex),v){let h=this.faceVertexUvs[0][f];t.push(d(h[0]),d(h[1]),d(h[2]))}if(P&&t.push(m(g.normal)),S){let h=g.vertexNormals;t.push(m(h[0]),m(h[1]),m(h[2]))}if(b&&t.push(p(g.color)),E){let h=g.vertexColors;t.push(p(h[0]),p(h[1]),p(h[2]))}}function u(f,g,x){return x?f|1<<g:f&~(1<<g)}function m(f){let g=f.x.toString()+f.y.toString()+f.z.toString();return i[g]!==void 0||(i[g]=o.length/3,o.push(f.x,f.y,f.z)),i[g]}function p(f){let g=f.r.toString()+f.g.toString()+f.b.toString();return a[g]!==void 0||(a[g]=s.length,s.push(f.getHex())),a[g]}function d(f){let g=f.x.toString()+f.y.toString();return c[g]!==void 0||(c[g]=l.length/2,l.push(f.x,f.y)),c[g]}return r.data={},r.data.vertices=e,r.data.normals=o,s.length>0&&(r.data.colors=s),l.length>0&&(r.data.uvs=[l]),r.data.faces=t,r}clone(){return new Jr().copy(this)}copy(r){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=r.name;let e=r.vertices;for(let p=0,d=e.length;p<d;p++)this.vertices.push(e[p].clone());let t=r.colors;for(let p=0,d=t.length;p<d;p++)this.colors.push(t[p].clone());let o=r.faces;for(let p=0,d=o.length;p<d;p++)this.faces.push(o[p].clone());for(let p=0,d=r.faceVertexUvs.length;p<d;p++){let f=r.faceVertexUvs[p];this.faceVertexUvs[p]===void 0&&(this.faceVertexUvs[p]=[]);for(let g=0,x=f.length;g<x;g++){let y=f[g],v=[];for(let P=0,S=y.length;P<S;P++){let b=y[P];v.push(b.clone())}this.faceVertexUvs[p].push(v)}}let i=r.morphTargets;for(let p=0,d=i.length;p<d;p++){let f={};if(f.name=i[p].name,i[p].vertices!==void 0){f.vertices=[];for(let g=0,x=i[p].vertices.length;g<x;g++)f.vertices.push(i[p].vertices[g].clone())}if(i[p].normals!==void 0){f.normals=[];for(let g=0,x=i[p].normals.length;g<x;g++)f.normals.push(i[p].normals[g].clone())}this.morphTargets.push(f)}let s=r.morphNormals;for(let p=0,d=s.length;p<d;p++){let f={};if(s[p].vertexNormals!==void 0){f.vertexNormals=[];for(let g=0,x=s[p].vertexNormals.length;g<x;g++){let y=s[p].vertexNormals[g],v={};v.a=y.a.clone(),v.b=y.b.clone(),v.c=y.c.clone(),f.vertexNormals.push(v)}}if(s[p].faceNormals!==void 0){f.faceNormals=[];for(let g=0,x=s[p].faceNormals.length;g<x;g++)f.faceNormals.push(s[p].faceNormals[g].clone())}this.morphNormals.push(f)}let a=r.skinWeights;for(let p=0,d=a.length;p<d;p++)this.skinWeights.push(a[p].clone());let l=r.skinIndices;for(let p=0,d=l.length;p<d;p++)this.skinIndices.push(l[p].clone());let c=r.lineDistances;for(let p=0,d=c.length;p<d;p++)this.lineDistances.push(c[p]);let u=r.boundingBox;u!==null&&(this.boundingBox=u.clone());let m=r.boundingSphere;return m!==null&&(this.boundingSphere=m.clone()),this.elementsNeedUpdate=r.elementsNeedUpdate,this.verticesNeedUpdate=r.verticesNeedUpdate,this.uvsNeedUpdate=r.uvsNeedUpdate,this.normalsNeedUpdate=r.normalsNeedUpdate,this.colorsNeedUpdate=r.colorsNeedUpdate,this.lineDistancesNeedUpdate=r.lineDistancesNeedUpdate,this.groupsNeedUpdate=r.groupsNeedUpdate,this}toBufferGeometry(){let r=new vl().fromGeometry(this),e=new oe.BufferGeometry,t=new Float32Array(r.vertices.length*3);if(e.setAttribute("position",new oe.BufferAttribute(t,3).copyVector3sArray(r.vertices)),r.normals.length>0){let o=new Float32Array(r.normals.length*3);e.setAttribute("normal",new oe.BufferAttribute(o,3).copyVector3sArray(r.normals))}if(r.colors.length>0){let o=new Float32Array(r.colors.length*3);e.setAttribute("color",new oe.BufferAttribute(o,3).copyColorsArray(r.colors))}if(r.uvs.length>0){let o=new Float32Array(r.uvs.length*2);e.setAttribute("uv",new oe.BufferAttribute(o,2).copyVector2sArray(r.uvs))}if(r.uvs2.length>0){let o=new Float32Array(r.uvs2.length*2);e.setAttribute("uv2",new oe.BufferAttribute(o,2).copyVector2sArray(r.uvs2))}e.groups=r.groups;for(let o in r.morphTargets){let i=[],s=r.morphTargets[o];for(let a=0,l=s.length;a<l;a++){let c=s[a],u=new oe.Float32BufferAttribute(c.data.length*3,3);u.name=c.name,i.push(u.copyVector3sArray(c.data))}e.morphAttributes[o]=i}if(r.skinIndices.length>0){let o=new oe.Float32BufferAttribute(r.skinIndices.length*4,4);e.setAttribute("skinIndex",o.copyVector4sArray(r.skinIndices))}if(r.skinWeights.length>0){let o=new oe.Float32BufferAttribute(r.skinWeights.length*4,4);e.setAttribute("skinWeight",o.copyVector4sArray(r.skinWeights))}return r.boundingSphere!==null&&(e.boundingSphere=r.boundingSphere.clone()),r.boundingBox!==null&&(e.boundingBox=r.boundingBox.clone()),e}computeTangents(){console.error("THREE.Geometry: .computeTangents() has been removed.")}computeLineDistances(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")}applyMatrix(r){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(r)}dispose(){this.dispatchEvent({type:"dispose"})}static createBufferGeometryFromObject(r){let e=new oe.BufferGeometry,t=r.geometry;if(r.isPoints||r.isLine){let o=new oe.Float32BufferAttribute(t.vertices.length*3,3),i=new oe.Float32BufferAttribute(t.colors.length*3,3);if(e.setAttribute("position",o.copyVector3sArray(t.vertices)),e.setAttribute("color",i.copyColorsArray(t.colors)),t.lineDistances&&t.lineDistances.length===t.vertices.length){let s=new oe.Float32BufferAttribute(t.lineDistances.length,1);e.setAttribute("lineDistance",s.copyArray(t.lineDistances))}t.boundingSphere!==null&&(e.boundingSphere=t.boundingSphere.clone()),t.boundingBox!==null&&(e.boundingBox=t.boundingBox.clone())}else r.isMesh&&(e=t.toBufferGeometry());return e}};Jr.prototype.isGeometry=!0;var vl=class{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(r){let e=[],t,o,i,s=r.faces;for(o=0;o<s.length;o++){let a=s[o];a.materialIndex!==i&&(i=a.materialIndex,t!==void 0&&(t.count=o*3-t.start,e.push(t)),t={start:o*3,materialIndex:i})}t!==void 0&&(t.count=o*3-t.start,e.push(t)),this.groups=e}fromGeometry(r){let e=r.faces,t=r.vertices,o=r.faceVertexUvs,i=o[0]&&o[0].length>0,s=o[1]&&o[1].length>0,a=r.morphTargets,l=a.length,c;if(l>0){c=[];for(let y=0;y<l;y++)c[y]={name:a[y].name,data:[]};this.morphTargets.position=c}let u=r.morphNormals,m=u.length,p;if(m>0){p=[];for(let y=0;y<m;y++)p[y]={name:u[y].name,data:[]};this.morphTargets.normal=p}let d=r.skinIndices,f=r.skinWeights,g=d.length===t.length,x=f.length===t.length;t.length>0&&e.length===0&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let y=0;y<e.length;y++){let v=e[y];this.vertices.push(t[v.a],t[v.b],t[v.c]);let P=v.vertexNormals;if(P.length===3)this.normals.push(P[0],P[1],P[2]);else{let b=v.normal;this.normals.push(b,b,b)}let S=v.vertexColors;if(S.length===3)this.colors.push(S[0],S[1],S[2]);else{let b=v.color;this.colors.push(b,b,b)}if(i===!0){let b=o[0][y];b!==void 0?this.uvs.push(b[0],b[1],b[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",y),this.uvs.push(new oe.Vector2,new oe.Vector2,new oe.Vector2))}if(s===!0){let b=o[1][y];b!==void 0?this.uvs2.push(b[0],b[1],b[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",y),this.uvs2.push(new oe.Vector2,new oe.Vector2,new oe.Vector2))}for(let b=0;b<l;b++){let E=a[b].vertices;c[b].data.push(E[v.a],E[v.b],E[v.c])}for(let b=0;b<m;b++){let E=u[b].vertexNormals[y];p[b].data.push(E.a,E.b,E.c)}g&&this.skinIndices.push(d[v.a],d[v.b],d[v.c]),x&&this.skinWeights.push(f[v.a],f[v.b],f[v.c])}return this.computeGroups(r),this.verticesNeedUpdate=r.verticesNeedUpdate,this.normalsNeedUpdate=r.normalsNeedUpdate,this.colorsNeedUpdate=r.colorsNeedUpdate,this.uvsNeedUpdate=r.uvsNeedUpdate,this.groupsNeedUpdate=r.groupsNeedUpdate,r.boundingSphere!==null&&(this.boundingSphere=r.boundingSphere.clone()),r.boundingBox!==null&&(this.boundingBox=r.boundingBox.clone()),this}},mn=class{constructor(r,e,t,o,i,s=0){this.a=r,this.b=e,this.c=t,this.normal=o&&o.isVector3?o:new oe.Vector3,this.vertexNormals=Array.isArray(o)?o:[],this.color=i&&i.isColor?i:new oe.Color,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=s}clone(){return new this.constructor().copy(this)}copy(r){this.a=r.a,this.b=r.b,this.c=r.c,this.normal.copy(r.normal),this.color.copy(r.color),this.materialIndex=r.materialIndex;for(let e=0,t=r.vertexNormals.length;e<t;e++)this.vertexNormals[e]=r.vertexNormals[e].clone();for(let e=0,t=r.vertexColors.length;e<t;e++)this.vertexColors[e]=r.vertexColors[e].clone();return this}};var Fv=["a","b","c"];function Uv(n,r){switch(r){case"c":return n.c;case"b":return n.b;case"a":default:return n.a}}function bl(n,r,e){let t=Math.min(n,r),o=Math.max(n,r),i=t+"_"+o;return e.get(i)}function Sl(n,r,e,t,o,i){let s=Math.min(n,r),a=Math.max(n,r),l=s+"_"+a,c;if(t.has(l))c=t.get(l);else{let u=e[s],m=e[a];c={a:u,b:m,newEdge:null,faces:[]},t.set(l,c)}c.faces.push(o),i[n].edges.push(c),i[r].edges.push(c)}function jv(n,r,e,t){let o,i,s;for(o=0,i=n.length;o<i;o++)e[o]={edges:[]};for(o=0,i=r.length;o<i;o++)s=r[o],Sl(s.a,s.b,n,t,s,e),Sl(s.b,s.c,n,t,s,e),Sl(s.c,s.a,n,t,s,e)}function Zs(n,r,e,t,o){n.push(new mn(r,e,t,void 0,void 0,o))}function dn(n,r){return Math.abs(r-n)/2+Math.min(n,r)}function ea(n,r,e,t){n.push([r.clone(),e.clone(),t.clone()])}var ta=class{constructor(r=1){this.subdivisions=r}modify(r){r instanceof Gr.BufferGeometry?r=new Jr().fromBufferGeometry(r):r=r.clone(),r.mergeVertices();let e=this.subdivisions;for(;e-- >0;)this._smooth(r);return r.computeFaceNormals(),r.computeVertexNormals(),r}_smooth(r){let e=new Gr.Vector3,t,o,i,s,a,l=r.vertices,c=r.faces,u=r.faceVertexUvs[0],m=u!==void 0&&u.length>0,p=[],d=new Map;jv(l,c,p,d);let f=[],g,x,y,v,P,S,b;for(let V of Array.from(d.keys())){for(x=d.get(V),y=new Gr.Vector3,P=3/8,S=1/8,b=x.faces.length,b!=2&&(P=.5,S=0,b!=1),y.addVectors(x.a,x.b).multiplyScalar(P),e.set(0,0,0),s=0;s<b;s++){for(v=x.faces[s],a=0;a<3&&(g=l[Uv(v,Fv[a])],!(g!==x.a&&g!==x.b));a++);g&&e.add(g)}e.multiplyScalar(S),y.add(e),x.newEdge=f.length,f.push(y)}let E,w,h,_,N,I,L,A=[];for(o=0,i=l.length;o<i;o++){for(I=l[o],N=p[o].edges,t=N.length,t==3?E=3/16:t>3&&(E=3/(8*t)),w=1-t*Number(E),h=E,t<=2&&(t==2?(w=3/4,h=1/8):t==1||t==0),L=I.clone().multiplyScalar(w),e.set(0,0,0),s=0;s<t;s++)_=N[s],g=_.a!==I?_.a:_.b,e.add(g);e.multiplyScalar(Number(h)),L.add(e),A.push(L)}let k=A.concat(f),q=A.length,ne,ue,se,K=[],U=[],z,B,D,M,G=new Gr.Vector2,Q=new Gr.Vector2,j=new Gr.Vector2;for(o=0,i=c.length;o<i;o++)v=c[o],ne=Number(bl(v.a,v.b,d).newEdge)+q,ue=Number(bl(v.b,v.c,d).newEdge)+q,se=Number(bl(v.c,v.a,d).newEdge)+q,Zs(K,ne,ue,se,v.materialIndex),Zs(K,v.a,ne,se,v.materialIndex),Zs(K,v.b,ue,ne,v.materialIndex),Zs(K,v.c,se,ue,v.materialIndex),m&&(z=u[o],B=z[0],D=z[1],M=z[2],G.set(dn(B.x,D.x),dn(B.y,D.y)),Q.set(dn(D.x,M.x),dn(D.y,M.y)),j.set(dn(B.x,M.x),dn(B.y,M.y)),ea(U,G,Q,j),ea(U,B,G,j),ea(U,D,Q,G),ea(U,M,j,Q));r.vertices=k,r.faces=K,m&&(r.faceVertexUvs[0]=U)}};var et=new mr.Vector3,Rm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=n.geometry??r?.geometry??new mr.BufferGeometry().copy(new mr.BoxBufferGeometry(100,100,100)),t;r===void 0?(e.computeBoundingBox(),e.boundingBox.getSize(et),t={width:et.x,height:et.y,depth:et.z,subdivisions:0}):t=r.parameters;let o={...t,...n.parameters};return{parameters:{width:Math.abs(o.width),height:Math.abs(o.height),depth:Math.abs(o.depth),subdivisions:Math.abs(o.subdivisions)},geometry:e}}static build(n){let{width:r,height:e,depth:t,subdivisions:o}=n.parameters,i=n.geometry??new mr.BufferGeometry().copy(new mr.BoxBufferGeometry(100,100,100)),s=i.userData.parameters;s===void 0?(i.computeBoundingBox(),i.boundingBox.getSize(et)):et.set(s.width,s.height,s.depth),(r!==et.x||e!==et.y||t!==et.z)&&i.scale(et.x===0?1:r/et.x,et.y===0?1:e/et.y,et.z===0?1:t/et.z);let a=i.originalGeometry;return o>0?(a===void 0||s?.subdivisions!==o)&&(a===void 0&&(a=i),i=new ta(o).modify(a).toBufferGeometry()):(a!==void 0&&(i=a),a=void 0,i.getAttribute("normal")===void 0&&i.computeVertexNormals()),a!==void 0&&Object.assign(i,{originalGeometry:a}),delete n.geometry,Object.assign(i,{userData:{...n,type:"NonParametricGeometry"}})}static loadFromUrl(n,r,e){new mr.BufferGeometryLoader(e).load(n,o=>{let i=this.normalizeInputs({geometry:o});o.boundingBox.getSize(et);let s=100/et.x;Object.assign(i.parameters,{width:100,height:et.y*s,depth:et.z*s}),r(this.build(i))})}};var zm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,depth:0,spikes:5,cornerRadius:0,extrudeBevelSize:0,extrudeBevelSegments:3},n.parameters);return{shape:n.shape&&n.shape instanceof Le?n.shape:new Le,parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??0)})}}static build(n){let{width:r,height:e,spikes:t,cornerRadius:o,depth:i,extrudeBevelSize:s,extrudeBevelSegments:a}=n.parameters,l=n.shape,c=r*.5,u=e*.5,m=0,p=0,d=2*Math.PI/t;for(let g=0;g<t;g++){let x=d*g,y=m+Math.sin(x)*c,v=p+Math.cos(x)*u;l.addPoint(l.createPoint(y,v))}l.isClosed=!0;for(let g=0,x=l.points.length;g<x;g++)l.points[g].roundness=o;l.roundness=o,l.update();let f=bt.create({shape:l,parameters:{roundness:o,depth:i,extrudeBevelSize:s,extrudeBevelSegments:a}});return Object.assign(f,{userData:{...n,type:"PolygonGeometry"}})}};var ve=require("three"),Vm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,radialSegments:4,heightSegments:1,cornerRadius:0,cornerSegments:8,openEnded:!1},n.parameters);return{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??e.width)})}}static build(n){let{width:r,height:e,depth:t,radialSegments:o,heightSegments:i,openEnded:s,cornerRadius:a,cornerSegments:l}=n.parameters,c=new Tl(r*.5,e,o,i,s,a,l);return c.scale(1,1,t/r),Object.assign(c,{userData:{...n,type:"PyramidGeometry"}})}};function si(n,r,e){e.x=n.x*r.x,e.y=n.y,e.z=n.x*r.y}function wl(n,r,e,t,o,i){let s=r.clone().sub(n),a=e.clone().sub(n),l=s.angleTo(a);if(s.normalize(),a.normalize(),t===o){let c=s.add(a).normalize();i.copy(n).addScaledVector(c,t/Math.sin(l/2))}else{let c=s.angleTo(a);i.copy(n),i.addScaledVector(s,o/Math.sin(c)),i.addScaledVector(a,t/Math.sin(c))}}function kv(n,r,e){let t=n.clone().sub(r),o=e.clone().sub(r);return t.projectOnVector(o),t.add(r)}var Tl=class extends ve.BufferGeometry{constructor(r=.5,e=1,t=4,o=1,i=!1,s=0,a=4){super(),t=Math.floor(Math.max(3,t)),o=Math.floor(o),a=Math.floor(a);let l=[],c=[],u=[],m=[],p=0,d=e/2,f=Math.PI/t,g=r*Math.cos(Math.PI/t),x=2*Math.PI/t,y=(t-2)*Math.PI/t,v=Math.PI-y,P=new ve.Vector3(0,-d,0),S=new ve.Vector3(0,d,0),b=new ve.Vector2(r,-d),E=new ve.Vector2(g,-d),w=new ve.Vector2(0,S.y).sub(E),h=new ve.Vector2(0,S.y).sub(b),_=new ve.Vector2(w.y,-w.x).normalize(),N=new ve.Vector2(h.y,-h.x).normalize(),L=r*Math.cos(Math.PI/t)*Math.tan((Math.PI-w.angle())/2)-1e-8;s=Math.min(s,L);let A;{let U=new ve.Vector3(_.x,_.y,0),z=new ve.Vector3(Math.cos(x)*U.x,U.y,Math.sin(x)*U.x);A=U.angleTo(z)}let k=s/Math.tan((Math.PI-w.angle())/2),q=s/Math.tan((Math.PI-A)/2),ne=new ve.Vector3;if(!i){c.push(P.x,P.y,P.z),u.push(0,-1,0),m.push(0,0);let U=p++,z=[],B=b.clone(),D=k/Math.cos(Math.PI/t);B.x-=D;for(let M=0;M<t;M++){let G=M/t*Math.PI*2+f,Q=new ve.Vector2(Math.sin(G),Math.cos(G));si(B,Q,ne),c.push(ne.x,ne.y,ne.z),u.push(0,-1,0),m.push(0,0),z.push(p++)}for(let M=0;M<z.length;M++)l.push(z[M],U,z[(M+1)%z.length])}let ue=[];{let U=new ve.Vector3,z=new ve.Vector3,B=new ve.Vector3,D=new ve.Vector3,M=new ve.Vector3,G=new ve.Vector3;for(let Q=0;Q<t;Q++){let j=Q/t*Math.PI*2+f,V=(Q+.5)/t*Math.PI*2+f,F=(Q+1)/t*Math.PI*2+f,O=new ve.Vector2(Math.sin(j),Math.cos(j)),$=new ve.Vector2(Math.sin(V),Math.cos(V)),Z=new ve.Vector2(Math.sin(F),Math.cos(F));si(b,O,z),si(b,Z,B),si(_,$,U),wl(S,z,B,q,q,D),c.push(D.x,D.y,D.z),wl(z,S,B,q,k,M),c.push(M.x,M.y,M.z),wl(B,z,S,k,q,G),c.push(G.x,G.y,G.z),u.push(U.x,U.y,U.z),u.push(U.x,U.y,U.z),u.push(U.x,U.y,U.z),m.push(0,0),m.push(0,0),m.push(0,0);let ee=p++,H=p++,J=p++;if(l.push(ee,H,J),s>0){{let ce=z.clone().add(B).multiplyScalar(.5),ie=S.clone().sub(ce).normalize(),ze=P.clone().sub(ce).normalize().add(ie).normalize().multiplyScalar(-1),ye=G.clone().sub(M);se(ce,ye,ze,w.angle())}let X,re;{let ce=new ve.Vector3;si(N,Z,ce);let ie=G.clone().add(D).multiplyScalar(.5);ie=kv(ie,B,S);let fe=G.clone().sub(D);[X,re]=se(ie,fe,ce,A,D.y)}{let ce=X,ie=ce.clone().setY(0).normalize(),fe=new ve.Vector3(0,-1,0),ze=ie.clone().cross(fe);K(ce,ie,fe,ze)}ue.concat(re);{let ce=w.angle(),ie=Math.PI-ce,fe=S.clone();fe.y-=s/Math.sin(ce-Math.PI/2);let ze=new ve.Vector3,ye=[];for(let Ce=0;Ce<a;Ce++){let Nt=[],Vt=Math.PI/2-ie*Ce/a,Ao=Math.cos(Vt),_t=Math.sin(Vt),Mo=V;for(let Vi=0;Vi<=Ce;Vi++){let Fi=Math.cos(Mo),ke=Math.sin(Mo);U.x=Ao*ke,U.y=_t,U.z=Ao*Fi,ze.copy(fe).addScaledVector(U,s),c.push(ze.x,ze.y,ze.z),u.push(U.x,U.y,U.z),m.push(0,0),Nt.push(p++),Mo+=Math.PI*2/Ce/t}ye.push(Nt)}re.reverse(),ye.push(re);let $e=ye.length-1;for(let Ce=0;Ce<$e;Ce++){let Nt=ye[Ce],Vt=ye[Ce+1],Ao=Nt.length-1;l.push(Vt[1],Nt[0],Vt[0]);for(let _t=1;_t<=Ao;_t++)l.push(Nt[_t],Nt[_t-1],Vt[_t]),l.push(Vt[_t+1],Nt[_t],Vt[_t])}}}}}this.setIndex(l),this.setAttribute("position",new ve.Float32BufferAttribute(c,3)),this.setAttribute("normal",new ve.Float32BufferAttribute(u,3)),this.setAttribute("uv",new ve.Float32BufferAttribute(m,2));function se(U,z,B,D,M){let G=-D/2,Q=(Math.PI-D)/2,j=z.clone().normalize().cross(B);U.addScaledVector(B,-s/Math.sin(Q));let V=new ve.Vector3,F=new ve.Vector3,O=1,$=p,Z=[];for(let ee=0;ee<=a;ee++){let H=G+ee/a*D;F.set(0,0,0),F.addScaledVector(j,Math.sin(H)),F.addScaledVector(B,Math.cos(H));for(let J=0;J<=O;J++){let X=J/O-.5;if(V.copy(U),V.addScaledVector(z,X),V.addScaledVector(F,s),M!=null){let re=Math.max(0,V.y-M);V.addScaledVector(z,-re/z.y)}c.push(V.x,V.y,V.z),u.push(F.x,F.y,F.z),m.push(0,0),J===0&&Z.push(p),p++}}for(let ee=0;ee<a;ee++)for(let H=0;H<O;H++){let J=$+H+(O+1)*ee,X=J+(O+1),re=X+1,ce=J+1;l.push(J,X,ce),l.push(X,re,ce)}return[U.clone().addScaledVector(z,.5),Z]}function K(U,z,B,D){let M=Math.PI/2,G=h.angle()-M,Q=[],j=new ve.Vector3,V=new ve.Vector3;for(let O=0;O<=a;O++){let $=[],Z=O/a;for(let ee=0;ee<=O;ee++){let J=((O?ee/O:0)-.5)*v,X=Math.cos(J),re=Math.sin(J),ce=Math.atan(Math.tan(G)*X),ie=(M+ce)*Z,fe=Math.cos(ie),ze=Math.sin(ie);j.set(0,0,0),j.addScaledVector(z,ze*X),j.addScaledVector(B,fe),j.addScaledVector(D,ze*re),V.copy(U).addScaledVector(j,s),c.push(V.x,V.y,V.z),u.push(j.x,j.y,j.z),m.push(0,0),$.push(p++)}Q.push($)}let F=Q.length-1;for(let O=0;O<F;O++){let $=Q[O],Z=Q[O+1],ee=$.length-1;l.push($[0],Z[1],Z[0]);for(let H=1;H<=ee;H++)l.push($[H-1],$[H],Z[H]),l.push($[H],Z[H+1],Z[H])}}}};var Fm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,depth:0,cornerRadius:[0,0,0,0],cornerType:1,extrudeBevelSize:0,extrudeBevelSegments:1},n.parameters),t=Object.assign(r?.ui??{enabledIndieCorners:!1},n.ui);return{shape:n.shape&&n.shape instanceof Le?n.shape:new Le,parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??0)}),ui:t}}static build(n){let r=n.shape,{width:e,height:t,cornerRadius:o,cornerType:i,depth:s,extrudeBevelSize:a,extrudeBevelSegments:l}=n.parameters,c={x:e*.5,y:t*.5},u={x:-c.x,y:-c.y},m={x:c.x,y:c.y};function p(S,b,E){return b>e&&E>t?Math.min(S*e/b,S*t/E):b>e?S*e/b:E>t?S*t/E:S}let d=[];d[0]=o[0]===0?0:p(o[0],o[0]+o[3],o[0]+o[1]),d[1]=o[1]===0?0:p(o[1],o[1]+o[2],o[1]+o[0]),d[2]=o[2]===0?0:p(o[2],o[2]+o[1],o[2]+o[3]),d[3]=o[3]===0?0:p(o[3],o[3]+o[0],o[3]+o[2]);let f=u.x,g=m.x,x=m.y,y=u.y;r.addPoint(r.createPoint(f,x)),r.addPoint(r.createPoint(g,x)),r.addPoint(r.createPoint(g,y)),r.addPoint(r.createPoint(f,y)),r.isClosed=!0;let v=!0;for(let S=0,b=r.points.length;S<b;S++)r.points[S].roundness=d[S],S>0&&d[S]!==d[S-1]&&(v=!1);v&&(r.roundness=d[0]),r.useCubicForRoundedCorners=i!==1,r.update();let P=bt.create({shape:r,parameters:{depth:s,extrudeBevelSize:a,extrudeBevelSegments:l}});return Object.assign(P,{userData:{...n,type:"RectangleGeometry"}})}};var Um=require("three"),jm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,widthSegments:64,heightSegments:64,phiStart:0,phiLength:2*Math.PI,thetaStart:0,thetaLength:Math.PI},n.parameters);return{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??e.width)})}}static build(n){let{width:r=100,height:e=r,depth:t=r,widthSegments:o=64,heightSegments:i=64,phiStart:s,phiLength:a,thetaStart:l,thetaLength:c}=n.parameters,u=new Um.SphereBufferGeometry(.5*r,o,i,s,a,l,c);return u.scale(1,e/r,t/r),Object.assign(u,{userData:{...n,type:"SphereGeometry"}})}};var km=require("three"),Hm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,depth:0,widthSegments:8,heightSegments:8},n.parameters);return{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:0})}}static build(n){let{width:r=100,height:e=r,widthSegments:t=8,heightSegments:o=8}=n.parameters,i=new km.PlaneBufferGeometry(r,e,t,o);return i.scale(1,1,1),Object.assign(i,{userData:{...n,type:"PlaneGeometry"}})}};var Zr=require("three"),Wm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,angle:90,cornerRadius:24,cornerSegments:8},n.parameters);return{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??e.width)})}}static build(n){let{width:r,height:e,depth:t,angle:o,cornerRadius:i,cornerSegments:s}=n.parameters,a=new Nl(r,e,t,o,i,s);return Object.assign(a,{userData:{...n,type:"BackdropGeometry"}})}},Nl=class extends Zr.BufferGeometry{constructor(r=1,e=1,t=1,o=90,i=10,s=24){super(),this.type="BackdropGeometry";let a=[],l=[],c=[],u=.001;i==0&&(s=1),s=Math.max(1,Math.floor(s)),i=Math.min(i,100),o=Math.min(180-u,o),o*=Math.PI/180;let m=[],p=Math.PI/2,d=(V=0,F=0,O=0)=>new Zr.Vector3(V,F,O),f=d(),g=d(),[x,y,v]=[e/2,r/2,t/2],P=-y,S=+y,[b,E,w]=[d(P,-x,+v),d(P,-x,-v),d(P,+x,-v)],h=(V,F=!1)=>Math.sin(V-Math.PI/(1+ +F)),_=(V,F=!1)=>Math.cos(V-Math.PI/(1+ +F));w.y=Math.sin(o)*e-x;let N=Math.cos(o)*e-v,I=b.z-u;o<=p?(w.z=Math.min(N,I),w.z==I&&(w.y-=(N-I)/Math.tan(p-o))):E.z=Math.min(E.z-N-v,b.z-u),f.subVectors(b,E),g.subVectors(w,E);let L=Math.min(f.length(),g.length())*i/100,A=L*Math.tan(o/2),k=L/Math.cos(o/2),q=f.clone().normalize().add(g.normalize()).setLength(k).add(E);f.set(0,h(o,!0),_(o,!0)),m.push([w,f.clone()]);let ne=(Math.PI-o)/s;for(let V=0;V<=s;V++){let F=p+o+V*ne;f.set(0,Math.sin(F)*A,Math.cos(F)*A),f.add(q),g.set(0,h(F),_(F)),m.push([f.clone(),g.clone()])}m.push([b,d(0,1,0)]);let ue=Math.sin(ne/2)*A*2,se=m.length-1,K=m[0][0].distanceTo(m[1][0]),U=m[se-1][0].distanceTo(m[se][0]),z=K+ue*s+U;m[0].push(1);for(let V=0;V<=s;V++)m[V+1].push(1-(K+V*ue)/z);m[se].push(0);let[B,D,M]=m[0],G,Q,j;for(let V=1;V<m.length;V++)[G,Q,j]=m[V],a.push(P,B.y,B.z,P,G.y,G.z,S,B.y,B.z,S,B.y,B.z,P,G.y,G.z,S,G.y,G.z),l.push(0,D.y,D.z,0,Q.y,Q.z,0,D.y,D.z,0,D.y,D.z,0,Q.y,Q.z,0,Q.y,Q.z),c.push(0,M,0,j,1,M,1,M,0,j,1,j),[B,D,M]=[G,Q,j];this.setAttribute("position",new Zr.Float32BufferAttribute(a,3)),this.setAttribute("normal",new Zr.Float32BufferAttribute(l,3)),this.setAttribute("uv",new Zr.Float32BufferAttribute(c,2))}};var qm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,depth:0,innerRadiusPercent:38.19,spikes:5,cornerRadius:0,angle:360,extrudeBevelSize:0,extrudeBevelSegments:1},n.parameters);return{shape:n.shape&&n.shape instanceof Le?n.shape:new Le,parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??0)})}}static build(n){let{width:r,height:e,innerRadiusPercent:t,spikes:o,cornerRadius:i,angle:s,depth:a,extrudeBevelSize:l,extrudeBevelSegments:c}=n.parameters,u=n.shape,m=r*.5,p=e*.5,d=0,f=0,g=s*Math.PI/360/o,x=Math.PI/2*3*-1,y=m*t/100,v=p*t/100;if(o===3&&t===50){g=2*Math.PI/o;for(let S=0;S<o;S++){let b=g*S,E=d+Math.sin(b)*m,w=f+Math.cos(b)*p;u.addPoint(u.createPoint(E,w))}}else for(let S=0;S<o;S++){let b=d+Math.cos(x)*m,E=f+Math.sin(x)*p;u.addPoint(u.createPoint(b,E)),x+=g,b=d+Math.cos(x)*y,E=f+Math.sin(x)*v,S<=o,u.addPoint(u.createPoint(b,E)),x+=g}u.isClosed=!0;for(let S=0,b=u.points.length;S<b;S++)u.points[S].roundness=i;u.roundness=i,u.update();let P=bt.create({shape:u,parameters:{roundness:i,depth:a,extrudeBevelSize:l,extrudeBevelSegments:c}});return Object.assign(P,{userData:{...n,type:"StarGeometry"}})}};var $m=require("three"),ra=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,depth:0},n.parameters);return{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??0)})}}static build(n){let{width:r,height:e}=n.parameters,t=new $m.PlaneBufferGeometry(r,e);return Object.assign(t,{userData:{...n,type:"TextFrameGeometry"}})}};var Xm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,radialSegments:32,tubularSegments:64,arc:Math.PI*2,cornerRadius:30,cornerSegments:8},n.parameters),t=Math.abs(e.width),o=Math.abs(e.height??e.width),i=Math.abs(e.depth??e.width*.25);return{parameters:Object.assign(e,{width:t,height:o,depth:i})}}static build(n){let{width:r,height:e,depth:t,radialSegments:o,tubularSegments:i,arc:s,cornerRadius:a,cornerSegments:l}=n.parameters,c=Hv(r,e,t,r*.5,s,i,0,0,o,a,l);return c.scale(1,e/r,1),Object.assign(c,{userData:{...n,type:"TorusGeometry"}})}};function Hv(n,r,e,t,o,i,s,a,l,c,u){return[r,e]=[e,r],s=r/2,o/=2*Math.PI,o==1&&(c=0),new ni(!0,n,r,e,t,o,i,s,a,l,c,u)}var Ym=require("three"),Km=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,tubularSegments:64,radialSegments:32,p:2,q:3},n.parameters);return{parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width),depth:Math.abs(e.depth??e.width),tube:e.tube??e.width*.125})}}static build(n){let{width:r,tube:e,tubularSegments:t,radialSegments:o,p:i,q:s}=n.parameters,a=r*.5;a!==e&&(a-=e);let l=new Ym.TorusKnotBufferGeometry(a,e,t,o,i,s);return Object.assign(l,{userData:{...n,type:"TorusKnotGeometry"}})}};var Qm=class{static create(n){return this.build(this.normalizeInputs(n))}static normalizeInputs(n,r){let e=Object.assign({},r?.parameters??{width:100,depth:0,spikes:5,cornerRadius:0,extrudeBevelSize:0,extrudeBevelSegments:1,isRect:!1},n.parameters);return{shape:n.shape&&n.shape instanceof Le?n.shape:new Le,parameters:Object.assign(e,{width:Math.abs(e.width),height:Math.abs(e.height??e.width*(e.isRect?1:Math.sqrt(3)/2)),depth:Math.abs(e.depth??0)})}}static build(n){let{width:r=100,height:e,cornerRadius:t,depth:o,extrudeBevelSize:i,extrudeBevelSegments:s,isRect:a}=n.parameters,l=n.shape,c=r*.5,u=e*.5;a?(l.addPoint(l.createPoint(-c,u)),l.addPoint(l.createPoint(c,-u)),l.addPoint(l.createPoint(-c,-u))):(l.addPoint(l.createPoint(0,u)),l.addPoint(l.createPoint(c,-u)),l.addPoint(l.createPoint(-c,-u))),l.isClosed=!0;for(let p=0,d=l.points.length;p<d;p++)l.points[p].roundness=t;l.roundness=t,l.update();let m=bt.create({shape:l,parameters:{roundness:t,depth:o,extrudeBevelSize:i,extrudeBevelSegments:s}});return Object.assign(m,{userData:{...n,type:"TriangleGeometry"}})}};var We=require("three");var Wv,oa=new Promise(n=>{Wv=n});var Ad=require("three");var oo=require("three");var ha=require("three");var Il=require("three");var Ue=require("three");var Cl=require("three");function Ke(n,r){return r.color(n)}var Ll=n=>"isEntity"in n,dr=n=>"isAbstractMesh"in n,fr=n=>n!==null&&n.isBooleanMesh,Jm=n=>n.objectType==="CombinedCamera";var Rr=n=>"objectHelper"in n;function qv(n,r){let e=!1;r.position&&(n.position.fromArray(r.position),e=!0),r.rotation&&(n.rotation.fromArray(r.rotation),e=!0),r.scale&&(e=!0,n.scale.fromArray(r.scale)),r.hiddenMatrix!==void 0&&"hiddenMatrix"in n&&(e=!0,n.hiddenMatrix.fromArray(r.hiddenMatrix??Wr.identity)),e&&(n.updateMatrix(),fr(n.parent)&&dr(n)&&n.invalidateDownstreamBooleanData(!0).recomputeBoolean()),r.position&&r.rotation&&r.scale&&r.hiddenMatrix!==void 0&&n.updateWorldMatrix(!1,!0),n.objectType==="CombinedCamera"&&(r.isUpVectorFlipped!==void 0&&(n.isUpVectorFlipped=r.isUpVectorFlipped),n.updateUp())}function $v(n,r){qv(n,r),r.name!==void 0&&(n.name=r.name),r.visible!==void 0&&(n.isEntity?n.visibility=r.visible:n.visible=r.visible)}function Zm(n,r,e){$v(n,r),r.color!==void 0&&(n.color=Ke(r.color,e)),r.intensity!==void 0&&(n.intensity=r.intensity),r.shadows!==void 0&&!(n instanceof Cl.HemisphereLight)&&(n.castShadow=r.shadows),n.shadow&&!(n instanceof Cl.HemisphereLight)&&r.depth!==void 0&&(n.shadow.camera.far=r.depth,n.shadow.needsUpdate=!0),r.helper!==void 0&&Rr(n)&&(n.enableHelper=r.helper,n.gizmos.shadowmap.visible=r.helper)}function ed(n,r){n.shadow.camera.right=r/2,n.shadow.camera.left=-r/2,n.shadow.camera.top=r/2,n.shadow.camera.bottom=-r/2,n.shadow.needsUpdate=!0}var fn=new Ue.Box3,hr=new Ue.Vector3,gr=new Ue.Vector3,hn=new Ue.Matrix4,rd=[new Ue.Vector3(-1,1,1),new Ue.Vector3(-1,-1,1),new Ue.Vector3(1,-1,1),new Ue.Vector3(1,1,1),new Ue.Vector3(-1,1,-1),new Ue.Vector3(-1,-1,-1),new Ue.Vector3(1,-1,-1),new Ue.Vector3(1,1,-1)],Xv=[[0,3],[1,2],[5,6],[4,7],[0,1],[3,2],[7,6],[4,5],[0,4],[1,5],[2,6],[3,7]],Yv=[[0,2],[7,5],[4,1],[3,6],[4,3],[1,6]];function Kv(n,r,e=0,t=r.count){let o=1/0,i=1/0,s=1/0,a=-1/0,l=-1/0,c=-1/0;for(let u=e;u<t;u++){let m=r.getX(u),p=r.getY(u),d=r.getZ(u);m<o&&(o=m),p<i&&(i=p),d<s&&(s=d),m>a&&(a=m),p>l&&(l=p),d>c&&(c=d)}return n.min.set(o,i,s),n.max.set(a,l,c),n}var td=(n,r,e,t)=>{if(dr(n)){let o=n.geometry.userData.parameters,i=n.geometry.getAttribute("position");n.geometry.userData.type==="SubdivGeometry"?hr.copy(n.originalGeometry.boundingSphere.center):i!==void 0&&(Kv(fn,i,n.geometry.drawRange.start,n.geometry.drawRange.count<1/0?n.geometry.drawRange.count:i.count),fn.getCenter(hr)),n.forceComputeSize?fn.getSize(gr).multiplyScalar(.5):gr.set(o.width,o.height,o.depth??0).multiplyScalar(.5)}else if(Rr(n)&&t===!0){let o=n.geometryHelper.getAttribute("position");fn.setFromArray(o.array),fn.getCenter(hr),fn.getSize(gr).multiplyScalar(.5)}else hr.setScalar(0),gr.setScalar(0);hn.copy(r).multiply(n.matrixWorld),gr.x===0&&gr.y===0&&gr.z===0?e.push(new Ue.Vector3(hr.x,hr.y,hr.z).applyMatrix4(hn)):rd.forEach(o=>{e.push(o.clone().multiply(gr).add(hr).applyMatrix4(hn))})},ai=class extends Ue.Box3{constructor(){super(...arguments);this.matrix=new Ue.Matrix4;this.vertices=[];this.faces=[];this.edges=[];this.centerEdges=[]}copy(e){return super.copy(e),this.matrix.copy(e.matrix),this.vertices=e.vertices.map(t=>t.clone()),this.faces=e.faces.map(t=>t.clone()),this.edges=e.edges.map(t=>t.clone()),this.centerEdges=e.centerEdges.map(t=>t.clone()),this}setFromObjectSize(e,t=!1){e.updateWorldMatrix(!1,t),this.makeEmpty(),this.matrix.copy(e.matrixWorld);let o=new Ue.Matrix4().copy(e.matrixWorld).invert();return this.expandByObjectSize(e,o,t)}expandByObjectSize(e,t,o=!1){let i=[];return o===!0?e.traverseEntity(s=>{s.visible&&td(s,t,i,e.enableHelper===!0)}):td(e,t,i,e.enableHelper===!0),this.setFromPoints(i)}getCenter(e){return e=super.getCenter(e),e.applyMatrix4(this.matrix),e}getPositionToCenter(e){return e=super.getCenter(e),e.applyMatrix4(hn.copy(this.matrix).setPosition(0,0,0)),e}computeVertices(){this.getSize(gr).multiplyScalar(.5),this.getCenter(hr),hn.copy(this.matrix).setPosition(hr),this.vertices=rd.map(e=>e.clone().multiply(gr).applyMatrix4(hn))}computeEdges(){this.vertices.length>0&&this.computeVertices(),this.edges=Xv.map(([e,t])=>new Ue.Line3(this.vertices[e],this.vertices[t])),this.centerEdges=this.edges.map(e=>e.getCenter(new Ue.Vector3))}computeFaces(){this.vertices.length>0&&this.computeVertices(),this.faces=Yv.map(([e,t])=>this.vertices[e].clone().add(this.vertices[t]).multiplyScalar(.5))}};var na=require("three");var ia=n=>class extends n{hasEntityChild(){return this.children.some(e=>Ll(e))}isDescendantOf(e){e instanceof na.Object3D&&(e=e.uuid);let t=this;for(;t.parent;){if(t.parent.uuid===e)return!0;t=t.parent}return!1}attach(e,t){this.updateWorldMatrix(!0,!1);let o=new na.Matrix4().copy(this.matrixWorld).invert();return e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),o.multiply(e.parent.matrixWorld)),Ll(e)?e.hiddenMatrix.premultiply(o):e.applyMatrix4(o),e.updateWorldMatrix(!1,!1),this.add(e),t!==void 0&&(this.children.pop(),this.children.splice(t,0,e)),this}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let o=0;o<e.children.length;o++){let i=e.children[o];this.add(i.clone())}return this}};var Yt=n=>"isEntity"in n,od=n=>"isAbstractMesh"in n,kt=n=>class extends ia(n){constructor(){super(...arguments);this.objectType="";this.isEntity=!0;this.raycastLock=!1;this.scaleLock=!1;this.hiddenMatrix=new Il.Matrix4;this._singleBBox=new ai;this._recursiveBBox=new ai;this.singleBBoxNeedsUpdate=!0;this.recursiveBBoxNeedsUpdate=!0;this.forceComputeSize=!1}set visibility(t){this.visible=t;for(let o of this.children)Yt(o)&&o.traverseEntity(i=>{Rr(i)&&i.visible&&(i.objectHelper.visible=t)})}get visibility(){return this.visible}get singleBBox(){return this.singleBBoxNeedsUpdate&&(this.singleBBoxNeedsUpdate=!1,this._singleBBox.setFromObjectSize(this,!1),this._singleBBox.computeVertices(),this._singleBBox.computeEdges(),this._singleBBox.computeFaces()),this._singleBBox}get recursiveBBox(){return this.recursiveBBoxNeedsUpdate&&(this.recursiveBBoxNeedsUpdate=!1,this._recursiveBBox.setFromObjectSize(this,!0),this._recursiveBBox.computeVertices(),this._recursiveBBox.computeEdges(),this._recursiveBBox.computeFaces()),this._recursiveBBox}resetBBoxNeedsUpdate(){this.singleBBoxNeedsUpdate=!0,this.recursiveBBoxNeedsUpdate=!0,this.traverseAncestors(t=>{Yt(t)&&(t.singleBBoxNeedsUpdate=!0,t.recursiveBBoxNeedsUpdate=!0)}),this.traverseEntity(t=>{t.singleBBoxNeedsUpdate=!0,t.recursiveBBoxNeedsUpdate=!0})}traverseEntity(t){t(this);for(let o of this.children)Yt(o)&&o.traverseEntity(t)}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.multiplyMatrices(this.hiddenMatrix,this.matrix):(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.hiddenMatrix),this.matrixWorld.multiplyMatrices(this.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);for(let o of this.children)o.updateMatrixWorld(t)}updateWorldMatrix(t,o){let i=this.parent;if(t&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.multiplyMatrices(this.hiddenMatrix,this.matrix):(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.hiddenMatrix),this.matrixWorld.multiplyMatrices(this.matrixWorld,this.matrix)),o)for(let s of this.children)s.updateWorldMatrix(!1,!0)}clone(t){return new this.constructor().copy(this,t)}copy(t,o=!0){if(super.copy(t,!1),this.raycastLock=t.raycastLock,this.scaleLock=t.scaleLock,this.hiddenMatrix.copy(t.hiddenMatrix),o===!0)for(let i of t.children)Yt(i)&&this.add(i.clone());return this}keepChildrenMatrixWorld(){let t=new Il.Matrix4,o=this.matrixWorld.clone();this.updateWorldMatrix(!1,!1),t.copy(this.matrixWorld).invert(),t.multiply(o);for(let i of this.children)Yt(i)&&i.hiddenMatrix.premultiply(t)}toObjectTransformState(t=[]){this.updateWorldMatrix(!0,!1);let o={position:this.position.toArray(),rotation:[this.rotation.x,this.rotation.y,this.rotation.z],scale:this.scale.toArray(),hiddenMatrix:this.hiddenMatrix.toArray()};return Yo(o,t)}fromObjectTransformState(t){return t.position&&this.position.fromArray(t.position),t.rotation&&this.rotation.fromArray(t.rotation),t.scale&&this.scale.fromArray(t.scale),t.hiddenMatrix&&this.hiddenMatrix.fromArray(t.hiddenMatrix),this.updateMatrix(),this}toState(t=[]){let o={name:this.name,visible:this.visible,raycastLock:this.raycastLock,...this.toObjectTransformState(t)};return Yo(o,t)}fromState(t,o){return t.name&&(this.name=t.name),t.raycastLock!==void 0&&(this.raycastLock=t.raycastLock),t.type!=="OrthographicCamera"&&t.type!=="PerspectiveCamera"&&(this.matrixAutoUpdate=!1),t.visible!==void 0&&(this.visibility=t.visible),this.fromObjectTransformState(t),this}};var Qe=require("three");var nd=require("three"),Pl=class extends nd.Object3D{},sa=class extends Pl{constructor(e){super();this.object=e;this.matrixAutoUpdate=!0}get castShadow(){return this.object.castShadow}set castShadow(e){}get receiveShadow(){return this.object.receiveShadow}set receiveShadow(e){}get isMesh(){return!0}get isLight(){return!1}get isCamera(){return!1}get geometry(){return this.object.geometry}get material(){return this.object.material}};var xo=class extends Qe.Object3D{constructor(e,t={}){super();this.object=e;let o=e.recursiveBBox.getSize(new Qe.Vector3),i=.1;this.parameters=vs.defaultData(o.toArray(),i),co(this.parameters,t),this.update(),this.setHideBase(this.parameters.hideBase)}setHideBase(e){this.parameters.hideBase=e}update(){switch(this._updateCount(),this.parameters.type){case"radial":this._updateRadial(this.parameters);break;case"linear":this._updateLinear(this.parameters);break;case"grid":this._updateGrid(this.parameters)}this.children.forEach(e=>e.updateMatrix())}_updateCount(){let e=this.parameters.type==="grid"?this.parameters.grid.count[0]*this.parameters.grid.count[1]*this.parameters.grid.count[2]:this.parameters.count;if(this.children.length!==e)if(this.children.length<e)for(let t=0,o=e-this.children.length;t<o;++t){let i=new sa(this.object);i.visible=!0,this.add(i),this.parameters.hideBase&&this.setHideBase(!0)}else for(let t=0,o=this.children.length-e;t<o;++t)this.remove(this.children[0])}_updateRadial(e){let t=e.radial,o=t.start*Qe.MathUtils.DEG2RAD,i=t.end*Qe.MathUtils.DEG2RAD,s=o-i,a=new Qe.Euler(t.rotation[0]*Qe.MathUtils.DEG2RAD,t.rotation[1]*Qe.MathUtils.DEG2RAD,t.rotation[2]*Qe.MathUtils.DEG2RAD),l;switch(t.axis){case"z":l=new Qe.Vector3(0,0,1);break;case"y":l=new Qe.Vector3(0,1,0);break;default:case"x":l=new Qe.Vector3(1,0,0);break}for(let[c,u]of this.children.entries()){u.scale.x=t.scale[0],u.scale.y=t.scale[1],u.scale.z=t.scale[2],u.position.setScalar(0);let m=s/e.count*c-o;switch(t.axis){case"x":u.rotation.set(0,m,0);break;case"y":u.rotation.set(0,0,m);break;case"z":u.rotation.set(m,0,0);break}u.translateOnAxis(l,t.radius),u.position.x+=t.position[0],u.position.y+=t.position[1],u.position.z+=t.position[2],t.alignment===!0?(u.rotation.x+=a.x,u.rotation.y+=a.y,u.rotation.z+=a.z):u.rotation.copy(a)}}_updateLinear(e){if(e.type!=="linear")throw new Error;let t=e.linear,o=new Qe.Euler(t.rotation[0]*Qe.MathUtils.DEG2RAD,t.rotation[1]*Qe.MathUtils.DEG2RAD,t.rotation[2]*Qe.MathUtils.DEG2RAD);for(let[i,s]of this.children.entries())s.scale.x=1+(t.scale[0]-1)*i,s.scale.y=1+(t.scale[1]-1)*i,s.scale.z=1+(t.scale[2]-1)*i,s.rotation.x=o.x*i,s.rotation.y=o.y*i,s.rotation.z=o.z*i,s.position.x=t.position[0]*i,s.position.y=t.position[1]*i,s.position.z=t.position[2]*i}_updateGrid(e){let t=0,o=e.grid;if(o.useCenter===!0){let i={x:o.count[0]%2===0?2:1,y:o.count[1]%2===0?2:1,z:o.count[2]%2===0?2:1},s=new Qe.Vector3(o.size[0]*(o.count[0]-i.x)*.5,o.size[1]*(o.count[1]-i.y)*.5,o.size[2]*(o.count[2]-i.z)*.5);for(let a=0;a<o.count[0];a++)for(let l=0;l<o.count[1];l++)for(let c=0;c<o.count[2];c++){let u=this.children[t++];u.scale.setScalar(1),u.rotation.set(0,0,0),u.position.x=o.size[0]*a-s.x,u.position.y=o.size[1]*l-s.y,u.position.z=o.size[2]*c-s.z}}else for(let i=0;i<o.count[0];i++)for(let s=0;s<o.count[1];s++)for(let a=0;a<o.count[2];a++){let l=this.children[t++];l.scale.setScalar(1),l.rotation.set(0,0,0),l.position.x=o.size[0]*i,l.position.y=-o.size[1]*s,l.position.z=-o.size[2]*a}}fromClonerState(e){return e.hideBase!==void 0&&this.setHideBase(e.hideBase),co(this.parameters,e),this.update(),this}};var fa=require("three");var Qt=require("three");var li=class{constructor(r){r=r??{},this.name=r.name,this.type=r.type,this.node=r.node,this.size=r.size,this.needsUpdate=r.needsUpdate}get value(){return this.node.value}set value(r){this.node.value=r}};var id=require("three"),st=class{constructor(r){this.hashProperties=void 0;this.isNode=!0;this.shortcuts={};this.uuid=id.MathUtils.generateUUID(),this.type=r,this.name=""}analyze(r,e){e=e??{},r.analyzing=!0,this.build(r.addFlow(e.slot,e.cache,e.context),"v4"),r.clearVertexNodeCode(),r.clearFragmentNodeCode(),r.removeFlow(),r.analyzing=!1}analyzeAndFlow(r,e,t){return t=t??{},this.analyze(r,t),this.flow(r,e,t)}flow(r,e,t){t=t??{},r.addFlow(t.slot,t.cache,t.context);let o={result:this.build(r,e),code:r.clearNodeCode(),extra:r.context.extra};return r.removeFlow(),o}build(r,e,t){e=e??this.getType(r,e);let o=r.getNodeData(t??this);return r.analyzing&&this.appendDepsNode(r,o,e),r.nodes.indexOf(this)===-1&&r.nodes.push(this),this.updateFrame!==void 0&&r.updaters.indexOf(this)===-1&&r.updaters.push(this),this.generate(r,e,t)}updateFrame(r){}generateReadonly(r,e,t,o,i,s){return""}generate(r,e,t,o,i){return""}parse(r,e,t,o){}appendDepsNode(r,e,t){e.deps=(e.deps||0)+1;let o=r.getTypeLength(t);(o>(e.outputMax||0)||this.getType(r,t))&&(e.outputMax=o,e.output=t)}setName(r){this.name=r}getName(){return this.name}getType(r,e){return e==="sampler2D"||e==="samplerCube"?e:this.type}getHash(){let r="{",e,t;for(e in this)t=this[e],t instanceof st&&(r+='"'+e+'":'+t.getHash()+",");if(this.hashProperties)for(let o=0;o<this.hashProperties.length;o++)e=this.hashProperties[o],t=this[e],r+='"'+e+'":"'+String(t)+'",';return r+='"id":"'+this.uuid+'"}',r}};var Al=class{constructor(){this.nodes={};this.keywords={}}add(r){this.nodes[r.name]=r}addKeyword(r,e,t){t=t!==void 0?t:!0,this.keywords[r]={callback:e,cache:t}}remove(r){delete this.nodes[r.name]}removeKeyword(r){delete this.keywords[r]}get(r){return this.nodes[r]}getKeyword(r,e){return this.keywords[r].callback(e)}getKeywordData(r){return this.keywords[r]}contains(r){return this.nodes[r]!==void 0}containsKeyword(r){return this.keywords[r]!==void 0}},tt=new Al;var Ml=require("three");var sd=require("three"),le=class extends st{constructor(e,t){super(e);this.scope="";t=t??{},this.shared=t.shared!==void 0?t.shared:!0,this.unique=t.unique!==void 0?t.unique:!1}build(e,t,o,i){if(t=t??this.getType(e),this.getShared(e,t)){let s=this.getUnique(e,t);s&&this.uuid===void 0&&(this.uuid=sd.MathUtils.generateUUID()),o=e.getUUID(o??this.getUUID(),!s);let a=e.getNodeData(o),l=a.output||this.getType(e);if(e.analyzing)return(a.deps||0)>0||this.getLabel()?(this.appendDepsNode(e,a,t),this.generate(e,t,o)):super.build(e,t,o);if(s)return a.name=a.name||super.build(e,t,o),a.name;if(!this.getLabel()&&(!this.getShared(e,l)||e.context.ignoreCache||a.deps===1))return super.build(e,t,o);o=this.getUUID(!1);let c=this.getTemp(e,o);if(c)return e.format(c,l,t);{c=super.generate(e,t,o,a.output,i);let u=this.generate(e,l,o);return e.addNodeCode(c+" = "+u+";"),e.format(c,l,t)}}return super.build(e,t,o)}getShared(e,t){return t!=="sampler2D"&&t!=="samplerCube"&&this.shared}getUnique(e,t){return this.unique}setLabel(e){return this.label=e,this}getLabel(){return this.label}getUUID(e){let t=this.uuid;return typeof this.scope=="string"&&(t=this.scope+"-"+t),t}getTemp(e,t){t=t||this.uuid;let o=e.getVars()[t];return o?o.name:void 0}generate(e,t,o,i,s){return this.getShared(e,t)||console.error("TempNode is not shared"),o=o??this.uuid,e.getTempVar(o,i??this.getType(e),s,this.getLabel()).name}};var Ae=class extends le{constructor(e,t){t=t??{},t.shared=t.shared!==void 0?t.shared:!1;super(e,t);this.readonly=!1}setReadonly(e){return this.readonly=e,this.hashProperties=this.readonly?["value"]:void 0,this}getReadonly(){return this.readonly}generate(e,t,o,i,s,a){o=e.getUUID(o??this.getUUID()),i=i??this.getType(e);let l=e.getNodeData(o);return this.getReadonly()&&this.generateReadonly!==void 0?this.generateReadonly(e,t,o,i,s,a):e.isShader("vertex")?(l.vertex||(l.vertex=e.createVertexUniform(i,this,s,a,this.getLabel())),e.format(l.vertex.name,i,t)):(l.fragment||(l.fragment=e.createFragmentUniform(i,this,s,a,this.getLabel())),e.format(l.fragment.name,i,t))}};var rt=class extends Ae{constructor(e=0,t){super("v2");this.nodeType="Vector2";this.value=e instanceof Ml.Vector2?e:new Ml.Vector2(e,t)}get x(){return this.value.x}set x(e){this.value.x=e}get y(){return this.value.y}set y(e){this.value.y=e}generateReadonly(e,t,o,i,s,a){return e.format("vec2("+this.value.x+", "+this.value.y+")",i,t)}};var Ol=require("three");var pt=class extends Ae{constructor(e=0,t,o){super("v3");this.nodeType="Vector3";this.value=e instanceof Ol.Vector3?e:new Ol.Vector3(e,t,o)}get x(){return this.value.x}set x(e){this.value.x=e}get y(){return this.value.y}set y(e){this.value.y=e}get z(){return this.value.z}set z(e){this.value.z=e}generateReadonly(e,t,o,i,s,a){return e.format("vec3("+this.value.x+", "+this.value.y+", "+this.value.z+")",i,t)}};var Ht=class extends Ae{constructor(e){super("v4");this.nodeType="Vector4";this.value=e instanceof ut?e:new ut(e.r,e.g,e.b,e.a)}generateReadonly(e,t,o,i,s,a){return e.format("vec4("+this.value.r+", "+this.value.g+", "+this.value.b+", "+this.value.a+")",i,t)}};var Qv=/^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i,ad=/[a-z_0-9]+/gi,Y=class extends le{constructor(e,t,o,i,s){super(s);this.src="";this.nodeType="Function";this.useKeywords=!0;this.includes=[];this.extensions={};this.keywords={};this.isMethod=s===void 0,this.isInterface=!1,this.parse(e,t,o,i)}getShared(e,t){return!this.isMethod}getType(e){return e.getTypeByFormat(this.type)}getInputByName(e){if(this.inputs){let t=this.inputs.length;for(;t--;)if(this.inputs[t].name===e)return this.inputs[t]}}getIncludeByName(e){if(this.includes){let t=this.includes.length;for(;t--;)if(this.includes[t].name===e)return this.includes[t]}}generate(e,t,o,i,s){let a,l=0,c=this.src;if(this.includes)for(let m=0;m<this.includes.length;m++)e.include(this.includes[m],this);for(let m in this.extensions)e.extensions[m]=!0;let u=[];for(;a=ad.exec(this.src);)u.push(a);for(let m=0;m<u.length;m++){let p=u[m],d=p[0],f=this.isMethod?!this.getInputByName(d):!0,g=d;if(this.keywords[d]||this.useKeywords&&f&&tt.containsKeyword(d)){let x=this.keywords[d];if(!x){let y=tt.getKeywordData(d);y.cache&&(x=e.keywords[d]),x=x||tt.getKeyword(d,e),y.cache&&(e.keywords[d]=x)}g=x.build(e)}d!==g&&c[p.index+l-1]!=="."&&(c=c.substring(0,p.index+l)+g+c.substring(p.index+d.length+l),l+=g.length-d.length),this.getIncludeByName(g)===void 0&&tt.contains(g)&&e.include(tt.get(g))}return t==="source"?c:this.isMethod?(this.isInterface||e.include(this,void 0,c),this.name):e.format("( "+c+" )",this.getType(e),t)}parse(e,t,o,i){if(this.src=e||"",this.includes=t??[],this.extensions=o??{},this.keywords=i??{},this.isMethod){let s=Qv.exec(this.src);if(this.inputs=[],s&&s.length==4){this.type=s[1],this.name=s[2];let a=s[3].match(ad);if(a){let l=0;for(;l<a.length;){let c=a[l++],u;c==="in"||c==="out"||c==="inout"?u=a[l++]:(u=c,c="");let m=a[l++];this.inputs.push({name:m,type:u,qualifier:c})}}this.isInterface=this.src.indexOf("{")===-1}else this.type="",this.name=""}}};var Jv=/^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i,_l=class extends le{constructor(e="",t){super();this.src="";this.useDefine=!1;this.nodeType="Const";this.parse(e||_l.PI,void 0,void 0,void 0,t)}getType(e){return e.getTypeByFormat(this.type)}parse(e,t,o,i,s){this.src=e||"";let a,l,c="",u=Jv.exec(e);this.useDefine=s??this.src.charAt(0)==="#",u&&u.length>1?(l=u[1],a=u[2],c=u[3]):(a=this.src,l="f"),this.name=a,this.type=l,this.value=c}build(e,t){if(t==="source"){if(this.value)return this.useDefine?"#define "+this.name+" "+this.value:"const "+this.type+" "+this.name+" = "+this.value+";";if(this.useDefine)return this.src}return e.include(this),e.format(this.name,this.getType(e),t)}generate(e,t,o,i,s){return e.format(this.name,this.getType(e),t)}},we=_l;we.PI="PI",we.PI2="PI2",we.RECIPROCAL_PI="RECIPROCAL_PI",we.RECIPROCAL_PI2="RECIPROCAL_PI2",we.LOG2="LOG2",we.EPSILON="EPSILON";var Zv=new RegExp(`^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`,"gim"),eb=new RegExp("s*(w*?)s*(w*?)(=|;)","gim"),gn=class extends le{constructor(e=""){super();this.inputs=[];this.src="";this.nodeType="Struct";this.parse(e)}getType(e){return e.getTypeByFormat(this.name)}getInputByName(e){let t=this.inputs.length;for(;t--;)if(this.inputs[t].name===e)return this.inputs[t]}generate(e,t,o,i,s){return t==="source"?this.src+";":e.format("( "+this.src+" )",this.getType(e),t)}parse(e=""){this.src=e,this.inputs=[];let t=Zv.exec(e);if(t){let o=t[2],i;for(;i=eb.exec(o);)this.inputs.push({type:i[1],name:i[2]});this.name=t[1]}else this.name="";this.type=this.name}};var yn=class extends le{constructor(e){super("v2",{shared:!1});this.nodeType="UV";this.index=e??0}generate(e,t){e.requires.uv[this.index]=!0;let o=this.index>0?this.index+1:"",i=e.isShader("vertex")?"uv"+o:"vUv"+o;return e.format(i,this.getType(e),t)}};tt.addKeyword("uv",function(){return new yn});tt.addKeyword("uv2",function(){return new yn(1)});var aa=require("three");var vo=class extends le{constructor(e,t){super("v4");this.nodeType="ColorSpace";this.input=e,this.method=t??vo.LINEAR_TO_LINEAR,this.hashProperties=["method"]}static getEncodingComponents(e){switch(e){case aa.LinearEncoding:return["Linear"];case aa.sRGBEncoding:return["sRGB"];default:return[]}}generate(e,t){let o=this.input.build(e,"v4"),i=this.getType(e),s=vo.Nodes[this.method],a=e.include(s);if(a===vo.LINEAR_TO_LINEAR)return e.format(o,i,t);if(s.inputs?.length===2){let l=this.factor.build(e,"f");return e.format(a+"( "+o+", "+l+" )",i,t)}else return e.format(a+"( "+o+" )",i,t)}fromEncoding(e){let t=vo.getEncodingComponents(e);this.method="LinearTo"+t[0],this.factor=t[1]}fromDecoding(e){let t=vo.getEncodingComponents(e);this.method=t[0]+"ToLinear",this.factor=t[1]}},St=vo;St.Nodes={LinearToLinear:new Y(["vec4 LinearToLinear( in vec4 value ) {","	return value;","}"].join(`
`)),sRGBToLinear:new Y(["vec4 sRGBToLinear( in vec4 value ) {","	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );","}"].join(`
`)),LinearTosRGB:new Y(["vec4 LinearTosRGB( in vec4 value ) {","	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );","}"].join(`
`))},St.LINEAR_TO_LINEAR="LinearToLinear",St.SRGB_TO_LINEAR="sRGBToLinear",St.LINEAR_TO_SRGB="LinearTosRGB";var Ne=class extends Y{constructor(e="",t,o,i,s){super(e,s,i,o,t);this.nodeType="Expression"}};var ld=require("three"),wt=class extends Ae{constructor(e=new ld.Texture,t,o,i){super("v4",{shared:!0});this.nodeType="Texture";this.value=e,this.uv=t??new yn,this.bias=o,this.project=i!==void 0?i:!1}getTexture(e,t){return super.generate(e,t,this.value.uuid,"t")}generate(e,t){if(t==="sampler2D")return this.getTexture(e,t);let o=this.getTexture(e,t),i=this.uv.build(e,this.project?"v4":"v2"),s=this.bias?this.bias.build(e,"f"):void 0;s===void 0&&e.context.bias&&(s=e.context.bias.setTexture(this).build(e,"f"));let a,l;this.project?a="texture2DProj":a=s?"tex2DBias":"tex2D",s?l=a+"( "+o+", "+i+", "+s+" )":l=a+"( "+o+", "+i+" )";let c={include:e.isShader("vertex"),ignoreCache:!0},u=this.getType(e);return e.addContext(c),this.colorSpace=this.colorSpace??new St(new Ne("",u)),this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)),this.colorSpace.input.parse(l),l=this.colorSpace.build(e,u),e.removeContext(),e.format(l,u,t)}};var W=class extends Ae{constructor(e){super("f");this.nodeType="Float";this.value=e??0}generateReadonly(e,t,o,i,s,a){return e.format(this.value+(this.value%1?"":".0"),i,t)}};var ci=class extends le{constructor(e,t){super();this.inputs=[];this.nodeType="FunctionCall";this.value=e,this.inputs=t??[]}getFunction(){return this.value}getType(e){return this.value.getType(e)}generate(e,t,o,i,s){i=this.getType(e);let a=this.value,l=a.build(e,t)+"( ",c=[];if(a.inputs){for(let u=0;u<a.inputs.length;u++){let m=a.inputs[u],p=this.inputs[u]||this.inputs[m.name];c.push(p.build(e,e.getTypeByFormat(m.type)))}l+=c.join(", ")+" )"}return e.format(l,i,t)}};var Dl=class extends le{constructor(e,t,o=Dl.ADD){super();this.nodeType="Operator";this.type=e.type,this.a=e,this.b=t,this.op=o}getType(e){let t=this.a.getType(e),o=this.b.getType(e);return e.isTypeMatrix(t)?"v4":e.getTypeLength(o)>e.getTypeLength(t)?o:t}generate(e,t){let o=this.getType(e);this.type=o;let i=this.a.build(e,o),s=this.b.build(e,o);return e.format("( "+i+" "+this.op+" "+s+" )",o,t)}},At=Dl;At.ADD="+",At.SUB="-",At.MUL="*",At.DIV="/";var Me=class extends le{constructor(e,t=Me.ABS,o,i){super();this.nodeType="Math";this.a=e,typeof t!="string"?this.b=t:i=t,typeof o!="string"?this.c=o:i=o,this.method=i,this.hashProperties=["method"]}getNumInputs(e){switch(this.method){case Me.MIX:case Me.CLAMP:case Me.REFRACT:case Me.SMOOTHSTEP:case Me.FACEFORWARD:return 3;case Me.MIN:case Me.MAX:case Me.MOD:case Me.STEP:case Me.REFLECT:case Me.DISTANCE:case Me.DOT:case Me.CROSS:case Me.POW:return 2;default:return 1}}getInputType(e){let t=e.getTypeLength(this.a.getType(e)),o=this.b?e.getTypeLength(this.b.getType(e)):0,i=this.c?e.getTypeLength(this.c.getType(e)):0;return t>o&&t>i?this.a.getType(e):o>i?this.b.getType(e):this.c.getType(e)}getType(e){switch(this.method){case Me.LENGTH:case Me.DISTANCE:case Me.DOT:return"f";case Me.CROSS:return"v3"}return this.getInputType(e)}generate(e,t){let o,i,s,a=this.a?e.getTypeLength(this.a.getType(e)):0,l=this.b?e.getTypeLength(this.b.getType(e)):0,c=this.c?e.getTypeLength(this.c.getType(e)):0,u=this.getInputType(e),m=this.getType(e);switch(this.type=m,this.method){case Me.NEGATE:return e.format("( -"+this.a.build(e,u)+" )",u,t);case Me.INVERT:return e.format("( 1.0 - "+this.a.build(e,u)+" )",u,t);case Me.CROSS:o=this.a.build(e,"v3"),i=this.b.build(e,"v3");break;case Me.STEP:o=this.a.build(e,a===1?"f":u),i=this.b.build(e,u);break;case Me.MIN:case Me.MAX:case Me.MOD:o=this.a.build(e,u),i=this.b.build(e,l===1?"f":u);break;case Me.REFRACT:o=this.a.build(e,u),i=this.b.build(e,u),s=this.c.build(e,"f");break;case Me.MIX:o=this.a.build(e,u),i=this.b.build(e,u),s=this.c.build(e,c===1?"f":u);break;default:o=this.a.build(e,u),this.b&&(i=this.b.build(e,u)),this.c&&(s=this.c.build(e,u));break}let p=[];p.push(o),i&&p.push(i),s&&p.push(s);let d=this.getNumInputs(e);if(p.length!==d)throw Error(`Arguments not match used in "${this.method}". Require ${d}, currently ${p.length}.`);return e.format(this.method+"( "+p.join(", ")+" )",m,t)}},de=Me;de.RAD="radians",de.DEG="degrees",de.EXP="exp",de.EXP2="exp2",de.LOG="log",de.LOG2="log2",de.SQRT="sqrt",de.INV_SQRT="inversesqrt",de.FLOOR="floor",de.CEIL="ceil",de.NORMALIZE="normalize",de.FRACT="fract",de.SATURATE="saturate",de.SIN="sin",de.COS="cos",de.TAN="tan",de.ASIN="asin",de.ACOS="acos",de.ARCTAN="atan",de.ABS="abs",de.SIGN="sign",de.LENGTH="length",de.NEGATE="negate",de.INVERT="invert",de.MIN="min",de.MAX="max",de.MOD="mod",de.STEP="step",de.REFLECT="reflect",de.DISTANCE="distance",de.DOT="dot",de.CROSS="cross",de.POW="pow",de.MIX="mix",de.CLAMP="clamp",de.REFRACT="refract",de.SMOOTHSTEP="smoothstep",de.FACEFORWARD="faceforward";var xn=class extends le{constructor(e,t,o){super("v4");this.nodeType="TextureCubeUV";this.value=e,this.uv=t,this.bias=o}bilinearCubeUV(e,t,o,i){let s=new ci(xn.Nodes.bilinearCubeUV,[t,o,i]);this.colorSpaceTL=this.colorSpaceTL??new St(new Ne("","v4")),this.colorSpaceTL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTL.input.parse(s.build(e)+".tl"),this.colorSpaceTR=this.colorSpaceTR??new St(new Ne("","v4")),this.colorSpaceTR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTR.input.parse(s.build(e)+".tr"),this.colorSpaceBL=this.colorSpaceBL??new St(new Ne("","v4")),this.colorSpaceBL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBL.input.parse(s.build(e)+".bl"),this.colorSpaceBR=this.colorSpaceBR??new St(new Ne("","v4")),this.colorSpaceBR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBR.input.parse(s.build(e)+".br");let a={include:e.isShader("vertex"),ignoreCache:!0};e.addContext(a),this.colorSpaceTLExp=new Ne(this.colorSpaceTL.build(e,"v4"),"v4"),this.colorSpaceTRExp=new Ne(this.colorSpaceTR.build(e,"v4"),"v4"),this.colorSpaceBLExp=new Ne(this.colorSpaceBL.build(e,"v4"),"v4"),this.colorSpaceBRExp=new Ne(this.colorSpaceBR.build(e,"v4"),"v4"),e.removeContext();let l=new Ne("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )","v4");return l.keywords.cubeUV_TL=this.colorSpaceTLExp,l.keywords.cubeUV_TR=this.colorSpaceTRExp,l.keywords.cubeUV_BL=this.colorSpaceBLExp,l.keywords.cubeUV_BR=this.colorSpaceBRExp,l.keywords.cubeUV=s,l}generate(e,t){if(e.isShader("fragment")){let o=this.uv,i=this.bias||e.context.roughness,s=new ci(xn.Nodes.roughnessToMip,[i]),a=new de(s,xn.Nodes.m0,xn.Nodes.cubeUV_maxMipLevel,de.CLAMP),l=new de(a,de.FLOOR),c=new de(a,de.FRACT),u=this.bilinearCubeUV(e,this.value,o,l),m=this.bilinearCubeUV(e,this.value,o,new At(l,new W(1).setReadonly(!0),At.ADD)),p=new de(u,m,c,de.MIX);return e.format(p.build(e),"v4",t)}else return console.warn("TextureCubeUVNode is not compatible with "+e.shader+" shader."),e.format("vec4( 0.0 )",this.getType(e),t)}},vn=xn;vn.Nodes=function(){let e=new gn(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`),t=new we("float cubeUV_maxMipLevel 8.0",!0),o=new we("float cubeUV_minMipLevel 4.0",!0),i=new we("float cubeUV_maxTileSize 256.0",!0),s=new we("float cubeUV_minTileSize 16.0",!0),a=new Y(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`);a.useKeywords=!1;let l=new Y(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`);l.useKeywords=!1;let c=new Y(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`,[e,a,l,t,o,i,s]);c.useKeywords=!1;let u=new we("float r0 1.0",!0),m=new we("float v0 0.339",!0),p=new we("float m0 -2.0",!0),d=new we("float r1 0.8",!0),f=new we("float v1 0.276",!0),g=new we("float m1 -1.0",!0),x=new we("float r4 0.4",!0),y=new we("float v4 0.046",!0),v=new we("float m4 2.0",!0),P=new we("float r5 0.305",!0),S=new we("float v5 0.016",!0),b=new we("float m5 3.0",!0),E=new we("float r6 0.21",!0),w=new we("float v6 0.0038",!0),h=new we("float m6 4.0",!0),_=[u,m,p,d,f,g,x,y,v,P,S,b,E,w,h],N=new Y(`float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`,_);return{bilinearCubeUV:c,roughnessToMip:N,m0:p,cubeUV_maxMipLevel:t}}();var bo=class extends le{constructor(e){super("v3");this.nodeType="Normal";this.scope=e??bo.VIEW}getShared(){return this.scope===bo.WORLD}build(e,t,o,i){let s=e.context[this.scope+"Normal"];return s?s.build(e,t,o,i):super.build(e,t,o)}generate(e,t,o,i,s){let a;switch(this.scope){case bo.VIEW:e.isShader("vertex")?a="transformedNormal":a="geometryNormal";break;case bo.LOCAL:e.isShader("vertex")?a="objectNormal":(e.requires.normal=!0,a="vObjectNormal");break;case bo.WORLD:e.isShader("vertex")?a="inverseTransformDirection( transformedNormal, viewMatrix ).xyz":(e.requires.worldNormal=!0,a="vWNormal");break}return e.format(a,this.getType(e),t)}},at=bo;at.LOCAL="local",at.WORLD="world",at.VIEW="view",at.NORMAL="normal";tt.addKeyword("viewNormal",function(){return new at(at.VIEW)});tt.addKeyword("localNormal",function(){return new at(at.NORMAL)});tt.addKeyword("worldNormal",function(){return new at(at.WORLD)});var yr=class extends le{constructor(e){super("v3");this.nodeType="Position";this.scope=e??yr.LOCAL}getType(){switch(this.scope){case yr.PROJECTION:return"v4"}return this.type}getShader(){switch(this.scope){case yr.LOCAL:case yr.WORLD:return!1}return!0}generate(e,t,o,i,s){let a;switch(this.scope){case yr.LOCAL:e.isShader("vertex")?a="transformed":(e.requires.position=!0,a="vPosition");break;case yr.WORLD:if(e.isShader("vertex"))return"( modelMatrix * vec4( transformed, 1.0 ) ).xyz";e.requires.worldPosition=!0,a="vWPosition";break;case yr.VIEW:a=e.isShader("vertex")?"-mvPosition.xyz":"vViewPosition";break;case yr.PROJECTION:a=e.isShader("vertex")?"( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )":"vec4( 0.0 )";break}return e.format(a,this.getType(),t)}},Mt=yr;Mt.LOCAL="local",Mt.WORLD="world",Mt.VIEW="view",Mt.PROJECTION="projection";tt.addKeyword("position",function(){return new Mt});tt.addKeyword("worldPosition",function(){return new Mt(Mt.WORLD)});tt.addKeyword("viewPosition",function(){return new Mt(Mt.VIEW)});var Kt=class extends le{constructor(e){super("v3");this.nodeType="Reflect";this.scope=e??Kt.CUBE}getUnique(e){return!e.context.viewNormal}getType(){switch(this.scope){case Kt.SPHERE:return"v2"}return this.type}generate(e,t){let o=this.getUnique(e);if(e.isShader("fragment")){let i;switch(this.scope){case Kt.VECTOR:{let s=new at(at.VIEW),a=e.context.roughness,l=s.build(e,"v3"),c=new Mt(Mt.VIEW).build(e,"v3"),u=a?a.build(e,"f"):void 0,m=`reflect( -normalize( ${c} ), ${l} )`;u&&(m=`normalize( mix( ${m}, ${l}, ${u} * ${u} ) )`);let p=`inverseTransformDirection( ${m}, viewMatrix )`;o?(e.addNodeCode(`vec3 reflectVec = ${p};`),i="reflectVec"):i=p;break}case Kt.CUBE:{let s=new Kt(Kt.VECTOR).build(e,"v3"),a="vec3( -"+s+".x, "+s+".yz )";o?(e.addNodeCode(`vec3 reflectCubeVec = ${a};`),i="reflectCubeVec"):i=a;break}case Kt.SPHERE:{let s=new Kt(Kt.VECTOR).build(e,"v3"),a="normalize( ( viewMatrix * vec4( "+s+", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";o?(e.addNodeCode(`vec2 reflectSphereVec = ${a};`),i="reflectSphereVec"):i=a;break}}return e.format(i,this.getType(),t)}else return console.warn("ReflectNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.type,t)}},xr=Kt;xr.CUBE="cube",xr.SPHERE="sphere",xr.VECTOR="vector";var la=class extends le{constructor(e=new wt,t,o){super("v4");this.nodeType="TextureCube";this.value=e,this.radianceNode=new vn(this.value,t??new xr(xr.VECTOR),o),this.irradianceNode=new vn(this.value,new at(at.WORLD),new W(1).setReadonly(!0))}generate(e,t){return e.isShader("fragment")?(e.require("irradiance"),e.context.bias&&e.context.bias.setTexture(this.value),(e.slot==="irradiance"?this.irradianceNode:this.radianceNode).build(e,t)):(console.warn("TextureCubeNode is not compatible with "+e.shader+" shader."),e.format("vec4( 0.0 )",this.getType(e),t))}};var cd=require("three");var ca=class extends Ae{constructor(e=new cd.CubeTexture,t,o){super("v4",{shared:!0});this.nodeType="CubeTexture";this.value=e,this.uv=t??new xr,this.bias=o}getTexture(e,t){return super.generate(e,t,this.value.uuid,"tc")}generate(e,t){if(t==="samplerCube")return this.getTexture(e,t);let o=this.getTexture(e,t),i=this.uv?.build(e,"v3"),s=this.bias?this.bias.build(e,"f"):void 0;s===void 0&&e.context.bias&&(s=e.context.bias.setTexture(this).build(e,"f"));let a;s?a="texCubeBias( "+o+", "+i+", "+s+" )":a="texCube( "+o+", "+i+" )";let l={include:e.isShader("vertex"),ignoreCache:!0},c=this.getType(e);return e.addContext(l),this.colorSpace=this.colorSpace??new St(new Ne("",c)),this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)),this.colorSpace.input.parse(a),a=this.colorSpace.build(e,c),e.removeContext(),e.format(a,c,t)}};var ud=["x","y","z","w"],tb=["float","vec2","vec3","vec4"],rb={float:"f",vec2:"v2",vec3:"v3",vec4:"v4",mat4:"v4",int:"i",bool:"b","float[]":"f[]","vec4[]":"v4[]"},ob={t:"sampler2D",tc:"samplerCube",b:"bool",i:"int",f:"float",c:"vec3",v2:"vec2",v3:"vec3",v4:"vec4",m3:"mat3",m4:"mat4","f[]":"float[]","v4[]":"vec4[]"},ua=class{constructor(){this.includes={consts:{},functions:{},structs:{}};this.cache="";this.slot="";this.shader="";this.context={};this.getIncludesCode=function(){function r(e,t){return e.deps.length-t.deps.length}return function(t,o){let i=this.getIncludes(t,o);if(!i)return"";let s="";i=i.sort(r);for(let a=0;a<i.length;a++)i[a].src&&(s+=i[a].src+`
`);return s}}();this.slots=[],this.caches=[],this.contexts=[],this.keywords={},this.nodeData={},this.fragmentVariables={},this.fragmentParsVariables={},this.vertexParsVariables={},this.requires={uv:[],color:[],lights:!1,fog:!1,transparent:!1,irradiance:!1,position:!1,worldPosition:!1,normal:!1,worldNormal:!1,vWorldViewDir:!1,modelMatrix:!1,viewMatrix:!1,projectionMatrix:!1},this.includes={consts:[],functions:[],structs:[]},this.attributes={},this.prefixCode=["#ifdef TEXTURE_LOD_EXT","	#define texCube(a, b) textureCube(a, b)","	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)","	#define tex2D(a, b) texture2D(a, b)","	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)","#else","	#define texCube(a, b) textureCube(a, b)","	#define texCubeBias(a, b, c) textureCube(a, b, c)","	#define tex2D(a, b) texture2D(a, b)","	#define tex2DBias(a, b, c) texture2D(a, b, c)","#endif",`
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`,"#include <packing>","#include <common>"].join(`
`),this.parsCode={vertex:["float neighbor_offset = 0.0001;",""].join(`
`),fragment:["float accumAlpha = 0.0;",`void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`,""].join(`
`)},this.code={vertex:"",fragment:""},this.nodeCode={vertex:"",fragment:""},this.resultCode={vertex:"",fragment:""},this.finalCode={vertex:"",fragment:""},this.inputs={uniforms:{list:[],vertex:[],fragment:[]},arrayUniforms:{list:[],vertex:[],fragment:[]},vars:{varying:[],vertex:[],fragment:[]}},this.defines={},this.uniforms={},this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.updaters=[],this.nodes=[],this.analyzing=!1}build(r,e){this.buildShader("vertex",r),this.buildShader("fragment",e);for(let t=0;t<this.requires.uv.length;t++)if(this.requires.uv[t]){let o=t>0?t+1:"";this.addVaryCode("varying vec2 vUv"+o+";"),t>0&&this.addVertexParsCode("attribute vec2 uv"+o+";"),this.addVertexFinalCode("vUv"+o+" = uv"+o+";")}return this.requires.color[0]&&(this.addVaryCode("varying vec4 vColor;"),this.addVertexParsCode("attribute vec4 color;"),this.addVertexFinalCode("vColor = color;")),this.requires.color[1]&&(this.addVaryCode("varying vec4 vColor2;"),this.addVertexParsCode("attribute vec4 color2;"),this.addVertexFinalCode("vColor2 = color2;")),this.requires.position&&(this.addVaryCode("varying vec3 vPosition;"),this.addVertexFinalCode("vPosition = transformed;")),this.requires.worldPosition,this.requires.normal&&(this.addVaryCode("varying vec3 vObjectNormal;"),this.addVertexFinalCode("vObjectNormal = normal;")),this.requires.modelMatrix&&this.addFragmentParsCode("uniform mat4 modelMatrix;"),this.requires.viewMatrix&&this.addFragmentParsCode("uniform mat4 viewMatrix;"),this.requires.projectionMatrix&&this.addFragmentParsCode("uniform mat4 projectionMatrix;"),this.requires.worldNormal&&(this.addVaryCode("varying vec3 vWNormal;"),this.addVertexFinalCode("vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;")),this.requires.vWorldViewDir&&(this.addVaryCode("varying vec3 vWorldViewDir;"),this.addVertexFinalCode("vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );")),this}buildShader(r,e){this.resultCode[r]=e.build(this.setShader(r),"v4")}setMaterial(r,e){return this.material=r,this.renderer=e,this.requires.lights=r.lights,this.requires.fog=r.fog,this.mergeDefines(r.defines),this}addFlow(r,e,t){return this.addSlot(r).addCache(e).addContext(t)}removeFlow(){return this.removeSlot().removeCache().removeContext()}addCache(r){return this.cache=r??"",this.caches.push(this.cache),this}removeCache(){return this.caches.pop(),this.cache=this.caches[this.caches.length-1]||"",this}addContext(r){return this.context=Object.assign({},this.context,r),this.context.extra=this.context.extra||{},this.contexts.push(this.context),this}removeContext(){return this.contexts.pop(),this.context=this.contexts[this.contexts.length-1]||{},this}addSlot(r){return this.slot=r||"",this.slots.push(this.slot),this}removeSlot(){return this.slots.pop(),this.slot=this.slots[this.slots.length-1]||"",this}addFragmentVariable(r,e){this.fragmentVariables[r]===void 0&&(this.addFragmentCode(`${e} ${r};`),this.fragmentVariables[r]="")}addFragmentParsVariable(r,e){this.fragmentParsVariables[r]===void 0&&(this.addFragmentParsCode(`${e} ${r};`),this.fragmentParsVariables[r]="")}addVertexParsVariable(r,e){this.vertexParsVariables[r]===void 0&&(this.addVertexParsCode(`${e} ${r};`),this.vertexParsVariables[r]="")}addVertexCode(r){this.addCode(r,"vertex")}addFragmentCode(r){this.addCode(r,"fragment")}addCode(r,e){this.code[e??this.shader]+=r+`
`}addVertexNodeCode(r){this.addNodeCode(r,"vertex")}addFragmentNodeCode(r){this.addNodeCode(r,"fragment")}addNodeCode(r,e){this.nodeCode[e??this.shader]+=r+`
`}clearNodeCode(r){r=r??this.shader;let e=this.nodeCode[r];return this.nodeCode[r]="",e}clearVertexNodeCode(){return this.clearNodeCode("vertex")}clearFragmentNodeCode(){return this.clearNodeCode("fragment")}addVertexFinalCode(r){this.addFinalCode(r,"vertex")}addFragmentFinalCode(r){this.addFinalCode(r,"fragment")}addFinalCode(r,e){this.finalCode[e??this.shader]+=r+`
`}addVertexParsCode(r){this.addParsCode(r,"vertex")}addFragmentParsCode(r){this.addParsCode(r,"fragment")}addParsCode(r,e){this.parsCode[e??this.shader]+=r+`
`}addVaryCode(r){this.addVertexParsCode(r),this.addFragmentParsCode(r)}isCache(r){return this.caches.indexOf(r)!==-1}isSlot(r){return this.slots.indexOf(r)!==-1}define(r,e){this.defines[r]=e===void 0?1:e}require(r){this.requires[r]=!0}isDefined(r){return this.defines[r]!==void 0}getVar(r,e,t,o="varying",i="V",s=""){let a=this.getVars(o),l=a[r];if(!l){let c=a.length;l={name:t||"node"+i+c+(s?"_"+s:""),type:e},a.push(l),a[r]=l}return l}getTempVar(r,e,t,o){return this.getVar(r,e,t,this.shader,"T",o)}getAttribute(r,e){if(!this.attributes[r]){let t=this.getVar(r,e);this.addVertexParsCode("attribute "+e+" "+r+";"),this.addVertexFinalCode(t.name+" = "+r+";"),this.attributes[r]={varying:t,name:r,type:e}}return this.attributes[r]}getCode(r){return[this.prefixCode,this.parsCode[r],this.getVarListCode(this.getVars("varying"),"varying"),this.getVarListCode(this.inputs.uniforms[r],"uniform"),this.getVarListCode(this.inputs.arrayUniforms[r],"uniform"),this.getIncludesCode("consts",r),this.getIncludesCode("structs",r),this.getIncludesCode("functions",r),"void main() {",this.getVarListCode(this.getVars(r)),this.code[r],this.resultCode[r],this.finalCode[r],"}"].join(`
`)}getVarListCode(r,e){e=e??"";let t="";for(let o=0,i=r.length;o<i;++o){let s=r[o],a=s.type,l=s.name,c=s.size,u=this.getFormatByType(a);if(u===void 0)throw new Error("Node pars "+u+" not found.");u.includes("[]")?t+=e+" "+u.substring(0,u.length-2)+" "+l+`[${c}];
`:t+=e+" "+u+" "+l+`;
`}return t}getVars(r){return this.inputs.vars[r??this.shader]}getNodeData(r){let e=r instanceof st?r.uuid:r;return this.nodeData[e]=this.nodeData[e]||{}}createUniform(r,e,t,o,i,s){if(e.includes("[]")){let a=this.inputs.arrayUniforms,l=a.list.length,c=new li({type:e,size:t.size,name:o||"nodeUA"+l+(s?"_"+s:""),node:t,needsUpdate:i});return a.list.push(c),a[r].push(c),a[r][c.name]=c,this.uniforms[c.name]=c,c}else{let a=this.inputs.uniforms,l=a.list.length,c=new li({type:e,name:o||"nodeU"+l+(s?"_"+s:""),node:t,needsUpdate:i});return a.list.push(c),a[r].push(c),a[r][c.name]=c,this.uniforms[c.name]=c,c}}createVertexUniform(r,e,t,o,i){return this.createUniform("vertex",r,e,t,o,i)}createFragmentUniform(r,e,t,o,i){return this.createUniform("fragment",r,e,t,o,i)}include(r,e,t){let o;if(r=typeof r=="string"?tt.get(r):r,this.context.include===!1)return r.name;r instanceof Y?o=this.includes.functions:r instanceof we?o=this.includes.consts:r instanceof gn&&(o=this.includes.structs);let i=o[this.shader]=o[this.shader]||[];if(r){let s=i[r.name];if(s||(s=i[r.name]={node:r,deps:[]},i.push(s),s.src=r.build(this,"source")),r instanceof Y&&e&&i[e.name]&&i[e.name].deps.indexOf(r)===-1&&(i[e.name].deps.push(r),r.includes?.length)){let a=0;do this.include(r.includes[a++],e);while(a<r.includes.length)}return t&&(s.src=t),r.name}else throw new Error("Include not found.")}colorToVectorProperties(r){return r.replace("r","x").replace("g","y").replace("b","z").replace("a","w")}colorToVector(r){return r.replace(/c/g,"v3")}getIncludes(r,e){return this.includes[r][e||this.shader]}getConstructorFromLength(r){return tb[r-1]}isTypeMatrix(r){return/^m/.test(r)}getTypeLength(r){return r==="f"?1:parseInt(this.colorToVector(r).substr(1))}getTypeFromLength(r){return r===1?"f":"v"+r}findNode(...r){for(let e=0;e<arguments.length;e++){let t=r[e];if(t?.isNode)return t}}resolve(...r){for(let e=0;e<arguments.length;e++){let t=r[e];if(t!==void 0){if(t.isNode)return t;if(t.isTexture)switch(t.mapping){case Qt.CubeReflectionMapping:case Qt.CubeRefractionMapping:return new ca(t);case Qt.CubeUVReflectionMapping:return new la(new wt(t));default:return new wt(t)}else{if(t.isVector2)return new rt(t);if(t.isVector3)return new pt(t);if(t.isVector4)return new Ht(t)}}}}format(r,e,t){switch(this.colorToVector(t+" <- "+e)){case"f <- v2":return r+".x";case"f <- v3":return r+".x";case"f <- v4":return r+".x";case"f <- i":case"f <- b":return"float( "+r+" )";case"v2 <- f":return"vec2( "+r+" )";case"v2 <- v3":return r+".xy";case"v2 <- v4":return r+".xy";case"v2 <- i":case"v2 <- b":return"vec2( float( "+r+" ) )";case"v3 <- f":return"vec3( "+r+" )";case"v3 <- v2":return"vec3( "+r+", 0.0 )";case"v3 <- v4":return r+".xyz";case"v3 <- i":case"v3 <- b":return"vec2( float( "+r+" ) )";case"v4 <- f":return"vec4( "+r+" )";case"v4 <- v2":return"vec4( "+r+", 0.0, 1.0 )";case"v4 <- v3":return"vec4( "+r+", 1.0 )";case"v4 <- i":case"v4 <- b":return"vec4( float( "+r+" ) )";case"i <- f":case"i <- b":return"int( "+r+" )";case"i <- v2":return"int( "+r+".x )";case"i <- v3":return"int( "+r+".x )";case"i <- v4":return"int( "+r+".x )";case"b <- f":return"( "+r+" != 0.0 )";case"b <- v2":return"( "+r+" != vec2( 0.0 ) )";case"b <- v3":return"( "+r+" != vec3( 0.0 ) )";case"b <- v4":return"( "+r+" != vec4( 0.0 ) )";case"b <- i":return"( "+r+" != 0 )"}return r}getTypeByFormat(r){return rb[r]||r}getFormatByType(r){return ob[r]||r}getUUID(r,e){return e=e!==void 0?e:!0,e&&this.cache&&(r=this.cache+"-"+r),r}getElementByIndex(r){return ud[r]}getIndexByElement(r){return ud.indexOf(r)}isShader(r){return this.shader===r}setShader(r){return this.shader=r,this}mergeDefines(r){for(let e in r)this.defines[e]=r[e];return this.defines}mergeUniform(r){for(let e in r)this.uniforms[e]=r[e];return this.uniforms}getTextureEncodingFromMap(r){let e;return r?r.isTexture&&(e=r.encoding):e=Qt.LinearEncoding,e===Qt.LinearEncoding&&this.context.gamma&&(e=Qt.sRGBEncoding),e}};var be=require("three");var Ie=class extends Ae{constructor(e=0,t,o,i){super("c");this.nodeType="Color";this.value=e instanceof ut?e:new ut(e||0,t,o,i)}setRGBA(e){this.value.setRGBA(e.r,e.g,e.b,e.a)}generate(e,t,o,i,s,a){o=e.getUUID(o??this.getUUID()),i=i??this.getType(e);let l=e.getNodeData(o),c=this.getReadonly()&&this.generateReadonly!==void 0;if(this.alpha){let u=this.alpha.build(e,"f");e.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${u};`)}return c?this.generateReadonly(e,t,o,i,s,a):e.isShader("vertex")?(l.vertex||(l.vertex=e.createVertexUniform(i,this,s,a,this.getLabel())),e.format(l.vertex.name,i,t)):(l.fragment||(l.fragment=e.createFragmentUniform(i,this,s,a,this.getLabel())),e.format(l.fragment.name,i,t))}generateReadonly(e,t,o,i,s,a){return e.format("vec3("+this.value.r+", "+this.value.g+", "+this.value.b+")",i,t)}};var ge=class extends Ae{constructor(e){super("i");this.nodeType="Int";this.value=Math.floor(e??0)}generateReadonly(e,t,o,i,s,a){return e.format(this.value.toString(),i,t)}};var pa=require("three");var eo=class extends st{constructor(){super("basic");this.nodeType="Basic";this.color=new Ie(5855577),this.shadingAlpha=new W(1),this.shadingBlend=new ge(0)}generate(e){let t;if(e.isShader("vertex")){let o=this.position?this.position.analyzeAndFlow(e,"v3",{cache:"position"}):void 0;e.mergeUniform(pa.UniformsUtils.merge([pa.UniformsLib.fog])),e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <normal_pars_vertex>"].join(`
`));let i=["#include <beginnormal_vertex>",`
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,"#include <normal_vertex>",`
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];o&&i.push(o.code,o.result?"displaced_position = "+o.result+";":""),i.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","	vNormal = transformedNormal;","#endif"),i.push("#include <project_vertex>","#include <fog_vertex>","#include <clipping_planes_vertex>","	vViewPosition = - mvPosition.xyz;","#include <worldpos_vertex>"),i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),t=i.join(`
`)}else{this.color===void 0&&(this.color=new Ie(5855577)),this.color.analyze(e,{slot:"color"}),this.alpha&&this.alpha.analyze(e),this.afterColor&&this.afterColor.analyze(e,{slot:"afterColor"});let o=this.color.flow(e,"c",{slot:"color"}),i=this.alpha?this.alpha.flow(e,"f"):void 0,s=this.afterColor?this.afterColor.flow(e,"c",{slot:"afterColor"}):void 0;e.requires.transparent=i!==void 0,e.addParsCode(["varying vec3 vWPosition;","#include <fog_pars_fragment>","#include <dithering_pars_fragment>","varying vec3 vViewPosition;","#include <normal_pars_fragment>"].join(`
`));let a=["#include <normal_fragment_begin>",o.code];i&&a.push(i.code,"#ifdef ALPHATEST"," if ( "+i.result+" <= ALPHATEST ) discard;","#endif"),s?a.push(s.code,`vec3 outgoingLight = ${o.result};`,`vec3 finalColor = spe_blend(outgoingLight, ${s.result}, 1.0, SPE_BLENDING_NORMAL);`):a.push(`vec3 finalColor = ${o.result};`),i?a.push(`gl_FragColor = vec4( finalColor, accumAlpha * ${i.result} );`):a.push("gl_FragColor = vec4("+o.result+", 1.0 );"),a.push("#include <fog_fragment>","#include <dithering_fragment>"),t=a.join(`
`)}return t}};var ui=require("three");var ot=class extends Ae{constructor(e=1,t){super("f[]");this.nodeType="FloatArray";this.size=e,this.value=Array.isArray(t)?t:typeof t=="number"?new Array(e).fill(t):new Array(e).fill(0)}};var pi=class extends st{constructor(){super("lambert");this.nodeType="Lambert";this.color=new Ie(5855577),this.emissive=new Ie(0),this.emissiveIntensity=new W(1),this.penumbraSize=new ot(5,.5),this.shadingAlpha=new W(1),this.shadingBlend=new ge(0)}build(e){let t;if(e.define("LAMBERT"),e.requires.lights=!0,e.extensions.derivatives=!0,e.isShader("vertex")){let o=this.position?this.position.analyzeAndFlow(e,"v3",{cache:"position"}):void 0;e.mergeUniform(ui.UniformsUtils.merge([ui.UniformsLib.fog,ui.UniformsLib.lights])),e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","varying vec3 vLightFront;","varying vec3 vIndirectFront;","#ifndef DOUBLE_SIDED","   #define DOUBLE_SIDED","#endif","#ifdef DOUBLE_SIDED","	varying vec3 vLightBack;","	varying vec3 vIndirectBack;","#endif","#include <bsdfs>","#include <lights_pars_begin>","#include <color_pars_vertex>","#include <fog_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join(`
`));let i=["#include <beginnormal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,"#include <normal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];o&&i.push(o.code,o.result?"displaced_position = "+o.result+";":""),i.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),i.push("	#include <project_vertex>","	#include <clipping_planes_vertex>","	vViewPosition = - mvPosition.xyz;","	#include <worldpos_vertex>",`
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`,"	#include <shadowmap_vertex>","	#include <fog_vertex>"),i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),t=i.join(`
`)}else{e.mergeUniform({penumbraSize:this.penumbraSize}),this.color===void 0&&(this.color=new Ie(5855577)),this.color.analyze(e,{slot:"color"}),this.shadingAlpha.analyze(e),this.shadingBlend.analyze(e),this.afterColor&&this.afterColor.analyze(e,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(e);let o=this.color.flow(e,"c",{slot:"color"}),i=this.emissive.flow(e,"c",{slot:"emissive"}),s=this.emissiveIntensity.flow(e,"f",{slot:"emissive"}),a=this.shadingAlpha.flow(e,"f"),l=this.shadingBlend.flow(e,"i"),c=this.afterColor?this.afterColor.flow(e,"c",{slot:"afterColor"}):void 0,u=this.alpha?this.alpha.flow(e,"f"):void 0;e.requires.transparent=u!==void 0,e.addParsCode([`uniform float penumbraSize[${5}];`,"varying vec3 vViewPosition;","varying vec3 vWPosition;","varying vec3 vLightFront;","varying vec3 vIndirectFront;","#ifndef DOUBLE_SIDED","   #define DOUBLE_SIDED","#endif","#include <normal_pars_fragment>","#ifdef DOUBLE_SIDED","	varying vec3 vLightBack;","	varying vec3 vIndirectBack;","#endif","#include <bsdfs>","#include <lights_pars_begin>","#include <fog_pars_fragment>","#include <shadowmap_pars_fragment>","#include <shadowmask_pars_fragment>","#include <clipping_planes_pars_fragment>","#include <dithering_pars_fragment>"].join(`
`));let m=["#include <normal_fragment_begin>",`
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`,"#include <clipping_planes_fragment>"];m.push(o.code,"vec3 diffuseColor = "+o.result+";","ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"),u&&m.push(u.code,"#ifdef ALPHATEST","if ( "+u.result+" <= ALPHATEST ) discard;","#endif"),m.push("#ifdef DOUBLE_SIDED","	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;","#else","	reflectedLight.indirectDiffuse += vIndirectFront;","#endif","#include <lightmap_fragment>","reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );","#ifdef DOUBLE_SIDED","	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;","#else","	reflectedLight.directDiffuse = vLightFront;","#endif","reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"),i&&m.push(i.code,"reflectedLight.directDiffuse += "+i.result+" * "+s.result+";"),m.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;"),m.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result}, ${l.result} );
				}
				`),c&&m.push(c.code,`outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`),u?m.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${u.result} );`):m.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),m.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),t=m.join(`
`)}return t}};var mi=require("three");var ma=class extends st{constructor(){super("phong");this.nodeType="Phong";this.color=new Ie(5855577),this.specular=new Ie(1118481),this.shininess=new W(30),this.penumbraSize=new ot(5,.5),this.shadingAlpha=new W(1),this.shadingBlend=new ge(0)}build(e){let t;if(e.define("PHONG"),e.requires.lights=!0,e.extensions.derivatives=!0,e.isShader("vertex")){let o=this.position?this.position.analyzeAndFlow(e,"v3",{cache:"position"}):void 0;e.mergeUniform(mi.UniformsUtils.merge([mi.UniformsLib.fog,mi.UniformsLib.lights])),e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join(`
`));let i=["#include <beginnormal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif


				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,"#include <normal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];o&&i.push(o.code,o.result?"displaced_position = "+o.result+";":""),i.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),i.push("	#include <project_vertex>","	#include <clipping_planes_vertex>","	vViewPosition = - mvPosition.xyz;","	#include <worldpos_vertex>","	#include <shadowmap_vertex>","	#include <fog_vertex>"),i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),t=i.join(`
`)}else{e.mergeUniform({penumbraSize:this.penumbraSize}),this.color===void 0&&(this.color=new Ie(5855577)),this.color.analyze(e,{slot:"color"}),this.specular.analyze(e),this.shininess.analyze(e),this.shadingAlpha.analyze(e),this.shadingBlend.analyze(e),this.afterColor&&this.afterColor.analyze(e,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(e);let o=this.color.flow(e,"c",{slot:"color"}),i=this.specular.flow(e,"c"),s=this.shininess.flow(e,"f"),a=this.shadingAlpha.flow(e,"f"),l=this.shadingBlend.flow(e,"i"),c=this.afterColor?this.afterColor.flow(e,"c",{slot:"afterColor"}):void 0,u=this.alpha?this.alpha.flow(e,"f"):void 0;e.requires.transparent=u!==void 0,e.addParsCode(["varying vec3 vWPosition;","uniform vec3 emissive;",`uniform float penumbraSize[${5}];`,"#include <normal_pars_fragment>","#include <fog_pars_fragment>","#include <bsdfs>","#include <lights_pars_begin>","#include <lights_phong_pars_fragment>","#include <shadowmap_pars_fragment>","#include <dithering_pars_fragment>"].join(`
`));let m=["#include <normal_fragment_begin>",`
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,"	BlinnPhongMaterial material;"];m.push(o.code,"	vec3 diffuseColor = "+o.result+";","	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );","	vec3 totalEmissiveRadiance = emissive;",i.code,"	vec3 specular = "+i.result+";",s.code,"	float shininess = max( 0.0001, "+s.result+" );","	float specularStrength = 1.0;"),u&&m.push(u.code,"#ifdef ALPHATEST","if ( "+u.result+" <= ALPHATEST ) discard;","#endif"),m.push("material.diffuseColor = diffuseColor;"),m.push("material.specularColor = specular;","material.specularShininess = shininess;","material.specularStrength = specularStrength;","#include <lights_fragment_begin>","#include <lights_fragment_end>"),m.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;"),m.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result}, ${l.result} );
				}
				`),c&&m.push(c.code,`outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`),u?m.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${u.result} );`):m.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),m.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),t=m.join(`
`)}return t}};var bn=require("three");var di=class extends st{constructor(){super("standard");this.nodeType="Standard";this.color=new Ie(5855577),this.roughness=new W(.3),this.metalness=new W(0),this.reflectivity=new W(.5),this.penumbraSize=new ot(5,.5),this.shadingAlpha=new W(1),this.shadingBlend=new ge(0)}build(e){let t;if(e.define("STANDARD"),e.requires.lights=!0,e.extensions.derivatives=!0,e.extensions.shaderTextureLOD=!0,e.isShader("vertex")){let o=this.position?this.position.analyzeAndFlow(e,"v3",{cache:"position"}):void 0;e.mergeUniform(bn.UniformsUtils.merge([bn.UniformsLib.fog,bn.UniformsLib.lights])),bn.UniformsLib.LTC_1&&(e.uniforms.ltc_1={value:void 0},e.uniforms.ltc_2={value:void 0}),e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join(`
`));let i=["#include <beginnormal_vertex>",`
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,"#include <normal_vertex>",`
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];o&&i.push(o.code,o.result?"displaced_position = "+o.result+";":""),i.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),i.push("#include <project_vertex>","#include <fog_vertex>","#include <clipping_planes_vertex>","	vViewPosition = - mvPosition.xyz;","#include <worldpos_vertex>","#include <shadowmap_vertex>"),i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),t=i.join(`
`)}else{e.mergeUniform({penumbraSize:this.penumbraSize});let o={gamma:!0};this.color===void 0&&(this.color=new Ie(5855577)),this.color.analyze(e,{slot:"color",context:o}),this.roughness.analyze(e),this.metalness.analyze(e),this.shadingAlpha.analyze(e),this.shadingBlend.analyze(e),this.afterColor&&this.afterColor.analyze(e,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(e),this.reflectivity&&this.reflectivity.analyze(e);let i=this.color.flow(e,"c",{slot:"color",context:o}),s=this.roughness.flow(e,"f"),a=this.metalness.flow(e,"f"),l=this.shadingAlpha.flow(e,"f"),c=this.shadingBlend.flow(e,"i"),u=this.afterColor?this.afterColor.flow(e,"c",{slot:"afterColor"}):void 0,m=this.alpha?this.alpha.flow(e,"f"):void 0,p=this.reflectivity?this.reflectivity.flow(e,"f"):void 0;e.requires.transparent=m!==void 0,e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;",`uniform float penumbraSize[${5}];`,"#include <normal_pars_fragment>","#include <dithering_pars_fragment>","#include <fog_pars_fragment>","#include <bsdfs>","#include <lights_pars_begin>","#include <lights_physical_pars_fragment>","#include <shadowmap_pars_fragment>"].join(`
`));let d=["#include <clipping_planes_fragment>","	#include <normal_fragment_begin>",`
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,"	PhysicalMaterial material;","	material.diffuseColor = vec3( 1.0 );"];d.push(i.code,"	vec3 diffuseColor = "+i.result+";","	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",s.code,"	float roughnessFactor = "+s.result+";",a.code,"	float metalnessFactor = "+a.result+";"),m&&d.push(m.code,"#ifdef ALPHATEST","	if ( "+m.result+" <= ALPHATEST ) discard;","#endif"),d.push("vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"),d.push("material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );","material.roughness = max( roughnessFactor, 0.0525 );","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"),p?d.push(p.code,"material.specularColor = mix( vec3( 0.16 * pow2( "+p.result+" ) ), diffuseColor, metalnessFactor );"):d.push("material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"),d.push("#include <lights_fragment_begin>"),d.push("#include <lights_fragment_end>"),d.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;"),d.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result}, ${c.result} );
				}
				`),u&&d.push(u.code,`outgoingLight = spe_blend(outgoingLight, ${u.result}, 1.0, SPE_BLENDING_NORMAL);`),m?d.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${m.result} );`):d.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),d.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),t=d.join(`
`)}return t}};var fi=require("three");var hi=class extends st{constructor(){super("toon");this.nodeType="Toon";this.color=new Ie(5855577),this.specular=new Ie(1118481),this.shininess=new W(30),this.penumbraSize=new ot(5,.5),this.shadingAlpha=new W(1),this.shadingBlend=new ge(0)}build(e){let t;if(e.define("TOON"),e.requires.lights=!0,e.extensions.derivatives=!0,e.isShader("vertex")){let o=this.position?this.position.analyzeAndFlow(e,"v3",{cache:"position"}):void 0;e.mergeUniform(fi.UniformsUtils.merge([fi.UniformsLib.fog,fi.UniformsLib.lights])),e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join(`
`));let i=["#include <beginnormal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,"#include <normal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];o&&i.push(o.code,o.result?"displaced_position = "+o.result+";":""),i.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),i.push("	#include <project_vertex>","	#include <fog_vertex>","	#include <clipping_planes_vertex>","	vViewPosition = - mvPosition.xyz;","	#include <worldpos_vertex>","	#include <shadowmap_vertex>","	#include <fog_vertex>"),i.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),t=i.join(`
`)}else{e.mergeUniform({penumbraSize:this.penumbraSize}),this.color===void 0&&(this.color=new Ie(5855577)),this.color.analyze(e,{slot:"color"}),this.specular.analyze(e),this.shininess.analyze(e),this.shadingAlpha.analyze(e),this.shadingBlend.analyze(e),this.afterColor&&this.afterColor.analyze(e,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(e);let o=this.color.flow(e,"c",{slot:"color"}),i=this.specular.flow(e,"c"),s=this.shininess.flow(e,"f"),a=this.shadingAlpha.flow(e,"f"),l=this.shadingBlend.flow(e,"i"),c=this.afterColor?this.afterColor.flow(e,"c",{slot:"afterColor"}):void 0,u=this.alpha?this.alpha.flow(e,"f"):void 0;e.requires.transparent=u!==void 0,e.addParsCode([`uniform float penumbraSize[${5}];`,"varying vec3 vWPosition;","#include <normal_pars_fragment>","#include <gradientmap_pars_fragment>","#include <fog_pars_fragment>","#include <bsdfs>","#include <lights_pars_begin>","#include <dithering_pars_fragment>",`
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`,"#include <shadowmap_pars_fragment>","#include <bumpmap_pars_fragment>","#include <normalmap_pars_fragment>"].join(`
`));let m=["#include <normal_fragment_begin>",`
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,"	ToonMaterial material;"];m.push(o.code,"	vec3 diffuseColor = "+o.result+";","	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",i.code,"	vec3 specular = "+i.result+";",s.code,"	float shininess = max( 0.0001, "+s.result+" );","	float specularStrength = 1.0;"),u&&m.push(u.code,"#ifdef ALPHATEST","if ( "+u.result+" <= ALPHATEST ) discard;","#endif"),m.push("material.diffuseColor = diffuseColor;"),m.push("material.specularColor = specular;","material.specularShininess = shininess;","material.specularStrength = specularStrength;","#include <lights_fragment_begin>","#include <lights_fragment_end>"),m.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;"),m.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result}, ${l.result} );
				}
				`),c&&m.push(c.code,`outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`),u?m.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${u.result} );`):m.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),m.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),t=m.join(`
`)}return t}};var to=class extends Ae{constructor(e){super("b");this.nodeType="Bool";this.value=e??!1}generateReadonly(e,t,o,i){return e.format(this.value?"true":"false",i,t)}};var pd=require("three");var Sn=class extends Ae{constructor(e){super("m3");this.nodeType="Matrix3";this.value=e??new pd.Matrix3}generateReadonly(e,t,o,i,s,a){return e.format("mat3("+this.value.elements.join(", ")+")",i,t)}get elements(){return this.value.elements}set elements(e){this.value.fromArray(e)}};var El=require("three");var Jt=class extends Ae{constructor(e=1,t){super("v4[]");this.nodeType="Vector4Array";this.size=e,this.value=Array.isArray(t)?t:t instanceof El.Vector4?new Array(e).fill(t):new Array(e).fill(new El.Vector4(0))}};var gi=(i=>(i.SIMPLEX="simplex3d",i.SIMPLEX_FRACTAL="simplex3dFractal",i.ASHIMA="simplexAshima",i.FBM="fbm",i.PERLIN="perlin",i))(gi||{}),ht=function(){let r=new Y(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`),e=new Y(`float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`,[r]);e.keywords.F3=new we("float F3 0.3333333"),e.keywords.G3=new we("float G3 0.1666667");let t=new Y(`float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`,[e]),o=new Y("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"),i=new Y("vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"),s=new Y(`float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`,[o,i]),a=new Y("vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"),l=new Y("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}",[a]),c=new Y(`float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`,[l]),u=new Y(`float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`,[c]);u.keywords.NUM_OCTAVES=new we(`int NUM_OCTAVES ${5}`);let m=new Y("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"),p=new Y(`float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`,[o,i,m]);return{simplex:e,simplexFractal:t,simplexAshima:s,fbm:u,perlin:p}}();var yi=class extends le{constructor(e,t,o,i,s,a,l,c,u,m,p,d){super("v3");this.nodeType="Noise";this.scale=e,this.size=t,this.move=o,this.fA=i,this.fB=s,this.distortion=a,this.colorA=l,this.colorB=c,this.colorC=u,this.colorD=m,this.alpha=p,this.noiseType=d,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t,o,i,s){e.require("uv"),e.requires.uv=[!0],e.addFragmentVariable(this.calpha,"float");let a=Object.values(gi)[this.noiseType.value],l=new Y(`vec3 ${a}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, float alpha, out float calpha) {
                vec3 st = position / size;
				st /= scale;
				vec3 q = vec3(${a}(st),
							  ${a}(st + vec3(1.0)),
							  ${a}(st + vec3(1.0)));
				vec3 r = vec3(${a}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
							  ${a}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
							  ${a}(st * q));
				float f = ${a}(st + r);
				vec4 color;
				color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
				color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
				color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));

                float lalpha = alpha * color.a;
                calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			    accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return clamp(color, 0.0, 1.0).rgb;
			}`,[ht.simplex,ht.simplexFractal,ht.simplexAshima,ht.fbm,ht.perlin]),c=e.include(l),u=[];return u.push(this.scale.build(e,"f")),u.push(this.size.build(e,"v3")),u.push(this.move.build(e,"f")),u.push(this.fA.build(e,"v2")),u.push(this.fB.build(e,"v2")),u.push(this.distortion.build(e,"v2")),u.push(this.colorA.build(e,"v4")),u.push(this.colorB.build(e,"v4")),u.push(this.colorC.build(e,"v4")),u.push(this.colorD.build(e,"v4")),u.push(this.alpha.build(e,"f")),u.push(this.calpha),e.format(c+"("+u.join(",")+")",this.getType(e),t)}};yi.numOctaves=5;var Bl=class extends le{constructor(e,t,o,i,s,a,l){super("v3");this.nodeType="Fresnel";this.color=e,this.bias=t,this.scale=o,this.intensity=i,this.factor=s,this.alpha=a,this.mode=l,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.require("vWorldViewDir"),e.require("worldNormal"),e.isShader("fragment")){e.addFragmentVariable(this.calpha,"float");let o=e.include(Bl.Nodes.fresnel),i=[];return i.push(this.color.build(e,"c")),i.push(this.bias.build(e,"f")),i.push(this.scale.build(e,"f")),i.push(this.intensity.build(e,"f")),i.push(this.factor.build(e,"f")),i.push(this.alpha.build(e,"f")),i.push(this.mode.build(e,"i")),i.push(this.calpha),e.format(o+"("+i.join(",")+")",this.getType(e),t)}else return console.warn("FresnelNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},xi=Bl;xi.Nodes=function(){return{fresnel:new Y(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, float alpha, int mode, out float calpha) {
				float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

				float lalpha = clamp( fresnel, 0.0, 1.0 ) * alpha;
				calpha = lalpha / clamp(lalpha + accumAlpha, 0.001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;
				return color;
			}`)}}();var Gl=class extends le{constructor(e,t,o,i,s,a,l){super("v3");this.nodeType="Rainbow";this.filmThickness=e,this.movement=t,this.wavelengths=o,this.noiseStrength=i,this.noiseScale=s,this.offset=a,this.alpha=l,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.require("vWorldViewDir"),e.require("worldNormal"),e.isShader("fragment")){e.require("uv"),e.requires.uv=[!0],e.addFragmentVariable(this.calpha,"float");let o=e.include(Gl.Nodes.rainbow),i=[];return i.push(this.filmThickness.build(e,"f")),i.push(this.movement.build(e,"f")),i.push(this.wavelengths.build(e,"v3")),i.push(this.noiseStrength.build(e,"f")),i.push(this.noiseScale.build(e,"f")),i.push(this.offset.build(e,"v3")),i.push(this.alpha.build(e,"f")),i.push(this.calpha),e.format(o+"("+i.join(",")+")",this.getType(e),t)}else return console.warn("RainbowNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},vi=Gl;vi.Nodes=function(){let e=new Y(`vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`,[ht.simplex]);return{rainbow:new Y(`vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, float alpha, out float calpha) {
                 vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

                 float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);
                 float lalpha = alpha * rainbowContribution;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

                 return res;
             }`,[e])}}();var Rl=class extends le{constructor(e,t,o,i,s,a,l,c,u,m,p,d,f,g,x,y){super("v3");this.nodeType="Outline";this.firstTime=!0,this.outlineColor=e,this.contourColor=t,this.outlineWidth=o,this.contourWidth=i,this.contourThreshold=s,this.outlineThreshold=a,this.contourFrequency=l,this.outlineSmoothing=c,this.contourDirection=u,this.positionalLines=m,this.compensation=p,this.resolution=d,this.normalMap=f,this.depthMap=g,this.pixelRatio=x,this.alpha=y,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.require("vWorldViewDir"),e.require("worldNormal"),e.extensions.derivatives=!0,this.firstTime){let o=this.outlineWidth.build(e,"f"),i=this.resolution.build(e,"v2"),s=this.compensation.build(e,"b"),a=this.pixelRatio.build(e,"f");e.addVertexParsVariable("randomColor","attribute vec3"),e.addVertexParsVariable("extrudeNormal","attribute vec3"),e.addVertexParsVariable(o,"uniform float"),e.addVertexParsVariable(i,"uniform vec2"),e.addVertexParsVariable(s,"uniform bool"),e.addVertexParsVariable(a,"uniform float"),e.addVertexParsVariable("vID","flat out float"),e.addFragmentParsVariable("vID","flat in float");let l=`g${this.uuid.toString().replace(/-/g,"")}`;e.addVertexFinalCode(`
                vID = randomColor.r;
                if (${s}) {
                    vec4 ${l}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
                    vec3 ${l}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal);
                    vec2 ${l}_offset = normalize(${l}_clipNormal.xy) / ${i} * (${o} / 2.0) * ${l}_clipPosition.w * 2.0 * ${a};
                    ${l}_clipPosition.xy += ${l}_offset;
                    // TODO(MAX): To handle multiple outline layers, we only want to extrude
                    // if this offset is the biggest of all the potential offsets
                    gl_Position = ${l}_clipPosition;
                }
            `)}if(e.isShader("fragment")){e.require("uv"),e.requires.uv=[!0],e.addFragmentVariable(this.calpha,"float");let o=e.include(Rl.Nodes.outline),i=[];return i.push(this.outlineColor.build(e,"c")),i.push(this.contourColor.build(e,"c")),i.push(this.outlineWidth.build(e,"f")),i.push(this.contourWidth.build(e,"f")),i.push(this.contourThreshold.build(e,"f")),i.push(this.outlineThreshold.build(e,"f")),i.push(this.contourFrequency.build(e,"f")),i.push(this.outlineSmoothing.build(e,"f")),i.push(this.contourDirection.build(e,"v3")),i.push(this.positionalLines.build(e,"b")),i.push(this.resolution.build(e,"v2")),i.push(this.normalMap.getTexture(e,"t")),i.push(this.depthMap.getTexture(e,"t")),i.push(this.pixelRatio.build(e,"f")),i.push(this.compensation.build(e,"b")),i.push(this.alpha.build(e,"f")),i.push(this.calpha),this.firstTime=!this.firstTime,e.format(o+"("+i.join(",")+")",this.getType(e),t)}else return console.warn("OutlineNode is not compatible with "+e.shader+" shader."),""}},bi=Rl;bi.Nodes=function(){let e=new Y(`
float sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)
{
    vec2 texelSize = (vec2(1.0) / resolution) * outlineWidth * pixelRatio;

    vec2 uvSamples[9];
    vec4 normalSamples[9];

	uvSamples[0] = uv + vec2( -texelSize.x, -texelSize.y);
	uvSamples[1] = uv + vec2(0.0, -texelSize.y);
	uvSamples[2] = uv + vec2(  texelSize.x, -texelSize.y);
	uvSamples[3] = uv + vec2( -texelSize.x, 0.0);
	uvSamples[4] = uv;
	uvSamples[5] = uv + vec2(  texelSize.x, 0.0);
	uvSamples[6] = uv + vec2( -texelSize.x, texelSize.y);
	uvSamples[7] = uv + vec2(0.0, texelSize.y);
	uvSamples[8] = uv + vec2(  texelSize.x, texelSize.y);


    normalSamples[0] = texture2D(t, uvSamples[0]);
    normalSamples[1] = texture2D(t, uvSamples[1]);
    normalSamples[2] = texture2D(t, uvSamples[2]);
    normalSamples[3] = texture2D(t, uvSamples[3]);
    normalSamples[4] = texture2D(t, uvSamples[4]);
    normalSamples[5] = texture2D(t, uvSamples[5]);
    normalSamples[6] = texture2D(t, uvSamples[6]);
    normalSamples[7] = texture2D(t, uvSamples[7]);
    normalSamples[8] = texture2D(t, uvSamples[8]);

    float depthBias = 0.0001;
    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!
    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }


    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    vec4 sobel_edge_h = normalSamples[2] + (2.0*normalSamples[5]) + normalSamples[8] - (normalSamples[0] + (2.0*normalSamples[3]) + normalSamples[6]);
  	vec4 sobel_edge_v = normalSamples[0] + (2.0*normalSamples[1]) + normalSamples[2] - (normalSamples[6] + (2.0*normalSamples[7]) + normalSamples[8]);

    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));
    return edgeNormal;
}
`);return{outline:new Y(`vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float alpha, out float calpha) {
                vec3 result = outlineColor;
                float resultAlpha = 0.0;

                vec3 N = normalize(vWNormal);
                vec2 nuv = (gl_FragCoord.xy / resolution);
                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);
                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);

                float t = 1.0 - contourThreshold;
                if(positionalLines) {
                    vec3 NDir = position * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float f  = fract(NT * contourFrequency * 0.01);
                    float df = fwidth(NT * contourFrequency);

                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);
                    if (g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0;
                    }
                 }
                 else {
                    vec3 NDir = N * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float df = fwidth(NT * contourThreshold);
                    float f = sin(NT * 1.0 * contourFrequency);
                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);

                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0 - g;
                    }
                 }

                 float lalpha = alpha * resultAlpha;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
                 return result;
             }`,[e])}}();var zl=class extends le{constructor(e,t,o,i,s,a,l,c){super("v3");this.nodeType="Transmission";this.thickness=e,this.ior=t,this.roughness=o,this.transmissionSamplerSize=i,this.transmissionSamplerMap=s,this.transmissionDepthMap=a,this.aspectRatio=l,this.alpha=c,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.extensions.shaderTextureLOD=!0,e.extensions.derivatives=!0,e.isShader("fragment")){e.define("NUM_SAMPLES",30),e.require("worldPosition"),e.requires.worldNormal=!0,e.requires.modelMatrix=!0,e.requires.projectionMatrix=!0,e.addFragmentVariable(this.calpha,"float");let o=e.include(zl.Nodes.transmission),i=[];return i.push(this.thickness.build(e,"f")),i.push(this.ior.build(e,"f")),i.push(this.roughness.build(e,"f")),i.push(this.transmissionSamplerSize.build(e,"v2")),i.push(this.transmissionSamplerMap.getTexture(e,"t")),i.push(this.transmissionDepthMap.getTexture(e,"t")),i.push(this.aspectRatio.build(e,"v2")),i.push("normal"),i.push(this.alpha.build(e,"f")),i.push(this.calpha),e.format(o+"("+i.join(",")+")",this.getType(e),t)}else return console.warn("TransmissionNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},Si=zl;Si.Nodes=function(){let e=new Y(`
            float gaussian(vec2 i) {
                const float sigma = float(NUM_SAMPLES) * .25;
                return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );
            }`),t=new Y(`
            vec4 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

                const int LOD = 2;
                const int sLOD = 4; // tile size = 2^LOD

                vec4 O = vec4(0);
                const int s = NUM_SAMPLES/sLOD;
                for ( int i = 0; i < s*s; i++ ) {
                    int modulo = (i)-((i)/(s))*(s);
                    vec2 d = vec2(float(modulo), float(i/s))*float(sLOD) - float(NUM_SAMPLES)/2.;
                    vec2 uv = U + (scale * aspectRatio) * d;
                    // What is the depth of the opaque object we're trying to sample
                    float opaqueDepth = texture2D(dm, uv).r;
                    if (opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU + ((scale * min(lod / 2., 1.)) * aspectRatio) * d;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
		            #ifdef TEXTURE_LOD_EXT
                    O += gaussian(d) * texture2DLodEXT( sp, uv, lod);
                    #else
                    O += gaussian(d) * textureLod( sp, uv, lod);
                    #endif
                }
                return O / O.a;
            }`,[e]),o=new Y(`
            vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        // Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		        // The thickness is specified in local space.
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`),i=new Y(`
float applyIorToRoughness( float roughness, float ior ) {
		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	} `),s=new Y(`
vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
        float lod = applyIorToRoughness(roughness, ior);

        return blur(transmissionSamplerMap, fragCoord, vec2(lod / (transmissionSamplerSize.x / 2.)), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
	}`,[i,t]),a=new Y(`
vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
        vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
        vec3 refractedRayExit = position + transmissionRay;

        // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
        vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
        vec2 refractionCoords = ndcPos.xy / ndcPos.w;
        refractionCoords += 1.0;
        refractionCoords /= 2.0;

        vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
        vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
        unrefractedCoords += 1.0;
        unrefractedCoords /= 2.0;

        // Sample framebuffer to get pixel the refracted ray hits.
        vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
        // Get the specular component.
        return vec4( ( 1.0 ) * transmittedLight.rgb, transmittedLight.a );
    }`,[s,o]);return{transmission:new Y(`
            vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec4 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                float lalpha = alpha;

                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
                 return transmission.rgb;
            }`,[a])}}();var wn=class extends le{constructor(e,t,o,i,s,a,l,c,u,m,p,d){super("v3");this.nodeType="Depth";this.gradientType=e,this.smooth=t,this.near=o,this.far=i,this.isVector=s,this.isWorldSpace=a,this.origin=l,this.direction=c,this.colors=u,this.steps=m,this.num=p,this.alpha=d,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){let o=`g${this.uuid.toString().replace(/-/g,"")}`,i=new Y(`vec3 ${o}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${o}_MAX_COLORS], float steps[${o}_MAX_COLORS], float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${o}_IS_VECTOR
                   #ifdef ${o}_LINEAR
                       #ifdef ${o}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${o}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${o}_SMOOTH
				for ( int i = 1; i < ${o}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${o}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a;
               calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			   accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
               return color.rgb;
			}`,[wn.Nodes.vectorLinearWorldSpaceDepth,wn.Nodes.vectorLinearObjectSpaceDepth,wn.Nodes.vectorSphericalObjectSpaceDepth,wn.Nodes.vectorSphericalWorldSpaceDepth]);if(e.isShader("fragment")){e.define(`${o}_MAX_COLORS`,this.num.value+1),this.smooth.value&&e.define(`${o}_SMOOTH`),this.isVector.value>.5&&e.define(`${o}_IS_VECTOR`),this.gradientType.value===0&&e.define(`${o}_LINEAR`),this.isWorldSpace.value>.5&&e.define(`${o}_WORLDSPACE`),e.require("worldPosition"),e.addFragmentVariable(this.calpha,"float");let s=e.include(i),a=[];return a.push(this.near.build(e,"f")),a.push(this.far.build(e,"f")),a.push(this.origin.build(e,"v3")),a.push(this.direction.build(e,"v3")),a.push(this.colors.build(e,"v4[]")),a.push(this.steps.build(e,"f[]")),a.push(this.alpha.build(e,"f")),a.push(this.calpha),e.format(s+"("+a.join(",")+")",this.getType(e),t)}else return console.warn("DepthNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},wi=wn;wi.Nodes=function(){let e=new Y(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),t=new Y(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),o=new Y(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`),i=new Y(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`);return{vectorLinearWorldSpaceDepth:e,vectorLinearObjectSpaceDepth:t,vectorSphericalWorldSpaceDepth:o,vectorSphericalObjectSpaceDepth:i}}();var Ti=class extends le{constructor(e,t,o,i){super("v3");this.nodeType="Blend";this.a=e,this.b=t,this.alpha=o,this.mode=i}generate(e,t){if(e.isShader("fragment")){let o=[];return o.push(this.a.build(e,"c")),o.push(this.b.build(e,"c")),o.push(this.alpha.build(e,"f")),o.push(this.mode.build(e,"i")),e.format("spe_blend("+o.join(",")+")",this.getType(e),t)}else return console.warn("BlendNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}};var Vl=(e=>(e.NOISE="noise",e.MAP="map",e))(Vl||{}),Fl=class extends le{constructor(e=new ge(0),t,o,i,s,a){super("v3");this.nodeType="VertexDisplacement";this.displacementTypeIndex=e,this.intensity=t,this.movementOrTexture=o,Object.values(Vl)[this.displacementTypeIndex.value]==="map"&&(this.mat=new Sn(this.movementOrTexture.value.matrix)),this.cropOrOffset=i,this.scale=s,this.noiseFunctionIndex=a}generate(e,t){if(e.isShader("vertex")){e.define("USE_LAYER_DISPLACE");let o,i=[];switch(i.push("displaced_position"),i.push("displaced_normal"),Object.values(Vl)[this.displacementTypeIndex.value]){case"map":{o=e.include(Fl.Nodes.map),i.push(this.movementOrTexture.getTexture(e,"t")),i.push("uv"),i.push(this.cropOrOffset.build(e,"f")),this.mat&&i.push(this.mat.build(e,"mat3"));break}case"noise":{let a=Object.values(gi)[this.noiseFunctionIndex.value],l=new Y(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`),c=new Y(`vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement) {
							return p + n * ${a}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
						}`,[ht.simplex,ht.simplexFractal,ht.simplexAshima,ht.fbm,ht.perlin]),u=new Y(`vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`,[c,l]);o=e.include(u),i.push(this.scale.build(e,"f")),i.push(this.cropOrOffset.build(e,"v3")),i.push(this.movementOrTexture.build(e,"f"));break}}return i.push(this.intensity.build(e,"f")),i.push("displaced_normal"),e.format(o+"("+i.join(",")+")",this.getType(e),t)}else return console.warn("VertexDisplacementNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},Tn=Fl;Tn.Nodes=function(){let e=new Y(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`),t=new Y(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`);return{map:new Y(`vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`,[e,t])}}();var Ul=class extends le{constructor(e,t,o,i,s,a,l,c){super("v3");this.nodeType="Gradient";this.gradientType=e,this.smooth=t,this.colors=o,this.steps=i,this.offset=s,this.morph=a,this.angle=l,this.alpha=c,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.isShader("fragment")){e.define("GRAD_MAX",10),e.require("uv"),e.requires.uv=[!0],e.addFragmentVariable(this.calpha,"float");let o=e.include(Ul.Nodes.gradient),i=[];return i.push(this.gradientType.build(e,"i")),i.push(this.smooth.build(e,"b")),i.push(this.colors.build(e,"v4[]")),i.push(this.steps.build(e,"f[]")),i.push(this.offset.build(e,"v2")),i.push(this.morph.build(e,"v2")),i.push(this.angle.build(e,"f")),i.push(this.alpha.build(e,"f")),i.push(this.calpha),e.format(o+"("+i.join(",")+")",this.getType(e),t)}else return console.warn("GradientNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},Ni=Ul;Ni.Nodes=function(){return{gradient:new Y(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return color.xyz;
			}`)}}();var Li=class extends le{constructor(e,t,o,i,s,a,l,c,u,m){super("v3");this.nodeType="CustomTexture";this.firstTime=!0,this.texture=e,this.textureSize=t,this.crop=o,this.projection=i,this.axis=s,this.side=a,this.size=l,this.mat=c,this.alpha=u,this.mode=m,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){e.require("position"),e.require("normal"),e.require("uv"),e.requires.uv=[!0],e.extensions.shaderTextureLOD=!0,e.extensions.derivatives=!0;let o=`g${this.uuid.toString().replace(/-/g,"")}`,i;switch(this.projection.value){case 3:i=e.include(Li.Nodes.cylindrical);break;case 2:i=e.include(Li.Nodes.spherical);break;case 1:let a=["vec3(1.0, 0.0, 0.0)","vec3(0.0, 1.0, 0.0)","vec3(0.0, 0.0, 1.0)"][this.axis.value],l=new Y(`
		vec3 ${o}_planarTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( (${o}_vCustomUv * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${this.side.value===2?"":`lalpha *= step(0.0, ${this.side.value===1?"-1.0 * ":""}dot(vObjectNormal, mat * ${a}));`}

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);i=e.include(l);break;default:i=e.include(Li.Nodes.uv);break}if(this.projection.value===1&&this.firstTime){e.addVertexParsCode(`varying vec2 ${o}_vCustomUv;`),e.addFragmentParsCode(`varying vec2 ${o}_vCustomUv;`);let a=["zy","xz","xy"][this.axis.value];e.addVertexFinalCode(`${o}_vCustomUv = (1. + (transformed.${a})) / 2.;`)}e.addFragmentVariable(this.calpha,"float");let s=[];return s.push(this.texture.generate(e,"t")),s.push(this.textureSize.build(e,"v2")),s.push(this.crop.build(e,"f")),s.push(this.mat.build(e,"mat3")),s.push(this.size.build(e,"v2")),s.push(this.alpha.build(e,"f")),s.push(this.mode.build(e,"i")),s.push(this.calpha),this.firstTime=!this.firstTime,e.format(i+"("+s.join(",")+")",this.getType(e),t)}},Ci=Li;Ci.Nodes=function(){let e=new Y(`
vec3 cylindricalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`),t=new Y(`
vec3 sphericalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`),o=new Y(`vec3 uvTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);return{cylindrical:e,spherical:t,uv:o}}();var jl=class extends le{constructor(e,t){super("v3");this.nodeType="CustomNormal";this.cnormal=e,this.alpha=t}generate(e,t){if(e.isShader("fragment")){let o=e.include(jl.Nodes.customNormal),i=[];return i.push(this.cnormal.build(e,"v3")),i.push("normal"),i.push(this.alpha.build(e,"f")),e.format(o+"("+i.join(",")+")",this.getType(e),t)}else return console.warn("CustomNormalNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},Ii=jl;Ii.Nodes=function(){return{customNormal:new Y(`vec3 customNormal(vec3 cnormal, vec3 norm, float alpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return normal;
			}`)}}();var Ee=require("three");function md(n,r){switch(n.type){case"fresnel":return ib(n,r);case"gradient":return sb(n);case"depth":return ab(n);case"normal":return lb(n);case"noise":return cb(n,r);case"rainbow":return ub(n);case"toon":return pb(n,r);case"outline":return mb(n,r);case"transmission":return db(n,r);case"displace":return fb(n);case"color":return nb(n,r)}}function dd(n){return{type:n.type}}function br(n){let{alpha:r,mode:e}=n;return{...dd(n),alpha:r,mode:e}}function nb(n,r){return{...br(n),color:Ke(n.color,r)}}function ib(n,r){let{bias:e,scale:t,intensity:o,factor:i,color:s}=n;return{...br(n),color:Ke(s,r),bias:e,scale:t,intensity:o,factor:i}}function sb(n){let{gradientType:r,smooth:e,colors:t,steps:o,angle:i,offset:s,morph:a}=n;return{...br(n),gradientType:r,smooth:e,colors:t.map(l=>new Ee.Vector4(l[0],l[1],l[2],l[3])),num:t.length,steps:o,offset:new Ee.Vector2(...s),morph:new Ee.Vector2(...a),angle:i}}function ab(n){let{gradientType:r,near:e,far:t,isVector:o,isWorldSpace:i,origin:s,direction:a,colors:l,steps:c,smooth:u,num:m}=n;return{...br(n),gradientType:r,near:e,far:t,isVector:o,isWorldSpace:i,origin:new Ee.Vector3(...s),direction:a?new Ee.Vector3(...a):new Ee.Vector3(1,0,0),num:m,colors:l.map(p=>new Ee.Vector4(p[0],p[1],p[2],p[3])),steps:c,smooth:u}}function lb(n){let{cnormal:r}=n;return{...br(n),cnormal:new Ee.Vector3(r[0],r[1],r[2])}}function cb(n,r){return{...br(n),scale:n.scale,move:n.move,fA:new Ee.Vector2(...n.fA),fB:new Ee.Vector2(...n.fB),size:new Ee.Vector3(...n.size),distortion:new Ee.Vector2(...n.distortion),colorA:Ke(n.colorA,r),colorB:Ke(n.colorB,r),colorC:Ke(n.colorC,r),colorD:Ke(n.colorD,r),noiseType:n.noiseType}}function ub(n){return{...br(n),filmThickness:n.filmThickness,movement:n.movement,wavelengths:new Ee.Vector3(...n.wavelengths),noiseStrength:n.noiseStrength,noiseScale:n.noiseScale,offset:new Ee.Vector3(...n.offset)}}function pb(n,r){return{...br(n),positioning:n.positioning,colors:n.colors.map(e=>new Ee.Vector4(e[0],e[1],e[2],e[3])),num:n.colors.length,steps:n.steps,source:new Ee.Vector3(...n.source),isWorldSpace:n.isWorldSpace,noiseStrength:n.noiseStrength,noiseScale:n.noiseScale,shadowColor:Ke(n.shadowColor,r),offset:new Ee.Vector3(...n.offset)}}function mb(n,r){return{...br(n),outlineColor:Ke(n.outlineColor,r),contourColor:Ke(n.contourColor,r),outlineWidth:n.outlineWidth,contourWidth:n.contourWidth,outlineThreshold:n.outlineThreshold,contourThreshold:n.contourThreshold,outlineSmoothing:n.outlineSmoothing,contourFrequency:n.contourFrequency,contourDirection:n.contourDirection,positionalLines:n.positionalLines,compensation:n.compensation,resolution:r.resolutionNode,normalMap:r.normalMap,depthMap:r.normalRenderTarget.depthTexture,pixelRatio:r.pixelRatioNode}}function db(n,r){return{...br(n),thickness:n.thickness,ior:n.ior,roughness:n.roughness,transmissionSamplerMap:r.transmissionSamplerMap,transmissionDepthMap:r.transmissionDepthMap}}function fb(n){let r={...dd(n),intensity:n.intensity};if(n.displacementType==="noise")return{...r,offset:new Ee.Vector3(...n.offset),scale:n.scale,movement:n.movement,noiseType:n.noiseType};{let e=new Ee.Texture,t=new Ee.Matrix3().setUvTransform(0,0,1,1,0,0,0);return{...r,texture:e,mat:t,crop:n.crop}}}var ro=class extends ut{};var gd=require("three");var kl=new Map,Pi={url:"head",time:0,data:null,next:null,prev:null},Nn={url:"tail",time:1/0,data:null,next:null,prev:null};Pi.next=Nn;Nn.prev=Pi;var fd=0;function hd(n){if(typeof n=="string")return n;let r=Date.now(),e=kl.get(n);return e===void 0?(e={url:URL.createObjectURL(new Blob([n])),data:n,time:r,next:null,prev:null},kl.set(n,e)):(e.time=r,e.prev.next=e.next,e.next.prev=e.prev),e.prev=Nn.prev,e.next=Nn,Nn.prev.next=e,Nn.prev=e,r-fd>1e3*10&&(fd=r+1e3,setTimeout(()=>{let t=Date.now(),o=Pi.next;for(;o.time<t-1e3*10;)URL.revokeObjectURL(o.url),kl.delete(o.data),o=o.next,o.prev=Pi,Pi.next=o},900)),e.url}var Cn=class{constructor(r,e){this.data=r;this.onImageLoad=e;this.loaded=!1;this.updateSrc(r.data)}updateSrc(r){this.dispose(),this.loaded=!1,this.img=new Image,this.img.src=hd(r),this.img.onload=()=>{this.loaded=!0;let e=[1e3,1001,1002];for(let t of e){let o=this[t];o&&(o.image=this.img,o.needsUpdate=!0)}this.onImageLoad&&this.onImageLoad()}}getTexture(r){let e=this[r];if(e)return e;{let t=new gd.Texture(this.img,void 0,r,r);return this.loaded&&(t.needsUpdate=!0),this[r]=t,t}}dispose(){this[1e3]?.dispose(),this[1e3]=void 0,this[1001]?.dispose(),this[1001]=void 0,this[1002]?.dispose(),this[1002]=void 0}};1e3,1001,1002;var So=class extends Cn{};function hb(n,r){switch(n.type){case"noise":return r==="noiseType";case"texture":return r==="projection"||r==="axis"||r==="side";case"displace":return r==="noiseType";case"depth":return r==="num"||r==="smooth"||r==="isWorldSpace"||r==="gradientType"||r==="isVector";default:return!1}}function Hl(n,r,e,t){let o=e.uniforms[`f${e.id}_texture`];if(!o)return!1;let i=!1,s=n;if("image"in s){let a=s.image,l=r.image(a),c=o;c instanceof So||c.image.dispose(),c.image=l}if("wrapping"in s){let a=o;a.wrap=s.wrapping}if("repeat"in s||"offset"in s){let a="mat";e.uniforms[`f${e.id}_${a}`].value.setUvTransform(t.offset[0],t.offset[1],t.repeat[0],t.repeat[1],0,0,0)}return i}function yd(n,r,e,t){let o=!1;for(let[i,s]of Object.entries(n)){if(!i||s===void 0||Wl(i,e,t))continue;e.visible=t.visible;let a=e.uniforms[`f${e.id}_${i}`];if(!!a)switch(a.constructor){case Ie:if(typeof s=="string"){let l=r.getColor(s);l&&(a.value=l);break}else{let l=s;a.value instanceof ro?a.value=new ut(l.r,l.g,l.b,l.a):a.setRGBA(l);break}case Ht:if(typeof s=="string"){let l=r.getColor(s);l&&(a.value=l);break}else{let l=s;a.value instanceof ro?a.value=new ut(l.r,l.g,l.b,l.a):a.value.setRGBA(l.r,l.g,l.b,l.a);break}case rt:{let l=s;a.value.setX(l[0]),a.value.setY(l[1]);break}case pt:{let l=s;a.value.setX(l[0]),a.value.setY(l[1]),a.value.setZ(l[2]);break}case wt:{let l=s;Hl(l,r,e,l);break}case Jt:{s.forEach((l,c)=>{a.value[c].setX(l[0]),a.value[c].setY(l[1]),a.value[c].setZ(l[2]),a.value[c].setW(l[3])});break}default:{o=o||hb(e,i),a.value=s;break}}}return o}var ql=class extends le{constructor(e,t,o){super("v3");this.nodeType="Matcap";this.texture=e,this.alpha=t,this.mode=o,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.isShader("fragment")){e.addFragmentVariable(this.calpha,"float");let o=e.include(ql.Nodes.matcap);e.require("normal"),e.requires.normal=!0;let i=[];return i.push(this.texture.generate(e,"t")),i.push("normal"),i.push(this.alpha.build(e,"f")),i.push(this.mode.build(e,"i")),i.push(this.calpha),e.format(o+"("+i.join(",")+")",this.getType(e),t)}else return console.warn("MatcapNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},Ai=ql;Ai.Nodes=function(){return{matcap:new Y(`vec3 matcap(sampler2D matcapTex, vec3 normal, float alpha, int mode, out float calpha) {
                vec3 viewDir = normalize( vViewPosition );
                vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
                vec3 y = cross( viewDir, x );
                vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
                vec4 matcapColor = texture2D( matcapTex, uv );

                calpha =  alpha / clamp( alpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;
                
                return matcapColor.rgb;
            }
            `)}}();var Mi=class extends Ae{constructor(e,t){super("t");this.image=e;this.wrap=t}get value(){return this.image.getTexture(this.wrap)}};var xd=require("three");var da=class extends Ae{constructor(e){super("v3");this.image=e;this._value=new xd.Vector3}get value(){return this._value.x=this.image.img.width,this._value.y=this.image.img.height,this._value}};var $l=class extends le{constructor(e,t,o,i,s,a,l,c,u,m){super("v3");this.nodeType="Toon";this.positioning=e,this.colors=t,this.steps=o,this.source=i,this.isWorldSpace=s,this.noiseStrength=a,this.noiseScale=l,this.shadowColor=c,this.offset=u,this.alpha=m,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.require("worldNormal"),e.require("worldPosition"),e.isShader("fragment")){e.define("COLORS_MAX",10),e.addFragmentVariable(this.calpha,"float");let o=e.include($l.Nodes.toon),i=[];return i.push(this.positioning.build(e,"i")),i.push(this.colors.build(e,"v4[]")),i.push(this.steps.build(e,"f[]")),i.push(this.source.build(e,"v3")),i.push(this.isWorldSpace.build(e,"b")),i.push(this.noiseStrength.build(e,"f")),i.push(this.noiseScale.build(e,"f")),i.push(this.shadowColor.build(e,"v4")),i.push(this.offset.build(e,"v3")),i.push(this.alpha.build(e,"f")),i.push(this.calpha),e.format(o+"("+i.join(",")+")",this.getType(e),t)}else return console.warn("ToonNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},Oi=$l;Oi.Nodes=function(){let e=new Y(`float rand(float n) {
				return fract(sin(n) * 43758.5453123);
			}`),t=new Y(`float hash1(float p) { 
				p = fract(p * 0.011); 
				p *= p + 7.5; 
				p *= p + p; 
				return fract(p); 
			}`),o=new Y(`float valueNoise(vec3 x) {
				const vec3 step = vec3(110, 241, 171);
			
				vec3 i = floor(x);
				vec3 f = fract(x);
			 
				// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
				// incremental change to the 1D based on the 3D -> 1D wrapping
				float n = dot(i, step);
			
				vec3 u = f * f * (3.0 - 2.0 * f);
				return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
						   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
			}`,[t]),i=new Y(`vec3 hash3(vec3 x) {
				x = vec3(dot(x,vec3(127.1, 311.7, 74.7)),
						 dot(x,vec3(269.5, 183.3, 246.1)),
						 dot(x,vec3(113.5, 271.9, 124.6)));
			
				return fract(sin(x)*43758.5453123);
			}`),s=new Y(`vec3 voronoiNoise(in vec3 x)
			{
				vec3 p = floor(x);
				vec3 f = fract(x);

				float id = 0.0;
				vec2 res = vec2(100.0);

				for(int k=-1; k<=1; k++)
				for(int j=-1; j<=1; j++)
				for(int i=-1; i<=1; i++)
				{
					vec3 b = vec3(float(i), float(j), float(k));

					// Comment out the "+ hash(p + b);" part below to get "square" cells
					vec3 r = vec3(b) - f + hash3(p + b);
					float d = dot(r, r);

					if (d < res.x)
					{
						id = dot(p + b, vec3(1.0, 57.0, 113.0));
						res = vec2(d, res.x);			
					}
					else if (d < res.y)
					{
						res.y = d;
					}
				}

				return vec3(sqrt(res), abs(id));
			}
			`,[i]);return{toon:new Y(`vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float alpha, out float calpha) {
				float t = 0.0;
				float shadow = 1.0;

				if (positioning == 0) {

					// Can't do this mode if lighting is "none"
					#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))

						// Algorithm from Chapter 10 of Graphics Shaders
						const vec3 weights = vec3(0.2125, 0.7154, 0.0721);
						vec3 lpos;
						vec3 l;
						float dproduct;

						#if (NUM_POINT_LIGHTS > 0)

							#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)
								PointLightShadow pointLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
								// Light positions are in view-space for some reason?
								lpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								
								// TODO: we want to use "intensity" but it isn't available in the shader code
								//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);

								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
									pointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getPointShadow( 
											pointShadowMap[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowMapSize, 
											pointLightShadow.shadowBias, 
											pointLightShadow.shadowRadius,
											vPointShadowCoord[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowCameraNear, 
											pointLightShadow.shadowCameraFar);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_DIR_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)
								DirectionalLightShadow directionalLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
								// Use the direction vector for directional lights instead
								l = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;
		
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
									directionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow( 
										UNROLLED_LOOP_INDEX,
										directionalShadowMap[UNROLLED_LOOP_INDEX], 
										directionalLightShadow.shadowMapSize, 
										directionalLightShadow.shadowBias, 
										directionalLightShadow.shadowRadius, 
										vDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_SPOT_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)
								SpotLightShadow spotLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
								lpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
									spotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow(
										UNROLLED_LOOP_INDEX,
										spotShadowMap[UNROLLED_LOOP_INDEX], 
										spotLightShadow.shadowMapSize, 
										spotLightShadow.shadowBias, 
										spotLightShadow.shadowRadius, 
										vSpotShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						t = clamp(t, 0.0, 1.0);
				
					#endif

				} else if (positioning == 1) {
					
					vec3 origin = mix(position, worldPosition, float(isWorldSpace));
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	

				} else {

					vec3 origin = worldPosition;
					vec3 source = cameraPosition - offset;
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	
					
				}

				if (noiseStrength > 0.0) {
					// Distort with noise
					vec3 st = position / noiseScale;
					
					// Voronoi "smooth" noise
					float noise = 1.0 - voronoiNoise(st).x;

					// Voronoi cellular noise
					//float noise = 1.0 - rand(voronoiNoise(st).z);

					// Position warp noise
					// vec3 offset = vec3(
					// 	simplex3d(st),
					// 	simplex3d(st + vec3(111.1, 143.89, 217.19)),
					// 	simplex3d(st + vec3(171.1, 247.89, 117.23))
					// );
					// st += offset;
					// float noise = valueNoise(st);

					t += noise * noiseStrength;
				}

				t = clamp(t, 0.0, 1.0);

				// Compute ramp color
				float p;
				vec4 color = colors[0];
				for (int i = 1; i < COLORS_MAX; i++) {
					p = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);
					color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
				}

				// Incorporate custom shadow color
				if (positioning == 0) {

					vec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);
					color.rgb = mix(blendedShadow, color.rgb, shadow);
				
				}

				// Accumulate alpha as usual
				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color.xyz;

            }`,[ht.simplex,e,o,s])}}();var Sr=class{constructor(r,e,t,o){this.type=r;this.id=e;this.uuid=t;this.uniforms={};for(let i in o)this.uniforms[`f${this.id}_${i}`]=o[i]}static create(r,e,t,o){if(t.type==="light")return wr.createLigherLayer(r,e,t,o);if(t.type==="texture"){let i=o.image(t.texture.image),s=new Mi(i,t.texture.wrapping),a=new da(i),l=new be.Matrix3().setUvTransform(t.texture.offset[0],t.texture.offset[1],t.texture.repeat[0],t.texture.repeat[1],0,0,0),c=new Sn(l),u=new W(t.crop?1:0),m=new ge(t.projection??0),p=new ge(["x","y","z"].indexOf(t.axis)??0),d=new ge(t.side??0),f=new rt(t.size?new be.Vector2(t.size[0],t.size[1]):new be.Vector2(100,100)),g=new W(t.alpha??1),x=new ge(t.mode??0),y=new Ci(s,a,u,m,p,d,f,c,g,x),v=new Ne(y.calpha,"f");return new nt("texture",r,e,{texture:s,textureSize:a,crop:u,projection:m,axis:p,side:d,size:f,mat:c,alpha:g,mode:x},y,x,v)}else if(t.type==="matcap"){let i=o.image(t.texture.image),s=new Mi(i,t.texture.wrapping),a=new W(t.alpha??1),l=new ge(t.mode??0),c=new Ai(s,a,l),u=new Ne(c.calpha,"f");return new nt("matcap",r,e,{texture:s,alpha:a,mode:l},c,l,u)}else{let i=yb(r,e,t,o);for(let s in t)Wl(s,i,t);return i}}updateByOp(r,e,t){let o=r;if(o.path[0]===void 0){if(o.type===0)return"type"in o.props||"category"in o.props?!0:yd(o.props,t,this,e)}else if(o.path[0]==="texture")return"texture"in e?Hl(o.props,t,this,e.texture):!0;return!1}dispose(){}hasValueByKey(r){return this.uniforms[r]!==void 0}hasValue(r){return this.hasValueByKey(`f${this.id}_${r}`)}setValue(r,e){let t=`f${this.id}_${r}`;this.hasValueByKey(t)&&e!==void 0&&(this.uniforms[t].value=e)}getValue(r){let e=`f${this.id}_${r}`;if(this.hasValueByKey(e))return this.uniforms[e].value}getName(r){let t=/f\d+_(.*)/.exec(r);if(t&&t.length>1)return t[1];console.log(`Layer.getName: error ${r}`)}getNames(){let r=[];for(let e in this.uniforms){let t=this.getName(e);t&&r.push(t)}return r}},nt=class extends Sr{constructor(e,t,o,i,s,a,l){super(e,t,o,i);this.color=s;this.mode=a;this.alpha=l}},Ln=class extends Sr{constructor(e,t,o,i,s){super(e,t,o,i);this.position=s}},wr=class extends Sr{constructor(e,t,o,i){super("light",e,t,{alpha:i.shadingAlpha,mode:i.shadingBlend});this.data=o;this.node=i}static createLigherLayer(e,t,o,i){let s,a=new W(o.alpha),l=new ge(o.mode);return o.category==="lambert"?(s=new pi,s.emissive=new Ie(i.color(o.emissive)??0)):o.category==="phong"?(s=new ma,s.shininess=new W(o.shininess??30),s.specular=new Ie(i.color(o.specular)??1118481)):o.category==="toon"?(s=new hi,s.shininess=new W(o.shininess??30),s.specular=new Ie(i.color(o.specular)??1118481)):o.category==="physical"?(s=new di,s.roughness=new W(o.roughness??.3),s.metalness=new W(o.metalness??0),s.reflectivity=new W(o.reflectivity??.5)):s=new eo,s.alpha=new W(1),s.shadingAlpha=a,s.shadingBlend=l,new wr(e,t,o,s)}};function vd(n){let r=n instanceof Sr?n.type:n;return r==="texture"||r==="displace_map"||r==="matcap"}function gb(n,r,e,t){switch(n){case"color":{let o=new Ie(t.color??5855577),i=new W(t.alpha??1),s=new Ne("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )","f");s.keywords.alpha=i;let a=new ge(t.mode??0);return o.alpha=i,new nt(n,r,e,{color:o,alpha:i,mode:a},o,a,s)}case"fresnel":{let o=new Ie(t.color??16777215),i=new W(t.bias??.1),s=new W(t.scale??1),a=new W(t.intensity??2),l=new W(t.factor??1),c=new W(t.alpha??1),u=new ge(t.mode??0),m=new xi(o,i,s,a,l,c,u),p=new Ne(m.calpha,"f");return new nt(n,r,e,{color:o,bias:i,scale:s,intensity:a,factor:l,alpha:c,mode:u},m,u,p)}case"rainbow":{let o=new W(t.filmThickness??30),i=new W(t.movement??0),s=new pt(t.wavelengths??new be.Vector3(0,0,0)),a=new W(t.noiseStrength??0),l=new W(t.noiseScale??1),c=new pt(t.offset??new be.Vector3(0,0,0)),u=new W(t.alpha??1),m=new vi(o,i,s,a,l,c,u),p=new Ne(m.calpha,"f"),d=new ge(t.mode??0);return new nt(n,r,e,{filmThickness:o,movement:i,wavelengths:s,noiseStrength:a,noiseScale:l,offset:c,alpha:u,mode:d},m,d,p)}case"transmission":{let o=new W(t.thickness??10),i=new W(t.ior??1.5),s=new W(t.roughness??.5),a=new rt(t.transmissionSamplerSize??new be.Vector2(2048,2048)),l=t.transmissionSamplerMap??new be.Texture,c=t.transmissionDepthMap??new be.Texture,u=new wt(l),m=new wt(c),p=window.innerWidth,d=window.innerHeight,f=p>=d?new rt(d/p,1):new rt(1,p/d),g=new W(t.alpha??1),x=new Si(o,i,s,a,u,m,f,g),y=new Ne(x.calpha,"f"),v=new ge(t.mode??0);return new nt(n,r,e,{thickness:o,ior:i,roughness:s,transmissionSamplerSize:a,transmissionSamplerMap:u,transmissionDepthMap:m,aspectRatio:f,alpha:g,mode:v},x,v,y)}case"toon":{let o=new ge(t.positioning??0),i;t.colors?i=new Jt(t.colors.length,t.colors):(i=new Jt(10,new be.Vector4(0,0,0,1)),i.value[1]=new be.Vector4(1,1,1,1));let s;t.steps?s=new ot(t.steps.length,t.steps):(s=new ot(10,1),s.value[0]=0);let a=new pt(t.source??new be.Vector3(0,0,0)),l=new to(t.isWorldSpace??!0),c=new W(t.noiseStrength??0),u=new W(t.noiseScale??1),m=new Ht(t.shadowColor),p=new pt(t.offset??new be.Vector3(0,0,0)),d=new W(t.alpha??1),f=new Oi(o,i,s,a,l,c,u,m,p,d),g=new Ne(f.calpha,"f"),x=new ge(t.mode??0);return new nt(n,r,e,{positioning:o,colors:i,steps:s,source:a,isWorldSpace:l,noiseStrength:c,noiseScale:u,shadowColor:m,offset:p,alpha:d,mode:x},f,x,g)}case"outline":{let o=new Ie(t.outlineColor??16777215),i=new Ie(t.contourColor??16777215),s=new W(t.outlineWidth??.1),a=new W(t.contourWidth??.1),l=new W(t.outlineThreshold??.1),c=new W(t.contourThreshold??.1),u=new W(t.outlineSmoothing??.1),m=new W(t.contourFrequency??.1),p=new pt(t.contourDirections??new be.Vector3(0,1,0)),d=new to(t.positionalLines??!1),f=new to(t.compensation??!0),g=t.normalMap??new be.Texture,x=new wt(g),y=t.depthMap??new be.Texture,v=new wt(y),P=t.pixelRatio??new W(window.devicePixelRatio),S=t.resolution??new rt(new be.Vector2(1,1)),b=new W(t.alpha??1),E=new bi(o,i,s,a,l,c,u,m,p,d,f,S,x,v,P,b),w=new Ne(E.calpha,"f"),h=new ge(t.mode??0);return new nt(n,r,e,{outlineColor:o,contourColor:i,outlineWidth:s,contourWidth:a,outlineThreshold:l,contourThreshold:c,outlineSmoothing:u,contourFrequency:m,contourDirection:p,positionalLines:d,compensation:f,resolution:S,normalMap:x,depthMap:v,pixelRatio:P,alpha:b,mode:h},E,h,w)}case"depth":{let o=new ge(t.gradientType??0),i=new to(t.smooth??!1),s=new W(t.near??50),a=new W(t.far??200),l=new W(t.isVector??1),c=new W(t.isWorldSpace??0),u=new pt(t.origin??new be.Vector3),m=new pt(t.direction??new be.Vector3),p=new ge(t.num??0),d;t.colors?d=new Jt(p.value+1,t.colors):(d=new Jt(p.value+1,new be.Vector4(0,0,0,1)),d.value[1]=new be.Vector4(1,1,1,1));let f;t.steps?f=new ot(p.value+1,t.steps):(f=new ot(p.value+1,1),f.value[0]=0);let g=new W(t.alpha??1),x=new ge(t.mode??0),y=new wi(o,i,s,a,l,c,u,m,d,f,p,g),v=new Ne(y.calpha,"f");return new nt(n,r,e,{gradientType:o,smooth:i,near:s,far:a,isVector:l,isWorldSpace:c,origin:u,direction:m,colors:d,steps:f,num:p,alpha:g,mode:x},y,x,v)}case"noise":{let o=new W(t.scale??1),i=new pt(t.size??new be.Vector3(100,100,100)),s=new W(t.move??1),a=new rt(t.fA??new be.Vector2(1.7,9.2)),l=new rt(t.fB??new be.Vector2(8.3,2.8)),c=new rt(t.distortion??new be.Vector2(1,1)),u=new Ht(t.colorA),m=new Ht(t.colorB),p=new Ht(t.colorC),d=new Ht(t.colorD),f=new W(t.alpha??1),g=new ge(t.mode??0),x=new ge(t.noiseType??0),y=new yi(o,i,s,a,l,c,u,m,p,d,f,x),v=new Ne(y.calpha,"f");return new nt(n,r,e,{scale:o,size:i,move:s,fA:a,fB:l,distortion:c,colorA:u,colorB:m,colorC:p,colorD:d,alpha:f,mode:g,noiseType:x},y,g,v)}case"normal":{let o=new pt(t.cnormal??new be.Vector3(1,1,1)),i=new W(t.alpha??1),s=new ge(t.mode??0),a=new Ii(o,i),l=new Ne("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )","f");return l.keywords.alpha=i,new nt(n,r,e,{cnormal:o,alpha:i,mode:s},a,s,l)}case"gradient":{let o=new ge(t.gradientType??0),i=new to(t.smooth??!1),s;t.colors?s=new Jt(t.colors.length,t.colors):(s=new Jt(10,new be.Vector4(0,0,0,1)),s.value[1]=new be.Vector4(1,1,1,1));let a;t.steps?a=new ot(t.steps.length,t.steps):(a=new ot(10,1),a.value[0]=0);let l=new rt(t.offset??new be.Vector2(0,0)),c=new rt(t.morph??new be.Vector2(0,0)),u=new W(t.angle??0),m=new W(t.alpha??1),p=new ge(t.mode??0),d=new Ni(o,i,s,a,l,c,u,m),f=new Ne(d.calpha,"f");return new nt(n,r,e,{gradientType:o,smooth:i,colors:s,steps:a,offset:l,morph:c,angle:u,alpha:m,mode:p},d,p,f)}case"displace":{let o=new ge(t.displacementType??0);if(o.value===0){let i=new pt(t.offset??new be.Vector3(0,0,0)),s=new W(t.scale??10),a=new W(t.intensity??8),l=new W(t.movement??1),c=new W(t.alpha??1),u=new ge(t.mode??0),m=new ge(t.noiseType??0),p=new Tn(o,a,l,i,s,m);return new Ln(n,r,e,{displacementType:o,offset:i,scale:s,intensity:a,movement:l,alpha:c,mode:u,noiseType:m},p)}else{let i=t.texture??new be.Texture,s=i.matrix;t.mat&&s.copy(t.mat);let a=new W(t.intensity??8),l=new wt(i),c=new W(t.crop??0),u=new W(t.alpha??1),m=new ge(t.mode??0),p=new Tn(o,a,l,c);return new Ln(n,r,e,{displacementType:o,intensity:a,texture:l,crop:c,mat:p.mat,alpha:u,mode:m},p)}}default:{let o=new Ie(1,0,0,1),i=new W(1),s=new Ne("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )","f");s.keywords.alpha=i;let a=new ge(0);return o.alpha=i,new nt(n,r,e,{color:o,alpha:i,mode:a},o,a,s)}}}function yb(n,r,e,t){let o=md(e,t);return gb(e.type,n,r,o)}function Wl(n,r,e){if(e.type==="displace"&&(n==="intensity"||n==="visible")){let t=r.uniforms[`f${r.id}_intensity`];return t?(t.value=e.intensity*(e.visible?1:0),t):void 0}if(e.type!=="displace"&&(n==="alpha"||n==="visible")){let t=r.uniforms[`f${r.id}_alpha`];if(!t)return;if(t.value=e.alpha*(e.visible?1:0),e.type==="outline"&&n=="visible"){let o=r.uniforms[`f${r.id}_compensation`];o&&(o.value=e.compensation&&e.visible)}return t}}var Zt=class extends fa.ShaderMaterial{constructor(e,t){super(void 0);this.data=e;this.layerIdGen=0;this.type="NodeMaterial";this.uniformsBackup={};this.fog=!0,this.updaters=[],this.dithering=!0,this.vertexColors=!0,this.onBeforeCompile=this._onBeforeCompile;let o=e.layers??_r.defaultTwoLayerData("phong").layers;this.layers=o.map(i=>Sr.create(this.layerIdGen++,i.id,i.data,t)),this.layers.reverse(),this.name=e.name??"Untitled Material",this.onUpdate(t)}get fragment(){return this.lightLayer.node}get category(){return this.lightLayer.data.category}getLayersOfType(e){return this.layers.filter(t=>t.type===e)}getLayerByUuid(e){return this.layers.find(t=>t.uuid===e)}onUpdate(e){this.lightLayer=this.layers.find(t=>t instanceof wr),this.lightLayer===void 0&&(this.lightLayer=new wr(0,"",Xr.defaultData("light","basic"),new eo)),this.lightLayer.node instanceof eo||(this.lightLayer.node.penumbraSize=e.penumbraSizeNode),this.dispose(),this.needsUpdate=!0,this.blendColors(),this.blendAfterColors(),this.blendPositions()}updateByOp(e,t,o){if(this.data=t,e.path[0]==="layers"){let i=e.path[1];if(i===void 0){if(this.layers.reverse(),e.type===4){let s=Sr.create(this.layerIdGen++,e.id,e.data,o);this.layers.splice(e.localIndex,0,s)}else if(e.type===5)this.layers.splice(e.localIndex,1)[0].dispose();else if(e.type===6){let s=this.layers.findIndex(l=>l.uuid===e.id),a=this.layers[s];this.layers.splice(s,1),this.layers.splice(e.localIndex,0,a)}this.layers.reverse(),this.onUpdate(o)}else{let s=this.layers.find(a=>a.uuid===i);if(s){let a=t.layers.data(i);if(s.updateByOp({...e,path:e.path.slice(2)},a,o)){let c=Sr.create(this.layerIdGen++,i,a,o);this.layers.splice(this.layers.findIndex(u=>u.uuid===i),1,c),this.onUpdate(o)}}}}}blendColors(){let e=this.layers.findIndex(o=>o instanceof nt),t=this.layers.findIndex(o=>o instanceof wr);if(e!==-1&&e<t){let o=this.layers[e].color;for(let i=e+1;i<t;++i){let s=this.layers[i];s instanceof nt&&(o=new Ti(o,s.color,s.alpha,s.mode))}this.fragment.color=o}else this.fragment.color=void 0}blendAfterColors(){let e=new Ne("outgoingLight","f"),t=this.layers.findIndex(o=>o instanceof wr);if(this.layers.length>t+1){for(let o=t+1;o<this.layers.length;++o){let i=this.layers[o];i instanceof nt&&(e=new Ti(e,i.color,i.alpha,i.mode))}this.fragment.afterColor=e}else this.fragment.afterColor=void 0}blendPositions(){let e=this.layers.filter(t=>t instanceof Ln);if(e.length>0){let t=e[0].position;for(let o=1;o<e.length;++o)e[o]&&(t=new At(t,e[o].position,At.ADD),t=new At(t,new W(.5).setReadonly(!0),At.MUL));this.fragment.position=t}else this.fragment.position=void 0}getDefines(){return this.defines}getUniforms(){return this.uniforms}getVertexShader(){return this.vertexShader}getFragmentShader(){return this.fragmentShader}_onBeforeCompile(e,t){this.build({renderer:t}),e.defines=this.defines,e.uniforms=this.uniforms,e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.extensionDerivatives=this.extensions.derivatives===!0,e.extensionFragDepth=this.extensions.fragDepth===!0,e.extensionDrawBuffers=this.extensions.drawBuffers===!0,e.extensionShaderTextureLOD=this.extensions.shaderTextureLOD===!0}clampUniformsForPreview(e,t){let o=(i,s,a)=>Math.min(Math.max(i,s),a);for(let i of this.layers)if(i.type=="displace"){this.uniformsBackup[`f${i.id}_intensity`]=i.uniforms[`f${i.id}_intensity`].value;let s=o(i.uniforms[`f${i.id}_intensity`].value,e,t);i.uniforms[`f${i.id}_intensity`].value=s}}restoreClampedUniforms(){for(let e of this.layers)e.type=="displace"&&(e.uniforms[`f${e.id}_intensity`].value=this.uniformsBackup[`f${e.id}_intensity`])}customProgramCacheKey(){return this.getHash()}updateFrame(e){for(let t=0;t<this.updaters.length;++t)e.updateNode(this.updaters[t])}build(e){e=e??{};let t=e.builder??new ua;return t.setMaterial(this,e.renderer),t.build(this.fragment,this.fragment),this.vertexShader=t.getCode("vertex"),this.fragmentShader=t.getCode("fragment"),this.defines=t.defines,this.uniforms=t.uniforms,this.extensions=t.extensions,this.updaters=t.updaters,this.fog=t.requires.fog,this.lights=t.requires.lights,this.transparent=t.requires.transparent||this.blending>fa.NormalBlending,this}dispose(){this.layers.forEach(e=>e.dispose()),super.dispose()}getHash(){let e="{";return e+='"fragment":'+this.fragment.getHash(),e+="}",e}};Object.defineProperties(Zt.prototype,{properties:{get:function(){return this.fragment.properties}},needsUpdate:{set:function(n){n===!0&&this.version++,this.needsCompile=n},get:function(){return this.needsCompile}}});var wo=class extends Zt{};var je=require("three");function bb(n,r){r.uniforms[`f${r.id}_transmissionSamplerMap`].value=n.texture,r.uniforms[`f${r.id}_transmissionDepthMap`].value=n.depthTexture}function Sb(n,r){r.uniforms[`f${r.id}_normalMap`].value=n.texture,r.uniforms[`f${r.id}_depthMap`].value=n.depthTexture}function wb(n){if(n.geometry.attributes.extrudeNormals||!n.geometry.attributes.position)return;let r=new Map,e=n.geometry.attributes.position.array,t=n.geometry.attributes.normal.array,o=new Float32Array(e.length);for(let i=0;i<e.length;i+=3){let s=`${e[i]}_${e[i+1]}_${e[i+2]}`,a=new je.Vector3(t[i],t[i+1],t[i+2]);r.has(s)?r.get(s)?.normals.push(a):r.set(s,{normals:[a],result:new je.Vector3})}r.forEach((i,s)=>{for(let a of i.normals)i.result.add(a);i.result.divideScalar(i.normals.length)});for(let i=0;i<e.length;i+=3){let s=`${e[i]}_${e[i+1]}_${e[i+2]}`,a=r.get(s)?.result;a&&(o[i]=a.x,o[i+1]=a.y,o[i+2]=a.z)}n.geometry.setAttribute("extrudeNormal",new je.Float32BufferAttribute(o,3))}function Tb(n){if(n.geometry.attributes.extrudeNormals||!n.geometry.attributes.position)return;let r=n.geometry.attributes.position.array,e=new Float32Array(r.length),t=new je.Vector3;for(let o=0;o<r.length;o+=3)t.set(r[o],r[o+1],r[o+2]).normalize(),e[o]=t.x,e[o+1]=t.y,e[o+2]=t.z;n.geometry.setAttribute("extrudeNormal",new je.Float32BufferAttribute(e,3))}function To(n){if(Array.isArray(n.material)){for(let r of n.material)if(r.getLayersOfType("outline").length===0)return}else if(n.material.getLayersOfType("outline").length===0)return;n.objectType==="Mesh2D"?Tb(n):wb(n)}function No(n){if(!n.geometry.attributes.position)return;let r=n.geometry.attributes.position.array,e=new Float32Array(r.length),t=parseInt(n.uuid.replace(/\D/g,"")),o=[je.MathUtils.seededRandom(t),je.MathUtils.seededRandom(t+1e4),je.MathUtils.seededRandom(t+2e4)];for(let i=0;i<r.length;i++)e[i]=o[i%3];n.geometry.setAttribute("randomColor",new je.BufferAttribute(e,3))}function bd(n,r,e){let t=!1,o=e.getLayersOfType("transmission"),i=e.getLayersOfType("outline");return i.length>0&&(r.layers.set(8),o.length===0&&r.layers.enable(3),t=!0,n!==void 0&&i.forEach(s=>Sb(n,s)),No(r),To(r)),o.length===0&&i.length===0&&r.layers.set(0),t}function Sd(n,r,e){if(!e.layers)return!1;let t=!1,o=e.getLayersOfType("transmission"),i=e.getLayersOfType("outline");return o.length>0&&(r.layers.set(3),i.length>0&&r.layers.enable(8),t=!0,n!==void 0&&o.forEach(s=>bb(n,s))),o.length===0&&i.length===0&&r.layers.set(0),t}function wd(n,r){let e=!1;return r.traverseEntity(t=>{if(t instanceof je.Mesh)if(Array.isArray(t.material))for(let o=0;o<t.material.length;o++)bd(n,t,t.material[o])&&(e=!0);else bd(n,t,t.material)&&(e=!0)}),e}function Td(n,r){let e=!1;return r.traverseEntity(t=>{if(t instanceof je.Mesh)if(Array.isArray(t.material))for(let o=0;o<t.material.length;o++)Sd(n,t,t.material[o])&&(e=!0);else Sd(n,t,t.material)&&(e=!0)}),e}function Nd(n){"material"in n&&Nb(n.material),"geometry"in n&&n.geometry.dispose()}function Nb(n){pc(n).forEach(r=>{r instanceof wo||r.dispose()})}var Cb=new je.Raycaster,Lb=new je.Matrix4,Ib=new je.Ray;function Cd(n,r,e){let t=n.cloner;if(t)for(let o of t.children){let i=Lb.copy(o.matrixWorld).invert(),s=Ib.copy(r.ray).applyMatrix4(i),a=n.matrixWorld;s.applyMatrix4(a);let l=Cb;l.set(s.origin,s.direction),l.near=r.near,l.far=r.far,l.intersectObject(n,!1).length>0&&e.push({object:n})}}var lt=class extends kt(ha.Mesh){constructor(e,t){super(e,t);this.isAbstractMesh=!0;this.isBooleanMesh=!1;this.booleanMeshSetAddress=-1;this.booleanWasTransformed=!1;this.booleanMatrixInvOld=new ha.Matrix4;this.booleanExclude=null;Array.isArray(t)&&e.groups.length===0&&e.addGroup(0,e.getAttribute("position").count,0)}get isGroup(){return this._cloner?.parameters.hideBase===!0}get cloner(){return this._cloner}set cloner(e){this._cloner&&this.remove(this._cloner),e&&this.add(e),this._cloner=e}updateGeometry(e){let t=this.geometry,o=Xl[t.userData.type],i=this.objectType==="NonParametric"?Object.assign({},t.userData,{geometry:t}):t.userData,s=o.build(o.normalizeInputs(e,i)),a=t.uuid;this.geometry.dispose(),this.geometry=s,this.geometry.uuid=a,this.geometry.computeBoundingSphere(),To(this),t.getAttribute("randomColor")&&No(this)}clone(e){let t=this.objectType==="NonParametric"?Object.assign({},this.geometry.userData,{geometry:this.geometry.clone()}):this.geometry.userData,o=_i(t),i=this.material;return new this.constructor(o,i).copy(this,e)}copy(e,t=!0){return super.copy(e,t),e.cloner&&(this.cloner=new xo(e,e.cloner.parameters),this.add(this.cloner)),this}setFromClonerState(e){e===null?this.cloner=void 0:(this.cloner===void 0&&(this.cloner=new xo(this)),this.cloner.fromClonerState(e))}fromState(e,t){return super.fromState(e),e.type==="Mesh"&&(this.setFromClonerState(e.cloner),this.castShadow=e.castShadow??!0,this.receiveShadow=e.receiveShadow??!0,this.booleanExclude=e.booleanExclude??null),this}freeBooleanPointer(){this.booleanMeshSetAddress!==-1&&(er.freeMeshSet(this.booleanMeshSetAddress),this.booleanMeshSetAddress=-1)}invalidateDownstreamBooleanData(e=!1){return e?this.booleanWasTransformed=!0:this.freeBooleanPointer(),fr(this.parent)?this.parent.invalidateDownstreamBooleanData():this}invalidateUpstreamBooleanData(){this.freeBooleanPointer();for(let e of this.children)dr(e)&&(e.freeBooleanPointer(),fr(e)&&e.invalidateUpstreamBooleanData())}};var Pb=new oo.Vector3(0,0,1),Ld=new oo.Vector3,Id=new oo.Vector3,Pd=new oo.Matrix3,In=class extends lt{constructor(e=bt.create({}),t){super(e,t);this.recursiveSelection=!1;this.objectType="VectorObject";this.eventDispatcher=new oo.EventDispatcher;this._onShapeUpdate=()=>{this.updateGeometry({}),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox()};this.castShadow=!0,this.receiveShadow=!0,this.forceComputeSize=!0,this.shape=e.userData.shape,this.shape.eventDispatcher?.addEventListener("update",this._onShapeUpdate)}fromState(e){return super.fromState(e),this.shape.update(),this}setHelperVisibility(){}updateGeometry(e){if(super.updateGeometry(e),"userData"in this.geometry){let t=this.geometry.userData.parameters;this.eventDispatcher.dispatchEvent({type:"geometryUpdate",parameters:t})}}setShape(e){this.shape&&this.shape.eventDispatcher?.removeEventListener("update",this._onShapeUpdate),this.shape=e,this.shape.eventDispatcher?.addEventListener("update",this._onShapeUpdate)}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),Pd.getNormalMatrix(this.matrixWorld),Ld.copy(Pb).applyMatrix3(Pd).normalize(),Id.setFromMatrixPosition(this.matrixWorld),this.shape.plane.setFromNormalAndCoplanarPoint(Ld,Id)}clone(e){let t=this.shape.clone(),o=this.material,i=this.geometry.userData,s=bt.create(Object.assign({},i,{shape:t})),a=new In(s,o).copy(this,e);return a.shape=t,t.update(),a}raycast(e,t){lt.prototype.raycast.call(this,e,t)}};function ga(n,r){return Ab(n)}function Ab(n){let r={parameters:n,type:n.type};if(n.type==="VectorGeometry"){let t=Le.createFromState(n.shape,n.width,n.height);r.shape=t}else n.type==="NonParametricGeometry"&&(n.data.groups&&n.data.groups.forEach(t=>t.materialIndex=Math.max(t.materialIndex??0,0)),r.geometry=new Ad.BufferGeometryLoader().parse(n));let e;try{e=_i(r)}catch(t){console.error(t)}if(!e){let t=Le.createFromState(rn.defaultData(),100,100);r.shape=t,e=_i(r)}return e}var me;oa.then(n=>{me=n});var Md=new Float32Array([10,10,0,-10,10,0,-10,-10,0,10,-10,0]),Od=new Uint32Array([0,1,2,3]),_d=new Uint8Array([4]),Wt=class{static build(n,r,e,t,o){let i,s,a,l=n?.phongAngle??r?.phongAngle??35;if(t===!1&&(l=-1),n.positionWASM!==void 0){e&&e!==0&&(me.free_bvh(e),me.free_subdivision_surface(e));try{i=Wt.allocate(n,o)}catch(c){console.error(c,n),i=Wt.allocate({positionWASM:Md,indexWASM:Od,verticesPerFaceWASM:_d},o)}me.set_destination_refinement_level(i,0),s=Wt.buildLevel(i,!0,l)}else i=e,n.phongAngle!==void 0&&(s=Wt.buildLevel(i,!0,l));return n.subdivisions!==void 0&&(me.set_destination_refinement_level(i,n.subdivisions),n.subdivisions>0?a=Wt.buildLevel(i,!1,l):a=null),{subdivPointer:i,originalGeometry:s,subdividedGeometry:a}}static primitiveToQuads(n,r){n.widthSegments>16&&(n.widthSegments=16),n.heightSegments>16&&(n.heightSegments=16),n.depthSegments>16&&(n.depthSegments=16),n.radialSegments>16&&(n.radialSegments=16),n.type==="DodecahedronGeometry"&&(n.detail=0);let e=n.shape!==void 0?r.geometry:ga(n),t,o,i,s;return{positions:t,triIndices:s}=Jl(e.getAttribute("position"),e.getIndex()),{indices:o,verticesPerFace:i}=Zl(t,s,e),{positions:t,indices:o,verticesPerFace:i}}static allocate(n,r){let e,t,o,i=[],s=[];n.positionWASM&&n.positionWASM.length>0?(e=n.positionWASM,t=n.indexWASM,o=n.verticesPerFaceWASM):(e=Md,t=Od,o=_d);let a=e.length,l=t.length,c=o.length,u=e.length+i.length+s.length,m=t.length+o.length,p=u*Float32Array.BYTES_PER_ELEMENT+m*Uint32Array.BYTES_PER_ELEMENT,d=u*Float32Array.BYTES_PER_ELEMENT,f=m*Uint32Array.BYTES_PER_ELEMENT,g=me._malloc(p),x=new Float32Array(me.HEAPF32.buffer,g,u),y=new Uint32Array(me.HEAPU32.buffer,g+d,m);x.set(e,0),x.set(i,e.length),x.set(s,e.length+i.length),y.set(t,0),y.set(o,t.length);let v;n?.scaleBaked?.some(S=>S!==1)&&(v=new We.Matrix4().makeScale(...n.scaleBaked)),r&&(v?v.premultiply(r):v=r);let P=v?me.alloc_subdivision_surface2(g,a,g+d,l,g+d+t.length*Uint32Array.BYTES_PER_ELEMENT,c,v.elements):me.alloc_subdivision_surface(g,a,g+d,l,g+d+t.length*Uint32Array.BYTES_PER_ELEMENT,c);return me._free(g),P}static buildLevel(n,r,e,t,o){let i=o?me.get_mesh_data2(n,r?me.Level.CONTROL:me.Level.REFINED,e,o.elements):me.get_mesh_data(n,r?me.Level.CONTROL:me.Level.REFINED,e),s=8,a=me.HEAPU32.subarray(i>>2,(i>>2)+s),l=a.subarray(4,4+4),c=0,u=me.HEAPU32[a[c]>>2],m=me.HEAPF32.subarray(u>>2,(u>>2)+l[c]);c++;let p=me.HEAPU32[a[c]>>2],d=me.HEAPF32.subarray(p>>2,(p>>2)+l[c]);c++;let f=me.HEAPU32[a[c]>>2],g=me.HEAPU32.subarray(f>>2,(f>>2)+l[c]);c++;let x=me.HEAPU32[a[c]>>2],y=me.HEAPU32.subarray(x>>2,(x>>2)+l[c]);if(c++,t===void 0){let v=new We.BufferGeometry;if(v.setIndex(new We.Uint32BufferAttribute(y,1)),v.setAttribute("position",new We.Float32BufferAttribute(m,3)),v.setAttribute("normal",new We.Float32BufferAttribute(d,3)),r){v.setAttribute("faceMap",new We.Uint32BufferAttribute(g,1));let P=new Float32Array(d.length/3*4).fill(0);v.setAttribute("color",new We.BufferAttribute(P,4))}return me.free_mesh_data(i),v.userData.type="SubdivGeometry",v}t.getAttribute("position").copyArray(m),t.getAttribute("normal").copyArray(d),t.attributes.position.needsUpdate=!0,t.attributes.normal.needsUpdate=!0,me.free_mesh_data(i)}static buildControlCageWireframe(n,r,e){let t=me.get_wireframe_data_for_base_level(n),o=4,i=me.HEAPU32.subarray(t>>2,(t>>2)+o),s=i.subarray(2,2+2),a=0,l=me.HEAPU32[i[a]>>2],c=me.HEAPF32.subarray(l>>2,(l>>2)+s[a]);a++;let u=me.HEAPU32[i[a]>>2],m=me.HEAPU32.subarray(u>>2,(u>>2)+s[a]);if(r===void 0){let p=new We.BufferGeometry;p.setAttribute("position",new We.Float32BufferAttribute(c,3));let d=new Float32Array(c.length);for(let f=0,g=c.length;f<g;)d[f++]=e.r,d[f++]=e.g,d[f++]=e.b;return p.setAttribute("color",new We.BufferAttribute(d,3)),p.setIndex(new We.Uint32BufferAttribute(m,1)),me.free_wireframe_data_for_base_level(t),p}r.getAttribute("position").copyArray(c),r.attributes.position.needsUpdate=!0,me.free_wireframe_data_for_base_level(t)}static updateCollabMesh(n,r,e){r||me.set_destination_refinement_level(n,1);let t=e?me.get_topological_data2(n,r?me.Level.CONTROL:me.Level.REFINED,e.elements):me.get_topological_data(n,r?me.Level.CONTROL:me.Level.REFINED),o=6,i=me.HEAPU32.subarray(t>>2,(t>>2)+o),s=i.subarray(3,3+3),a=0,l=me.HEAPU32[i[a]>>2],c=new Float32Array(me.HEAPF32.subarray(l>>2,(l>>2)+s[a]));a++;let u=me.HEAPU32[i[a]>>2],m=new Uint32Array(me.HEAPU32.subarray(u>>2,(u>>2)+s[a]));a++;let p=me.HEAPU32[i[a]>>2],d=new Uint8Array(me.HEAPU32.subarray(p>>2,(p>>2)+s[a]));return me.free_topological_data(t),{positions:c,indices:m,verticesPerFace:d}}};var Dd=["getX","getY","getZ"];function Jl(n,r){let e={},t=r?r.count:n.count,o=0,i=[],s=[],a=1e4;for(let c=0;c<t;c++){let u=r?r.getX(c):c,m="";for(let p=0;p<3;p++)m+=`${~~(n[Dd[p]](u)*a)},`;if(m in e)i.push(e[m]);else{for(let p=0;p<3;p++)s.push(n[Dd[p]](u));e[m]=o,i.push(o),o++}}let l=[];for(let c=0;c<i.length;c+=3)i[c]===i[c+1]||i[c]===i[c+2]||i[c+1]===i[c+2]||l.push(i[c],i[c+1],i[c+2]);return{positions:s,triIndices:l}}var ya=new We.Vector3,Yl=new We.Vector3,Kl=new We.Vector3,Ql=new We.Vector3;function Zl(n,r,e){let t=[],o=[];if(e.userData.shape!==void 0&&e.userData.parameters.depth===0&&e.userData.shape.shapeHoles.length===0){let i=e.userData.shape.extractShapePointsToFlatArray([]),s=0;for(let l=0;l<i.length;l+=2)s+=(i[l]-i[(l===0?i.length:l)-2])*(i[l+1]+i[(l===0?i.length:l)-1]);n.length=0;let a=0;if(s<0)for(let l=0;l<i.length;l+=2)n.push(i[l],i[l+1],0),t.push(a++);else for(let l=i.length-2;l>=0;l-=2)n.push(i[l],i[l+1],0),t.push(a++);return o.push(a),{indices:t,verticesPerFace:o}}for(let i=0,s=e.capStartIndex??r.length;i<s;)if(r[i+1]===r[i+3]&&r[i+2]===r[i+5]||r[i+0]===r[i+3]&&r[i+2]===r[i+4]){ya.set(n[r[i]*3],n[r[i]*3+1],n[r[i]*3+2]),Yl.set(n[r[i+1]*3],n[r[i+1]*3+1],n[r[i+1]*3+2]),Kl.set(n[r[i+4]*3],n[r[i+4]*3+1],n[r[i+4]*3+2]),Ql.set(n[r[i+5]*3],n[r[i+5]*3+1],n[r[i+5]*3+2]),Yl.sub(ya).normalize(),Kl.sub(ya).normalize(),Ql.sub(ya).normalize();let a=Yl.cross(Kl).dot(Ql);Math.abs(a)>.005?(t.push(r[i],r[i+1],r[i+2]),o.push(3),i+=3):(t.push(r[i],r[i+1],r[i+4],r[i+5]),o.push(4),i+=6)}else t.push(r[i],r[i+1],r[i+2]),o.push(3),i+=3;if(e.capStartIndex!==void 0){let i=[],s=[],a=0;for(let l=0,c=0;l<n.length;l+=3,c++)n[l+2]===0&&(i.push(c),a++),n[l+2]===e.userData.parameters.depth&&s.push(c);if(e.userData.parameters.extrudeBevelSize===0){let l=s[0];s[0]=s[1],s[1]=l}i.reverse(),t.push(...i,...s),o.push(a,a)}return{indices:t,verticesPerFace:o}}var er={};cc(er,{calcBoolean:()=>Db,calcBooleanTopological:()=>_b,freeMeshSet:()=>Gb,getMeshSet:()=>Eb,transformMeshSet:()=>Bb});var Mb,Ed=new Promise(n=>{Mb=n});var Di=require("three");var xe,Pn;Ed.then(n=>xe=n);function Ob(n,r){let e,{positions:t,triIndices:o}=Jl(n.getAttribute("position"),n.getIndex()),i;if(r){let{indices:s,verticesPerFace:a}=Zl(t,o,n);i=a.length,e=[];for(let l=0,c=0;l<i;l++){e.push(a[l]);for(let u=0;u<a[l];u++)e.push(s[c++])}}else{let s=o.length;e=Array(s+s/3),i=0;for(let a=0,l=0;l<e.length;)e[l++]=3,i++,e[l++]=o[a++],e[l++]=o[a++],e[l++]=o[a++]}return{positions:t,faceIndices:e,nFaces:i}}function Bd(n){let r=n.length,e=r*Uint32Array.BYTES_PER_ELEMENT,t=r*Float32Array.BYTES_PER_ELEMENT,o=Number.isInteger(n[0])?e:t,i=xe._malloc(o);return(Number.isInteger(n[0])?new Uint32Array(xe.HEAPU32.buffer,i,r):new Float32Array(xe.HEAPF32.buffer,i,r)).set(n,0),i}function Gd(n){switch(n){case 0:return xe.OP.UNION;case 1:return xe.OP.INTERSECTION;case 2:return xe.OP.A_MINUS_B;case 3:return xe.OP.B_MINUS_A;case 4:return xe.OP.SYMMETRIC_DIFFERENCE;case 5:return xe.OP.ALL;default:throw new Error("Unknown boolean operation "+n)}}function _b(n,r){Pn===void 0&&(Pn=xe.init_csg());let e=Bd(n),t=xe.csg_calc_topological(Pn,e,n.length,Gd(r));xe._free(e);let o=6,i=xe.HEAPU32.subarray(t>>2,(t>>2)+o),s=i.subarray(3,3+3),a=0,l=xe.HEAPU32[i[a]>>2],c=new Float32Array(xe.HEAPF32.subarray(l>>2,(l>>2)+s[a]));a++;let u=xe.HEAPU32[i[a]>>2],m=new Uint32Array(xe.HEAPU32.subarray(u>>2,(u>>2)+s[a]));a++;let p=xe.HEAPU32[i[a]>>2],d=new Uint8Array(xe.HEAPU32.subarray(p>>2,(p>>2)+s[a]));return xe.free_mesh_data(t),{positions:c,indices:m,verticesPerFace:d}}function Db(n,r,e,t){Pn===void 0&&(Pn=xe.init_csg());let o=Bd(n),i=xe.csg_calc(Pn,o,n.length,t,Gd(r));xe._free(o);let s=5,a=xe.HEAPU32.subarray(i>>2,(i>>2)+s),l=a.subarray(2,2+3),c=0,u=xe.HEAPU32[a[c]>>2],m=xe.HEAPF32.subarray(u>>2,(u>>2)+l[c]);c++;let p=xe.HEAPU32[a[c]>>2],d=xe.HEAPF32.subarray(p>>2,(p>>2)+l[c]);c++;let f=l[c];e.setAttribute("position",new Di.Float32BufferAttribute(m,3)),e.setAttribute("normal",new Di.Float32BufferAttribute(d,3));let g=xe.HEAPF32.subarray((i>>2)+5,(i>>2)+5+6);return e.boundingSphere===null&&(e.boundingSphere=new Di.Sphere),e.boundingSphere.center.set(g[0],g[1],g[2]),e.boundingSphere.radius=(g[3]**2+g[4]**2+g[5]**2)**.5,e.userData.parameters={width:g[3]*2,height:g[4]*2,depth:g[5]*2},xe.free_mesh_data(i),f}function Eb(n,r){if(xe===void 0)return-1;let e,t,o;if(r&&n.userData.positions!==void 0){let g=n.userData;o=g.verticesPerFace.length,e=g.positions,t=Array(g.verticesPerFace.reduce((x,y)=>x+y,0)+o);for(let x=0,y=0,v=0;x<g.verticesPerFace.length;x++){t[v++]=g.verticesPerFace[x];for(let P=0;P<g.verticesPerFace[x];P++)t[v++]=g.indices[y++]}}else({positions:e,faceIndices:t,nFaces:o}=Ob(n,r));let i=e.length,s=t.length,a=e.length,l=t.length,c=a*Float32Array.BYTES_PER_ELEMENT+l*Uint32Array.BYTES_PER_ELEMENT,u=a*Float32Array.BYTES_PER_ELEMENT,m=l*Uint32Array.BYTES_PER_ELEMENT,p=xe._malloc(c),d=new Float32Array(xe.HEAPF32.buffer,p,a),f=new Uint32Array(xe.HEAPU32.buffer,p+u,l);return d.set(e,0),f.set(t,0),xe.get_csg_mesh(p,i,p+u,s,o)}function Bb(n,r){xe.transform_csg_mesh(n,r.elements)}function Gb(n){xe.free_csg_mesh(n)}var Xl={ConeGeometry:nm,CubeGeometry:im,CylinderGeometry:rm,DodecahedronGeometry:am,EllipseGeometry:Am,HelixGeometry:Dm,IcosahedronGeometry:Bm,LatheGeometry:Gm,NonParametricGeometry:Rm,PolygonGeometry:zm,PyramidGeometry:Vm,RectangleGeometry:Fm,SphereGeometry:jm,PlaneGeometry:Hm,BackdropGeometry:Wm,StarGeometry:qm,TextFrameGeometry:ra,TorusGeometry:Xm,TorusKnotGeometry:Km,TriangleGeometry:Qm,VectorGeometry:bt},_i=n=>Xl[n.type].create(n);var Ei=require("three");var Rd=new Ei.Matrix4;var xa=class extends lt{constructor(e=new Ei.BufferGeometry,t){super(e,t);this.booleanOp=2;this.phongAngle=35;this.meshSetAddresses=[];this.needsTransformForDownstream=!1;this.isBooleanMesh=!0,this.castShadow=!0,this.receiveShadow=!0,this.geometry.userData.parameters={width:0,height:0,depth:0},this.onAfterRender=this.recomputeBoolean.bind(this)}reInit(){this.isBooleanMesh=!0,this.meshSetAddresses=[],this.needsTransformForDownstream=!1,this.geometry.userData.parameters={width:0,height:0,depth:0},this.onAfterRender=this.recomputeBoolean.bind(this)}recomputeBoolean(e){if(this.booleanMeshSetAddress!==-1)return;for(let o=0;o<this.children.length;o++){let i=this.children[o];fr(i)&&i.recomputeBoolean(e===!0)}this.meshSetAddresses=[];for(let o=0;o<this.children.length;o++){let i=this.children[o];if(od(i)&&i.booleanExclude===!1&&i.geometry.attributes.position?.count>0&&i.geometry.drawRange.count>0){if(i.booleanMeshSetAddress===-1){if(i.booleanMeshSetAddress=er.getMeshSet(i.geometry,e===!0),i.booleanMeshSetAddress===-1)return;er.transformMeshSet(i.booleanMeshSetAddress,i.matrix),i.booleanMatrixInvOld.copy(i.matrix).invert(),i.booleanWasTransformed=!1}else fr(i)&&i.needsTransformForDownstream===!0?(er.transformMeshSet(i.booleanMeshSetAddress,i.matrix),i.needsTransformForDownstream=!1):i.booleanWasTransformed===!0&&(Rd.multiplyMatrices(i.matrix,i.booleanMatrixInvOld),er.transformMeshSet(i.booleanMeshSetAddress,Rd),i.booleanMatrixInvOld.copy(i.matrix).invert(),i.booleanWasTransformed=!1);this.meshSetAddresses.push(i.booleanMeshSetAddress)}}if(this.meshSetAddresses.length===0){this.geometry.setDrawRange(0,0);return}if(e===!0)return er.calcBooleanTopological(this.meshSetAddresses,this.booleanOp);let t=this.geometry;t.dispose(),this.geometry=new Ei.BufferGeometry,this.geometry.userData=t.userData,this.geometry.boundingSphere=t.boundingSphere;try{this.booleanMeshSetAddress=er.calcBoolean(this.meshSetAddresses,this.booleanOp,this.geometry,this.phongAngle)}catch(o){this.booleanMeshSetAddress=0,console.error(o)}this.booleanMatrixInvOld.copy(this.matrix).invert(),this.needsTransformForDownstream=!0,To(this),No(this)}updateGeometry(e){let t=e.parameters;t.operation!==void 0&&(this.booleanOp=t.operation),t.phongAngle!==void 0&&(this.phongAngle=t.phongAngle),this.invalidateDownstreamBooleanData().recomputeBoolean()}};var Re=require("three");var zd=require("three"),Tr=n=>{var r;return r=class extends n{constructor(){super(...arguments);this.isObjectHelper=!0}},r.geometryHelper=new zd.BoxBufferGeometry(30,30,30),r};var mt=require("three");var gt=require("three"),va=new gt.Ray,ec=new gt.Sphere,Vd=new gt.Matrix4,Nr=(n,r,e,t,o=!1)=>{let i=r,s=n.matrixWorld;if(i.boundingSphere===null&&i.computeBoundingSphere(),ec.copy(i.boundingSphere),ec.applyMatrix4(s),e.ray.intersectsSphere(ec)===!1||(Vd.copy(s).invert(),va.copy(e.ray).applyMatrix4(Vd),i.boundingBox!==null&&va.intersectsBox(i.boundingBox)===!1))return;let a,l,c,u,m=i.index,p=i.attributes.position,d=i.drawRange,f,g;if(o===!1){let y=Math.max(0,d.start),v=Math.min(m.count,d.start+d.count);for(f=y,g=v;f<g;f+=3)if(l=m.getX(f),c=m.getX(f+1),u=m.getX(f+2),a=x(n,e,va,p,l,c,u),a){a.faceIndex=Math.floor(f/3),t.push(a);return}}else{let v=i.attributes.position,P=new gt.Vector3,S=new gt.Vector3,b=new gt.Vector3,E=new gt.Vector3,w=2,_=1/((n.scale.x+n.scale.y+n.scale.z)/3),N=_*_,I=Math.max(0,d.start),L=Math.min(v.count,d.start+d.count);for(let A=I,k=L-1;A<k;A+=w){if(P.fromBufferAttribute(v,A),S.fromBufferAttribute(v,A+1),va.distanceSqToSegment(P,S,E,b)>N)continue;E.applyMatrix4(n.matrixWorld);let ne=e.ray.origin.distanceTo(E);ne<e.near||ne>e.far||t.push({distance:ne,point:b.clone().applyMatrix4(n.matrixWorld),object:n})}}function x(y,v,P,S,b,E,w){let h=new gt.Vector3,_=new gt.Vector3,N=new gt.Vector3,I=new gt.Vector3,L=new gt.Vector3;if(h.fromBufferAttribute(S,b),_.fromBufferAttribute(S,E),N.fromBufferAttribute(S,w),P.intersectTriangle(h,_,N,!1,I)===null)return null;L.copy(I),L.applyMatrix4(y.matrixWorld);let k=v.ray.origin.distanceTo(L);return k<v.near||k>v.far?null:{faceIndex:1,distance:k,point:L.clone(),object:y}}};var ba=new mt.Vector3,qt=new mt.Camera,tc=class extends mt.LineSegments{constructor(e){let t=new mt.BufferGeometry,o=new mt.LineBasicMaterial({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],s=[],a={},l=new mt.Color(15711266),c=new mt.Color(15711266),u=new mt.Color(2857471);m("n1","n2",l),m("n2","n4",l),m("n4","n3",l),m("n3","n1",l),m("f1","f2",l),m("f2","f4",l),m("f4","f3",l),m("f3","f1",l),m("n1","f1",l),m("n2","f2",l),m("n3","f3",l),m("n4","f4",l),m("p","n1",c),m("p","n2",c),m("p","n3",c),m("p","n4",c),m("u1","u2",u),m("u2","u3",u),m("u3","u1",u);function m(d,f,g){p(d,g),p(f,g)}function p(d,f){i.push(0,0,0),s.push(f.r,f.g,f.b),a[d]===void 0&&(a[d]=[]),a[d].push(i.length/3-1)}t.setAttribute("position",new mt.Float32BufferAttribute(i,3)),t.setAttribute("color",new mt.Float32BufferAttribute(s,3));super(t,o);this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update()}update(){let e=this.geometry,t=this.pointMap,o=!0;qt.projectionMatrixInverse.elements=[.5112609807824982,-0,-0,-0,-0,.41421356237309503,-0,-0,-0,-0,-0,-.099999,-0,-0,-1.0000000000000002,.100001];let i=1,s=1,a=o?.8:1e-4;tr("n1",t,e,qt,-i,-s,a),tr("n2",t,e,qt,i,-s,a),tr("n3",t,e,qt,-i,s,a),tr("n4",t,e,qt,i,s,a);let l=a;tr("f1",t,e,qt,-i,-s,l),tr("f2",t,e,qt,i,-s,l),tr("f3",t,e,qt,-i,s,l),tr("f4",t,e,qt,i,s,l);let c=l,u=.5;tr("u1",t,e,qt,i*.7*u,s*1.1,c),tr("u2",t,e,qt,-i*.7*u,s*1.1,c),tr("u3",t,e,qt,0,s*(1.1+.9*u),c),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}};function tr(n,r,e,t,o,i,s){ba.set(o,i,s).unproject(t);let a=r[n];if(a!==void 0){let l=e.getAttribute("position");for(let c=0,u=a.length;c<u;c++)l.setXYZ(a[c],ba.x,ba.y,ba.z)}}var Sa=class extends Tr(tc){constructor(e){super(e);this.object=e;this.object=e,this.name=`CombinedCameraHelper: ${e.uuid}`}updateMatrixWorld(e){super.updateMatrixWorld(e),this.updateTarget()}updateTarget(){let e=this.object.getTarget();this.updateWorldMatrix(!0,!1),this.worldToLocal(e)}raycast(e,t){Nr(this.object,this.geometry,e,t,!0)}};var Fd=require("three");var An=class extends Tr(Fd.DirectionalLightHelper){constructor(e,t=15,o=10066329){super(e,t,o);this.object=e;this.added=!1;this.name=`DirectionalLightHelper: ${e.uuid}`}raycast(e,t){Nr(this.object,An.geometryHelper,e,t)}};var Ud=require("three");var Mn=class extends Tr(Ud.AxesHelper){constructor(e,t=15){super(t);this.object=e;this.object.updateMatrixWorld(),this.name=`EmptyObjectHelper: ${e.uuid}`,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}raycast(e,t){Nr(this.object,Mn.geometryHelper,e,t)}update(){}};var jd=require("three");var On=class extends Tr(jd.PointLightHelper){constructor(e,t=15,o=6710886){super(e,t,o);this.object=e;this.name=`PointLightHelper: ${e.uuid}`}raycast(e,t){Nr(this.object,On.geometryHelper,e,t)}};var Ta=require("three");var wa=class extends Tr(Ta.SpotLightHelper){constructor(e,t=6710886){super(e,t);this.object=e;this.name=`SpotLightHelper: ${e.uuid}`}raycast(e,t){Nr(this.object,wa.geometryHelper,e,t)}update(){if(this.object!==void 0){let e=wa._vector,t=this.object.distance?this.object.distance:1e3,o=t*Math.tan(this.object.angle);this.cone.scale.set(o,o,t),e.setFromMatrixPosition(this.object.target.matrixWorld),this.cone.lookAt(e);let i=this.color!==void 0?this.color:this.light.color;if(this.cone.material instanceof Array)for(let s=0,a=this.cone.material.length;s<a;s++)this.cone.material[s].color.set(i);else this.cone.material.color.set(i)}}},Bi=wa;Bi._vector=new Ta.Vector3;var Cr=(n,r)=>class extends n{constructor(){super(...arguments);this.objectHelper=new r(this);this.enableHelper=!1}set visibility(o){this.visible=o,this.setHelperVisibility(o),this.setHelperChildrenVisibility(o)}get visibility(){return this.visible}get geometryHelper(){return r.geometryHelper}setHelperVisibility(o){this.objectHelper.visible=o}setHelperChildrenVisibility(o){for(let i of this.children)Yt(i)&&i.traverseEntity(s=>{Rr(s)&&s.visible&&(s.objectHelper.visible=o)})}raycast(o,i){this.objectHelper.raycast(o,i)}fromLightState(o,i){if(this.objectType==="LightDirectional"||this.objectType==="LightPoint"||this.objectType==="LightSpot"){let s=this;o.color!==void 0&&(s.color=Ke(o.color,i)),o.intensity!==void 0&&(s.intensity=o.intensity),o.depth!==void 0&&(s.shadow.camera.far=o.depth,s.shadow.needsUpdate=!0),o.shadows!==void 0&&(this.castShadow=o.shadows),o.helper!==void 0&&(this.enableHelper=o.helper,s.gizmos.shadowmap.visible=o.helper)}return this}};var _n=new Re.Vector3,rc=new Re.Vector3,zr=class extends Cr(kt(Re.Camera),Sa){constructor(e=window.innerWidth,t=window.innerHeight,o=45,i,s=1e5){super();this.objectType="CombinedCamera";this._cameraType="OrthographicCamera";this.targetOffset=uo.DefaultTargetOffset;this.isUpVectorFlipped=!1;this.angleOffsetFromUp=0;this.width=e,this.height=t,this.orthoCamera=new Re.OrthographicCamera(e*-.5,e*.5,t*.5,t*-.5,i??-5e4,s),this.perspCamera=new Re.PerspectiveCamera(o,e/t,i??50,s),this.left=this.orthoCamera.left,this.right=this.orthoCamera.right,this.top=this.orthoCamera.top,this.bottom=this.orthoCamera.bottom,this.far=this.orthoCamera.far,this.view=this.orthoCamera.view,this.aspect=this.perspCamera.aspect,this.fov=this.perspCamera.fov,this.focus=this.perspCamera.focus,this.filmGauge=this.perspCamera.filmGauge,this.filmOffset=this.perspCamera.filmOffset,this.toOrthographic(!0)}static createFromState(e,t){let o=new zr().fromState(t);return o.enableHelper=!0,o.objectHelper.update(),o.uuid=e,o}get isPerspectiveCamera(){return this.cameraType==="PerspectiveCamera"}get isOrthographicCamera(){return!this.isPerspectiveCamera}get cameraType(){return this._cameraType}setNear(e,t){e==="PerspectiveCamera"?this.perspCamera.near=t:this.orthoCamera.near=t}setZoom(e,t){t>=0&&(e==="PerspectiveCamera"?this.perspCamera.zoom=t:this.orthoCamera.zoom=t)}set cameraType(e){e==="PerspectiveCamera"?this.toPerspective():e==="OrthographicCamera"&&this.toOrthographic()}get near(){return this._cameraType==="PerspectiveCamera"?this.perspCamera.near:this.orthoCamera.near}set near(e){this._cameraType==="PerspectiveCamera"?this.perspCamera.near=e:this.orthoCamera.near=e}get zoom(){return this._cameraType==="PerspectiveCamera"?this.perspCamera.zoom:this.orthoCamera.zoom}set zoom(e){e>=0&&(this._cameraType==="PerspectiveCamera"?this.perspCamera.zoom=e:this.orthoCamera.zoom=e)}lookAt(e){super.lookAt(e),this.getWorldPosition(_n),this.targetOffset=_n.distanceTo(e)}getTarget(e=new Re.Vector3){return this.getWorldDirection(rc),this.getWorldPosition(_n),rc.multiplyScalar(this.targetOffset),e.copy(_n).add(rc),e}getDistanceToTarget(){let e=this.getTarget();return this.getWorldPosition(_n),_n.distanceTo(e)}updateUp(){let e=this.getWorldQuaternion(new Re.Quaternion),t=new Re.Vector3(0,0,1).applyQuaternion(e),o=new Re.Vector3().copy(Re.Object3D.DefaultUp);this.isUpVectorFlipped&&o.negate(),o.applyQuaternion(e);let i=new Re.Vector3().copy(Re.Object3D.DefaultUp).projectOnPlane(t),s=new Re.Vector3().crossVectors(i,o).dot(t)>=0?1:-1;this.angleOffsetFromUp=i.angleTo(o)*s}getViewFrontToObject(e){let t=e.getWorldPosition(new Re.Vector3),i=e.getWorldDirection(new Re.Vector3).multiplyScalar(this.targetOffset);return{position:t.clone().add(i),target:t}}getViewToObject(e){let t=e.getWorldPosition(new Re.Vector3),i=this.getWorldDirection(new Re.Vector3).multiplyScalar(this.targetOffset);return{position:t.clone().sub(i),target:t}}setViewplaneSize(e,t){this.left=-e*.5,this.right=e*.5,this.top=t*.5,this.bottom=-t*.5,this.aspect=e/t,this.updateProjectionMatrix()}toOrthographic(e){this.orthoCamera.left=this.left,this.orthoCamera.right=this.right,this.orthoCamera.top=this.top,this.orthoCamera.bottom=this.bottom,this.orthoCamera.view=this.view,this.orthoCamera.far=this.far,this.orthoCamera.updateProjectionMatrix(),this.projectionMatrix=this.orthoCamera.projectionMatrix,this.projectionMatrixInverse=this.orthoCamera.projectionMatrixInverse,this._cameraType="OrthographicCamera",(this.enableHelper===!0||e===!0)&&this.objectHelper.update()}toPerspective(e){this.perspCamera.aspect=this.aspect,this.perspCamera.fov=this.fov,this.perspCamera.view=this.view,this.perspCamera.far=this.far,this.perspCamera.updateProjectionMatrix(),this.projectionMatrix=this.perspCamera.projectionMatrix,this.projectionMatrixInverse=this.perspCamera.projectionMatrixInverse,this._cameraType="PerspectiveCamera",(this.enableHelper===!0||e===!0)&&this.objectHelper.update()}setFocalLength(e){this.perspCamera.setFocalLength(e),this.toPerspective()}getFocalLength(){return this.perspCamera.getFocalLength()}getEffectiveFOV(){return this.perspCamera.getEffectiveFOV()}getFilmWidth(){return this.perspCamera.getFilmWidth()}getFilmHeight(){return this.perspCamera.getFilmHeight()}setViewOffset(e,t,o,i,s,a){this._cameraType==="PerspectiveCamera"?this.perspCamera.setViewOffset(e,t,o,i,s,a):this.orthoCamera.setViewOffset(e,t,o,i,s,a)}clearViewOffset(){this._cameraType==="PerspectiveCamera"?(this.perspCamera.clearViewOffset(),this.toPerspective()):(this.orthoCamera.clearViewOffset(),this.toOrthographic())}updateProjectionMatrix(e){this._cameraType==="PerspectiveCamera"?this.toPerspective(e):this._cameraType==="OrthographicCamera"&&this.toOrthographic(e)}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}copy(e,t){return super.copy(e,t),this.orthoCamera.copy(e.orthoCamera),this.perspCamera.copy(e.perspCamera),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.far=e.far,this.view=e.view===null?null:Object.assign({},e.view),this._cameraType=e._cameraType,this.aspect=e.aspect,this.fov=e.fov,this.focus=e.focus,this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this.targetOffset=e.targetOffset,this.updateProjectionMatrix(),this}toCameraState(e=[]){let t={type:this.cameraType,far:this.far,orthographic:{near:this.orthoCamera.near,zoom:this.orthoCamera.zoom},perspective:{near:this.perspCamera.near,fov:this.perspCamera.fov,zoom:this.perspCamera.zoom},up:this.up.toArray(),targetOffset:this.targetOffset,isUpVectorFlipped:this.isUpVectorFlipped};return Yo(t,e)}fromCameraState(e){let{orthographic:t,perspective:o}=e;return e.type!==void 0&&(this.cameraType=e.type),e.far!==void 0&&(this.far=e.far),t!==void 0&&(t.near!==void 0&&(this.orthoCamera.near=t.near),t.zoom!==void 0&&(this.orthoCamera.zoom=t.zoom)),o!==void 0&&(o.near!==void 0&&(this.perspCamera.near=o.near),o.fov!==void 0&&(this.perspCamera.fov=o.fov),o.zoom!==void 0&&(this.perspCamera.zoom=o.zoom)),e.up!==void 0&&this.up.fromArray(e.up),e.targetOffset!==void 0&&(this.targetOffset=e.targetOffset),e.isUpVectorFlipped!==void 0&&(this.isUpVectorFlipped=e.isUpVectorFlipped),this.updateProjectionMatrix(),this}toState(e){return{...super.toState(e),...this.toCameraState(e),type:this.cameraType}}fromState(e){return super.fromState(e),this.fromCameraState(e),this}};var kd=require("three");var Co=class extends Cr(kt(kd.Group),Mn){constructor(){super(...arguments);this.objectType="EmptyObject"}static createFromState(e,t){let o=new Co().fromState(t);return o.uuid=e,o.enableHelper=!0,o.objectHelper.update(),o}};var Lo=require("three");var Dn=class extends Cr(kt(Lo.DirectionalLight),An){constructor(...e){super(...e);this.objectType="LightDirectional";this._gizmos={};this.castShadow=!0,this.shadow.mapSize.width=2048,this.shadow.mapSize.height=2048,this.shadow.normalBias=1;let o=this.shadow.camera;o.top=1250,o.bottom=-1250,o.right=1250,o.left=-1250,o.near=-1e4,o.far=2500;let i=new Lo.CameraHelper(this.shadow.camera);i.visible=!1,this._gizmos.shadowmap=i,this.update()}static createFromState(e,t,o){let i=new Dn().fromState(t,o);return i.uuid=e,i}get gizmos(){return this._gizmos}showGizmos(){for(let e in this._gizmos){let t=this._gizmos[e];t instanceof Lo.CameraHelper&&(t.visible=!0)}}hideGizmos(){for(let e in this._gizmos){let t=this._gizmos[e];t instanceof Lo.CameraHelper&&(t.visible=!1)}}update(){this.shadow.camera.updateProjectionMatrix();for(let e in this._gizmos){let t=this._gizmos[e];t instanceof Lo.CameraHelper&&t.update()}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.enableHelper===!0&&this.objectHelper.visible===!0&&this.objectHelper.update()}fromDirectionalLightState(e,t){let o=e.depth!==void 0&&e.depth!==this.shadow.camera.far||e.size!==void 0&&e.size/2!==this.shadow.camera.right;return super.fromLightState(e,t),e.size!==void 0&&ed(this,e.size),e.shadowRadius!==void 0&&(this.shadow.radius=e.shadowRadius),e.shadowResolution!==void 0&&(this.shadow.mapSize.set(e.shadowResolution,e.shadowResolution),this.shadow.map&&(this.shadow.map.dispose(),this.shadow.map=null)),o&&this.update(),this}fromState(e,t){return super.fromState(e),this.fromDirectionalLightState(e,t),this}};var yt=require("three");var En=class extends Cr(kt(yt.PointLight),On){constructor(...e){super(...e);this.objectType="LightPoint";this._gizmos={};this.castShadow=!0,this.shadow.mapSize.width=1024,this.shadow.mapSize.height=1024,this.shadow.normalBias=1;let o=this.shadow.camera;o.fov=90,o.aspect=1,o.near=100,o.far=2500;let i=new yt.Vector3(-o.far+this.position.x,-o.far+this.position.y,-o.far+this.position.z),s=new yt.Vector3(o.far+this.position.x,o.far+this.position.y,o.far+this.position.z),a=new yt.Box3(i,s),l=new yt.Box3Helper(a,new yt.Color(16755200));l.visible=!1,this._gizmos.shadowmap=l,this.update()}static createFromState(e,t,o){let i=new En().fromState(t,o);return i.uuid=e,i}get gizmos(){return this._gizmos}showGizmos(){for(let e in this._gizmos){let t=this._gizmos[e];t instanceof yt.Box3Helper&&(t.visible=!0)}}hideGizmos(){for(let e in this._gizmos){let t=this._gizmos[e];t instanceof yt.Box3Helper&&(t.visible=!1)}}update(){if(this.shadow&&(this.shadow.camera.updateProjectionMatrix(),this._gizmos))for(let e in this._gizmos){let t=this._gizmos[e];if(t instanceof yt.Box3Helper){let o=this.shadow.camera,i=new yt.Vector3(-o.far+this.position.x,-o.far+this.position.y,-o.far+this.position.z),s=new yt.Vector3(o.far+this.position.x,o.far+this.position.y,o.far+this.position.z);t.box.set(i,s),t.updateMatrixWorld(!0)}}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.enableHelper===!0&&this.objectHelper.visible===!0&&this.objectHelper.update()}fromPointLightState(e,t){return super.fromLightState(e,t),e.distance!==void 0&&(this.distance=e.distance),e.decay!==void 0&&(this.decay=e.decay),e.shadowRadius!==void 0&&(this.shadow.radius=e.shadowRadius),e.shadowResolution!==void 0&&(this.shadow.mapSize.set(e.shadowResolution,e.shadowResolution),this.shadow.map&&(this.shadow.map.dispose(),this.shadow.map=null)),this}fromState(e,t){return super.fromState(e),this.fromPointLightState(e,t),this}};var Ot=require("three");var Hd=new Ot.Vector3,Wd=new Ot.Vector3,qd=new Ot.Quaternion,Bn=class extends Cr(kt(Ot.SpotLight),Bi){constructor(...e){super(...e);this.objectType="LightSpot";this._gizmos={};this.castShadow=!0,this.shadow.mapSize.width=1024,this.shadow.mapSize.height=1024,this.shadow.normalBias=1;let o=this.shadow.camera;o.fov=Ot.MathUtils.RAD2DEG*2*this.angle,o.aspect=1,o.near=100,o.far=2500;let i=new Ot.CameraHelper(this.shadow.camera);i.visible=!1,this._gizmos.shadowmap=i,this.update()}static createFromState(e,t,o){let i=new Bn().fromState(t,o);return i.uuid=e,i}get gizmos(){return this._gizmos}showGizmos(){for(let e in this._gizmos){let t=this._gizmos[e];t instanceof Ot.CameraHelper&&(t.visible=!0)}}hideGizmos(){for(let e in this._gizmos){let t=this._gizmos[e];t instanceof Ot.CameraHelper&&(t.visible=!1)}}update(){this.shadow.camera.updateProjectionMatrix();for(let e in this._gizmos){let t=this._gizmos[e];t instanceof Ot.CameraHelper&&t.update()}}updateMatrixWorld(e){super.updateMatrixWorld(e),Wd.setFromMatrixPosition(this.matrixWorld),qd.setFromRotationMatrix(this.matrixWorld),Hd.copy(this.up).applyQuaternion(qd).negate().multiplyScalar(this.distance),this.target.position.copy(Wd).add(Hd),this.target.updateMatrixWorld(),this.enableHelper===!0&&this.objectHelper.visible===!0&&this.objectHelper.update()}fromSpotLightState(e,t){return super.fromLightState(e,t),e.distance!==void 0&&(this.distance=e.distance),e.decay!==void 0&&(this.decay=e.decay),e.angle!==void 0&&(this.angle=e.angle),e.penumbra!==void 0&&(this.penumbra=e.penumbra),e.shadowRadius!==void 0&&(this.shadow.radius=e.shadowRadius),e.shadowResolution!==void 0&&(this.shadow.mapSize.set(e.shadowResolution,e.shadowResolution),this.shadow.map&&(this.shadow.map.dispose(),this.shadow.map=null)),this}fromState(e,t){return super.fromState(e),this.fromSpotLightState(e,t),this}};var $d=n=>n.tagName==="VIDEO",Gn=class{static resize(r,e,t){let o=r/e,i;if(!t.image)return;let s=t.image;$d(s)?i=s.videoWidth/s.videoHeight:i=s.width/s.height,o>i&&(t.imageType=="WEBCAM"?t.repeat.set(-1,1*i/o):t.repeat.set(1,1*i/o)),o<i&&(t.imageType=="WEBCAM"?t.repeat.set(1*o/i*-1,1):t.repeat.set(1*o/i,1)),o==i&&(t.imageType=="WEBCAM"?t.repeat.set(-1,1):t.repeat.set(1,1))}static resizeTextureLayer(r,e,t){let o=r/e,i=t.image!==void 0?t.image.width/t.image.height:1,s;o>i?s={x:1,y:i/o}:o<i?s={x:o/i,y:1}:s={x:1,y:1},t.repeat.set(s.x,s.y),t.updateMatrix()}static resizeTextureLayers(r,e,t){let o=t.layers;for(let i=0;i<o.length;i++){let s=o[i];vd(s)&&Gn.resizeTextureLayer(r,e,s.uniforms[`f${s.id}_texture`].value)}}static resizeComplex(r,e,t,o){let i=r/e,s,a=t.image;$d(a)?s=a.videoWidth/a.videoHeight:s=a.width/a.height,o.geometry.type.includes("Shape")?(i>s&&(t.imageType=="WEBCAM"?t.repeat.set(1/r*-1,1/e*s/i):t.repeat.set(1/r,1/e*s/i)),i<s&&(t.imageType=="WEBCAM"?t.repeat.set(1/r*i/s*-1,1/e):t.repeat.set(1/r*i/s,1/e)),i==s&&(t.imageType=="WEBCAM"?t.repeat.set(1/r*-1,1/e):t.repeat.set(1/r,1/e))):(i>s&&(t.imageType=="WEBCAM"?t.repeat.set(-1,1*s/i):t.repeat.set(1,1*s/i)),i<s&&(t.imageType=="WEBCAM"?t.repeat.set(1*i/s*-1,1):t.repeat.set(1*i/s,1)),i==s&&(t.imageType=="WEBCAM"?t.repeat.set(-1,1):t.repeat.set(1,1)))}};var Na=class extends lt{constructor(e,t){super(e,t);this.objectType="Mesh2D";this.castShadow=!0,this.receiveShadow=!0}updateGeometry(e){super.updateGeometry(e),this.material.layers&&Gn.resizeTextureLayers(this.geometry.userData.parameters.width,this.geometry.userData.parameters.height,this.material)}};var Rn=class extends lt{constructor(e,t){super(e,t);this.objectType="Mesh3D";this.castShadow=!0,this.receiveShadow=!0}};var Ca=class extends Rn{constructor(e,t){super(e,t);this.objectType="NonParametric"}};var $t=require("three"),Xd=require("three/examples/jsm/loaders/FontLoader.js"),qe=class extends $t.Mesh{constructor({char:e,originalChar:t,fontFamily:o,letterSpacing:i,fontSize:s,LOD:a=16},l=new $t.MeshBasicMaterial({color:0,opacity:1,visible:!0,transparent:!0,side:$t.DoubleSide})){let c=qe.loadChar(e,o,a);super(c.geometry,l);this.char=e,this.originalChar=t??e,this.fontFamily=o,this.letterSpacing=i,this.fontSize=s,this.LOD=a,this.resolution=c.resolution,this.glyphsHa=c.glyphsHa,this.localPosition=new $t.Vector2,this.charSize=0,this.geometry.userData={type:"CharacterGeometry",parameters:{char:this.char,fontFamily:this.fontFamily,letterSpacing:this.letterSpacing,fontSize:this.fontSize,lod:this.LOD,resolution:this.resolution,charSize:this.charSize,localPosition:this.localPosition}},this.updateFontSize(this.fontSize)}static get FONTS_PATH(){return qe._fontPath}static set FONTS_PATH(e){qe._fontPath=e}updatePosition(e,t){this.localPosition.copy(e);let o=new $t.Vector3(this.localPosition.x,-this.localPosition.y,0);this.position.copy(o).add(t)}updateFontSize(e){let t=e/this.resolution;this.fontSize=e,this.scale.set(this.fontSize,this.fontSize,1),this.charSize=this.glyphsHa*t*this.letterSpacing}updateFontFamily(e){if(this.fontFamily===e)return;this.fontFamily=e;let t=qe.loadChar(this.char,e,this.LOD);this.geometry=t.geometry,this.resolution=t.resolution,this.glyphsHa=t.glyphsHa,this.geometry.userData={type:"CharacterGeometry",parameters:{char:this.char,fontFamily:this.fontFamily,letterSpacing:this.letterSpacing,fontSize:this.fontSize,lod:this.LOD,resolution:this.resolution,charSize:this.charSize,localPosition:this.localPosition}},this.updateFontSize(this.fontSize)}updateChar(e){if(this.char===e)return;this.char=e;let t=qe.loadChar(e,this.fontFamily,this.LOD);this.geometry=t.geometry,this.resolution=t.resolution,this.glyphsHa=t.glyphsHa,this.geometry.userData={type:"CharacterGeometry",parameters:{char:this.char,fontFamily:this.fontFamily,letterSpacing:this.letterSpacing,fontSize:this.fontSize,lod:this.LOD,resolution:this.resolution,charSize:this.charSize,localPosition:this.localPosition}},this.updateFontSize(this.fontSize)}updateLetterSpacing(e){this.letterSpacing!==e&&(this.letterSpacing=e,this.updateFontSize(this.fontSize))}updateLOD(e){if(this.LOD===e)return;this.LOD=e;let t=qe.loadChar(this.char,this.fontFamily,this.LOD);this.geometry=t.geometry,this.resolution=t.resolution,this.glyphsHa=t.glyphsHa,this.geometry.userData={type:"CharacterGeometry",parameters:{char:this.char,fontFamily:this.fontFamily,letterSpacing:this.letterSpacing,fontSize:this.fontSize,lod:this.LOD,resolution:this.resolution,charSize:this.charSize,localPosition:this.localPosition}},this.updateFontSize(this.fontSize)}clone(){let e={char:this.char,originalChar:this.originalChar,fontFamily:this.fontFamily,letterSpacing:this.letterSpacing,fontSize:this.fontSize,LOD:this.LOD};return new qe(e).copy(this)}static loadFont(e){return new Promise(function(t,o){qe.fontCache[e]?t(qe.fontCache[e]):new Xd.FontLoader().load(qe.FONTS_PATH+e+".json",s=>{qe.fontCache[e]=s,t(s)},void 0,o)})}static loadChar(e,t,o){if(qe.charCache[e]){if(qe.charCache[e][o]&&qe.charCache[e][o].fontFamily===t)return qe.charCache[e][o]}else qe.charCache[e]={};let i=qe.fontCache[t],s=i.generateShapes(e,1);return qe.charCache[e][o]={geometry:new $t.ShapeBufferGeometry(s,o),fontFamily:t,resolution:i.data.resolution,glyphsHa:i.data.glyphs[e].ha},qe.charCache[e][o]}},rr=qe;rr.charCache={},rr.fontCache={},rr._fontPath="/_assets/_fonts/";var Lr=require("three");var oc=require("three"),La=new oc.Vector2,Io=class{constructor(r,e,t){this.message=[];this.endLine=!0;this.yLinePos=r,this.lineHeight=e,this.maxCharSize=t,this.nextChar3DPos=new oc.Vector2(0,this.yLinePos+this.maxCharSize*this.lineHeight),this.align=1}addChar3D(r,e,t=this.message.length){this.message.splice(t,0,r),r.fontSize>this.maxCharSize?(this.maxCharSize=r.fontSize,this.nextChar3DPos.y=this.yLinePos+this.maxCharSize*this.lineHeight,this.fullUpdate(e)):(r.updatePosition(this.nextChar3DPos,e),this.nextChar3DPos.x+=r.charSize)}deleteChar3D(r=this.message.length-1){let e=this.message[r];if(e)return this.message.splice(r,1),this.nextChar3DPos.x-=e.charSize,e}isEndLine(r){this.endLine=r}fullUpdate(r,e=0){this.nextChar3DPos.x=0;for(let t=e,o=this.message.length;t<o;t+=1)this.message[t].updatePosition(this.nextChar3DPos,r),this.nextChar3DPos.x+=this.message[t].charSize}checkOverFlow(r){let e,t=this.message.length-1;if(t<=0)return!1;for(;t>=0;){if(this.message[t].char!==" "){e=this.message[t];break}t-=1}return!!(t>=0&&e&&e.localPosition.x+e.charSize>r)}containSpaceOverFlow(r=this.message.length-1){for(let e=r;e>=0;e-=1)if(this.message[e].char===" ")return!0;return!1}containSpace(r=this.message.length-1){if(this.endLine)return!0;for(let e=r;e>=0;e-=1)if(this.message[e].char===" ")return!0;return!1}popWord(r=this.message.length-1){let e=[],t=!0,o;for(o=r;o>=0;o-=1)if(this.message[o].char===" "){t=!1,e.length===0&&(o-=1,e.splice(0,0,this.message[o]));break}else e.splice(0,0,this.message[o]);return t?e=[]:this.message.splice(o+1,e.length),e}getWord(r=0,e=1){let t=[],o=r;for(o=r;;o+=e){if(!this.message[o]||this.message[o].char===" "){t.length===0&&this.message[o]&&(t.push(this.message[o]),this.message.splice(o,1));break}e>0?(t.push(this.message[o]),this.message.splice(o,1),o-=e):(t.splice(0,0,this.message[o]),this.message.splice(o,1))}return t}getWordAtIndex(r){let e=[];for(let t=r;t<this.message.length&&this.message[t].char!==" ";t++)e.push(this.message[t]);for(let t=r-1;t>=0&&this.message[t].char!==" ";t--)e.splice(0,0,this.message[t]);return e}wordSize(r=0,e=-1){let t=0,o=r;for(;o>=0&&o<this.message.length;){if(this.message[o].char===" "){t===0&&(t=this.message[o].charSize);break}t+=this.message[o].charSize,o+=e}return(o<0||o>=this.message.length)&&!this.endLine?this.message[r]?this.message[r].charSize:999999999:t===0?999999999:t}spaceLeft(r){return r-this.nextChar3DPos.x}popChar(r=this.message.length-1){return this.nextChar3DPos.x-=this.message[r].charSize,this.message.splice(r,1)}isEmpty(){return!this.message.length}updateNextCharPosY(){this.nextChar3DPos.y=this.yLinePos+this.maxCharSize*this.lineHeight}updateYLinePos(r){this.yLinePos=r,this.updateNextCharPosY()}updatelineHeight(r){this.lineHeight=r,this.updateNextCharPosY()}updateFontSize(r,e=0,t=this.message.length-1){for(let o=e;o<=t;o+=1)this.message[o].updateFontSize(r);this.maxCharSize=r,this.nextChar3DPos.y=this.yLinePos+this.maxCharSize*this.lineHeight}countSpaces(){let r=0;for(let e=0;e<this.message.length;e++)this.message[e].char===" "&&(r+=1);return r}alignText(r,e,t,o,i){switch(t){case 1:this.leftAlign(r,i);break;case 3:this.centerAlign(this.spaceLeft(e),r,i);break;case 2:this.rightAlign(this.spaceLeft(e),r,i);break;case 4:this.justifyAlign(this.spaceLeft(e),r,i);break}}offsetCharacters(r,e,t){La.set(e,t);let o=this.message.length;for(let i=0;i<o;i++)this.message[i].updatePosition(this.message[i].localPosition.add(La),r)}leftAlign(r,e){this.align=1,this.offsetCharacters(r,0,e)}centerAlign(r,e,t){this.align=3,this.offsetCharacters(e,r/2,t)}rightAlign(r,e,t){this.align=2,this.offsetCharacters(e,r,t)}justifyAlign(r,e,t){if(this.align=4,this.endLine){this.offsetCharacters(e,0,t);return}let o=this.countSpaces();if(o===0){this.offsetCharacters(e,0,t);return}let i=r/o,s=0;for(let a=0;a<this.message.length;a++)this.message[a].char===" "&&(s+=i),La.set(s,t),this.message[a].updatePosition(this.message[a].localPosition.add(La),e)}clone(){let r=new Io(this.yLinePos,this.lineHeight,this.maxCharSize);r.nextChar3DPos=this.nextChar3DPos.clone(),r.align=this.align,r.endLine=this.endLine;for(let e=0;e<this.message.length;e++)r.message.push(this.message[e].clone());return r}};var nc=class extends lt{constructor(e){super(e,new Lr.MeshBasicMaterial({transparent:!0,opacity:1,visible:!1,side:Lr.DoubleSide}));this.objectType="TextFrame";this.charContainer=new Lr.Object3D,this.add(this.charContainer),this.material.visible=!1,this._geometryUserData=e.userData,this.userData.textFrame={hexColor:null,opacity:1,visible:!0,text:"",fontSize:16,lineHeight:1.5,letterSpacing:1,fontFamily:"roboto_regular",textTransform:1,horizontalAlignment:1,verticalAlignment:1,LOD:16,maxLineSize:this._geometryUserData.parameters.width,textOrigin:new Lr.Vector3(this._geometryUserData.parameters.width*-.5,this._geometryUserData.parameters.height*.5,0),textLines:[]},this.createTextLine()}static createFromState(e,t,o){let i=ra.create({parameters:{width:t.width,height:t.height}}),s=new nc(i).fromState(t,o);return s.uuid=e,s}async updateText(e){this.clearText();let t=this.userData.textFrame,o=t.fontFamily;await rr.loadFont(o),t.text=e;let i=t.textOrigin,s=new Lr.MeshBasicMaterial({visible:t.visible,transparent:!0,side:Lr.DoubleSide}),a=e.split(`
`),l=0;this.userData.textFrame.textLines=a.map((c,u)=>{let m=new Io(l,t.lineHeight,t.fontSize);return m.message=c.split("").map(p=>{let d={char:p,fontFamily:o,letterSpacing:t.letterSpacing,fontSize:t.fontSize,LOD:16},f=s.clone();f.color=t.hexColor,f.opacity=t.opacity;let g=new rr(d,f);return m.addChar3D(g,i),this.charContainer.add(g),g}),l+=m.maxCharSize*m.lineHeight,m}),this.textFullUpdate(),this.checkOverFlow()}clearText(){let e=this.userData.textFrame.textLines;for(;this.charContainer.children.length;){let t=this.charContainer.children[0];this.charContainer.remove(t)}for(;e.length;)e.pop()}raycast(e,t){let o=[];if(super.raycast(e,o),o.length>0){t.push(o[0]);return}let i=[];for(let s=0,a=this.charContainer.children.length;s<a;++s)if(this.charContainer.children[s]instanceof rr&&(e.intersectObject(this.charContainer.children[s],!1,i),i.length>0)){i[0].object=this,t.push(i[0]);return}}updateGeometry(e){let t=this.userData,o=this.geometry.userData,i=o.parameters.width,s=o.parameters.height,a=e.parameters?.width??i,l=e.parameters?.height??s,c=t.textFrame;super.updateGeometry(e),c.maxLineSize=a,c.textOrigin.set(-.5*a,.5*l,0),l!==s?(this.checkOverFlow(),this.checkCapacity()):a!==i&&(i<a?this.checkCapacity():i>a&&this.checkOverFlow())}checkOverFlow(e=0){let t=this.userData,o=t.textFrame.textOrigin,i=t.textFrame.textLines;for(let s=e;s<i.length;s++){i[s].updateYLinePos(this.getNewLinePosition(s)),i[s].fullUpdate(o);let a=[];for(;i[s].checkOverFlow(t.textFrame.maxLineSize);)i[s].containSpaceOverFlow()?a.unshift(i[s].getWord(i[s].message.length-1,-1)):a.unshift(i[s].popChar());if(a.length>0){i[s+1]===void 0?(i[s].isEndLine(!1),this.createTextLine()):i[s].endLine&&(this.createTextLine(s+1),i[s].isEndLine(!1),i[s+1].isEndLine(!0));let l=0;for(let c=0;c<a.length;c+=1)for(let u=0;u<a[c].length;u+=1)i[s+1].addChar3D(a[c][u],o,l),l+=1;i[s+1].fullUpdate(o)}i[s].fullUpdate(o)}this.textFullUpdate(e)}checkCapacity(e=0){let t=this.userData,o=t.textFrame.textOrigin,i=t.textFrame.maxLineSize,s=t.textFrame.textLines;for(let a=e;a<s.length;a+=1)if(s[a].updateYLinePos(this.getNewLinePosition(a)),s[a].fullUpdate(o),!!s[a-1])for(;!s[a-1].endLine;){let l,c=s[a-1].spaceLeft(i);if(s[a].wordSize(0,1)<=c){s[a].containSpace()?l=s[a].getWord(0,1):l=s[a].popChar(0);for(let u=0;u<l.length;u+=1)l[u]&&s[a-1].addChar3D(l[u],o)}else{s[a].isEmpty()?(s[a].endLine&&s[a-1].isEndLine(!0),s.splice(a,1),a-=1):(s[a].updateYLinePos(this.getNewLinePosition(a)),s[a].fullUpdate(o));break}}this.textFullUpdate(e)}createTextLine(e=this.userData.textFrame.textLines.length){let o=this.userData.textFrame;o.textLines.splice(e,0,new Io(this.getNewLinePosition(e),o.lineHeight,o.fontSize))}textFullUpdate(e=0){let o=this.userData.textFrame,i=o.textLines,s=this.getVerticalAlignmentOffSet();for(let a=e;a<i.length;a++)i[a].updateYLinePos(this.getNewLinePosition(a)),i[a].fullUpdate(o.textOrigin),i[a].alignText(o.textOrigin,o.maxLineSize,o.horizontalAlignment,o.verticalAlignment,s)}getVerticalAlignmentOffSet(){switch(this.userData.textFrame.verticalAlignment){case 1:return 0;case 2:return this.getRemainingVerticalSpace()/2;case 3:return this.getRemainingVerticalSpace();default:return 0}}getRemainingVerticalSpace(){let t=this.userData.textFrame.textLines;return this.geometry.userData.parameters.height-this.getNewLinePosition(t.length)}getNewLinePosition(e){let o=this.userData.textFrame.textLines,i=0;for(let s=0;s<e;s+=1)i+=o[s].maxCharSize*o[s].lineHeight;return i}updateColor(e){let t=this.userData;t.textFrame.hexColor=e;let o=t.textFrame.textLines;for(let i=0;i<o.length;i++){let s=o[i].message;for(let a=0;a<s.length;a++){let l=s[a].material;l.color?.isColor&&(l.color=e)}}}updateOpacity(e){let t=this.userData;t.textFrame.opacity=e;let o=t.textFrame.textLines;for(let i=0;i<o.length;i++){let s=o[i].message;for(let a=0;a<s.length;a++){let l=s[a].material;l.opacity=e}}}updateVisible(e){let t=this.userData;t.textFrame.visible=e;let o=t.textFrame.textLines;for(let i=0;i<o.length;i++){let s=o[i].message;for(let a=0;a<s.length;a++){let l=s[a].material;l.visible=e}}}async updateFontFamily(e){await rr.loadFont(e);let o=this.userData.textFrame,i=o.textLines;o.fontFamily=e;for(let s=0;s<i.length;s++){let a=i[s].message;for(let l=0;l<a.length;l++)a[l].updateFontFamily(e)}this.textFullUpdate(),this.checkOverFlow(),this.checkCapacity()}updateFontSize(e){let o=this.userData.textFrame,i=o.textLines,s=o.fontSize;o.fontSize=e;for(let a=0;a<i.length;a++)i[a].updateFontSize(e);this.textFullUpdate(),e>s?this.checkOverFlow():e<s&&this.checkCapacity()}async updateTextTransform(e){let o=this.userData.textFrame;await rr.loadFont(o.fontFamily);let i=o.textLines;switch(o.textTransform=e,e){case 2:for(let s=0;s<i.length;s++){let a=i[s].message;for(let l=0;l<a.length;l++)i[s].message[l].updateChar(a[l].char.toUpperCase())}break;case 3:for(let s=0;s<i.length;s++){let a=i[s].message;for(let l=0;l<a.length;l++)i[s].message[l].updateChar(a[l].char.toLowerCase())}break;default:for(let s=0;s<i.length;s++){let a=i[s].message;for(let l=0;l<a.length;l++)i[s].message[l].updateChar(a[l].originalChar)}}this.textFullUpdate(),this.checkOverFlow(),this.checkCapacity()}updateLetterSpacing(e){let t=this.userData,o=t.textFrame.textLines;t.textFrame.letterSpacing=e;for(let i=0;i<o.length;i++){let s=o[i].message;for(let a=0;a<s.length;a++)s[a].updateLetterSpacing(e)}this.textFullUpdate(),this.checkOverFlow(),this.checkCapacity()}updateLOD(e){let t=this.userData;t.textFrame.LOD=e;let o=t.textFrame.textLines;for(let i=0;i<o.length;i++);this.textFullUpdate(),this.checkOverFlow(),this.checkCapacity()}updateLineHeight(e){let t=this.userData,o=t.textFrame.textLines;t.textFrame.lineHeight=e;for(let i=0;i<o.length;i++)o[i].updatelineHeight(e);this.textFullUpdate()}updateVerticalAlignment(e){let t=this.userData;t.textFrame.verticalAlignment=e,this.textFullUpdate()}updateHorizontalAlignment(e){let t=this.userData;t.textFrame.horizontalAlignment=e,this.textFullUpdate()}fromTextFrameData(e,t){if(e.color!==void 0){let o=Ke(e.color,t);this.updateColor(o),this.updateOpacity(o.a)}e.alpha!==void 0&&this.updateOpacity(e.alpha),e.font!==void 0&&this.updateFontFamily(e.font),e.horizontalAlign!==void 0&&this.updateHorizontalAlignment(e.horizontalAlign),e.verticalAlign!==void 0&&this.updateVerticalAlignment(e.verticalAlign),e.textTransform!==void 0&&this.updateTextTransform(e.textTransform),e.fontSize!==void 0&&this.updateFontSize(e.fontSize),e.lineHeight!==void 0&&this.updateLineHeight(e.lineHeight),e.letterSpacing!==void 0&&this.updateLetterSpacing(e.letterSpacing),e.text!==void 0&&e.text!==""&&this.updateText(e.text),(e.width!==void 0||e.height!==void 0)&&this.updateGeometry({parameters:{width:e.width,height:e.height}})}fromState(e,t){return super.fromState(e),this.fromTextFrameData(e,t),this}},Po=nc;Po.VerticalAlign=nl,Po.HorizontalAlign=ol,Po.TextTransform=il;var ct=require("three");var Gi=class{constructor(r){this.deletedMaterial=new wo(_r.defaultTwoLayerData("basic"),this);this.deletedImage=new So(qs.emptyImage);this.materials={};this.images={};this.colors={};this.onImageLoad=()=>{this._onImageLoad&&this._onImageLoad()};this.transmissionRenderTarget=new ct.WebGLRenderTarget(2048,2048,{generateMipmaps:!0,minFilter:ct.LinearMipmapLinearFilter,magFilter:ct.LinearFilter,wrapS:ct.ClampToEdgeWrapping,wrapT:ct.ClampToEdgeWrapping}),this.transmissionRenderTarget.depthTexture=new ct.DepthTexture(2048,2048),this.normalRenderTarget=new ct.WebGLRenderTarget(1024,1024,{generateMipmaps:!1,minFilter:ct.NearestFilter,magFilter:ct.NearestFilter,type:ct.FloatType}),this.normalRenderTarget.depthTexture=new ct.DepthTexture(1024,1024),this.penumbraSizeNode=new ot(5,r.penumbraSize),this.resolutionNode=new rt(1,1),this.pixelRatioNode=new W(window.devicePixelRatio),this.reset(r)}setOnImageLoad(r){this._onImageLoad=r}reset(r){for(let[e,t]of Object.entries(r.images))this.addImage(e,t);for(let[e,t]of Object.entries(r.colors))this.addColor(e,t);for(let[e,t]of Object.entries(r.materials))this.addMaterial(e,new wo(t,this))}get transmissionSamplerMap(){return this.transmissionRenderTarget.texture}get transmissionDepthMap(){return this.transmissionRenderTarget.depthTexture}get normalMap(){return this.normalRenderTarget.texture}addMaterial(r,e){e.uuid=r,this.materials[r]=e}deleteMaterial(r){this.materials[r]&&(this.materials[r].dispose(),delete this.materials[r])}getMaterial(r){let e=this.materials[r];return e}getMaterialOrDeletedPlaceholder(r){return this.materials[r]??this.deletedMaterial}material(r){return typeof r=="string"?this.getMaterialOrDeletedPlaceholder(r):new Zt(r,this)}getMaterials(){return this.materials}addImage(r,e){return this.images[r]?(this.images[r].updateSrc(e.data),!0):(this.images[r]=new So(e,this.onImageLoad),!1)}deleteImage(r){this.images[r]&&delete this.images[r]}getDefaultImage(){return this.images.image_0}getImage(r){return this.images[r]??this.deletedImage}image(r){return typeof r=="string"?this.getImage(r):new Cn(r,this.onImageLoad)}getImages(){return this.images}addColor(r,e){return this.colors[r]?("a"in e?this.colors[r].setRGBA(e.r,e.g,e.b,e.a):this.colors[r].setRGBA(e.r,e.g,e.b,1),!0):("a"in e?this.colors[r]=new ro(e.r,e.g,e.b,e.a):this.colors[r]=new ro(e.r,e.g,e.b,1),!1)}updateColor(r,e){if(this.colors[r]){let t=this.colors[r];return this.colors[r].r=e.r??t.r,this.colors[r].g=e.g??t.g,this.colors[r].b=e.b??t.b,this.colors[r].a=e.a??t.a,!0}return!1}deleteColor(r){this.colors[r]&&delete this.colors[r]}getColor(r){return this.colors[r]}color(r){let e;if(typeof r=="string"){let t=this.getColor(r);t?e=t:(console.warn("Tried to create color layer params with a color key that does not exist in the assets manager"),e=new ut(0,0,0,0))}else return"a"in r?new ut(r.r,r.g,r.b,r.a):new ut(r.r,r.g,r.b,1);return e}dispose(){Object.keys(this.materials).forEach(e=>this.deleteMaterial(e)),this.transmissionRenderTarget.depthTexture.dispose(),this.transmissionRenderTarget.dispose(),this._onImageLoad=void 0}},TV=new Gi(Ws.emptyData());var Yd=require("three/examples/jsm/loaders/DRACOLoader.js");var no;function zb(){return no||(no=new Yd.DRACOLoader,no.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.2/").preload()),no.decoderPending}async function Vb(n){if(no){let r={attributeIDs:no.defaultAttributeIDs,attributeTypes:no.defaultAttributeTypes,useUniqueIDs:!1},e;try{e=await no.decodeGeometry(new Int8Array(n).buffer,r)}catch(t){console.error(t)}if(e)return{index:e.index?{array:e.index.array}:void 0,attributes:Object.entries(e.attributes).map(([t,o])=>({name:t,itemSize:o.itemSize,array:o.array}))}}return null}async function Kd(n,r){let[e,t]=Fa(Rs.deserialize(new Uint8Array(n))),o=[];e.scene.objects.traverse((i,s)=>{s.type==="Mesh"&&s.geometry.type==="NonParametricGeometry"&&s.geometry.data.draco!==void 0&&o.push(s)}),o.length&&await zb();for(let i of o){let s=await Vb(ja(i.geometry.data.draco));if(s){s.index&&(i.geometry.data.index={array:s.index.array,itemSize:1,normalized:!1,type:"Uint32Array"});let a={};s.attributes.forEach(({name:l,array:c,itemSize:u})=>{a[l]={array:c,itemSize:u,type:"Float32Array",normalized:!1}}),i.geometry.data.attributes=a,i.geometry.data.draco=void 0}}return r&&r(e),t.result().data}var zt=require("three");var Tt=require("three");var ef=Af(Jd());var ic;oa.then(n=>{ic=n});var tf=new Tt.Matrix4,Fb=new Tt.Matrix4,Ub=new Tt.Matrix4,or=new Tt.Box3,io=new Tt.Vector3,jb=new Tt.Matrix4,kb=new Tt.Matrix4,zn=class extends lt{constructor(e,t,o,i){super(o??t,i);this.subdivPointer=e;this.originalGeometry=t;this.subdividedGeometry=o;this.objectType="SubdivObject";this.hiddenMatrixOld=new Tt.Matrix4;this.smoothShading=!0;this.phongAngle=35;this.matrixWorldRigid=new Tt.Matrix4;this.castShadow=!0,this.receiveShadow=!0,this.forceComputeSize=!1}static createFromState(e,t,o){let{subdivPointer:i,originalGeometry:s,subdividedGeometry:a}=Wt.build(t.geometry,void 0,void 0,!t.flatShading),l=o.material(t.material),c=new zn(i,s,a||void 0,l);return t.geometry.phongAngle!==void 0&&(c.phongAngle=t.geometry.phongAngle),c.calcBoundingBox(),c.freeSubdivPointer(),c.uuid=e,c.fromState(t),c}buildFromStore(e,t){let{originalGeometry:o,subdividedGeometry:i,subdivPointer:s}=Wt.build(e,t,this.subdivPointer,this.smoothShading,this.shearScale);e.phongAngle!==void 0&&(this.phongAngle=e.phongAngle),this.subdivPointer=s,o!==void 0&&(this.originalGeometry?.dispose(),this.originalGeometry=o),i!==void 0&&(this.subdividedGeometry?.dispose(),this.subdividedGeometry=i??void 0),this.geometry=this.subdividedGeometry??this.originalGeometry,To(this),No(this),e.width&&(this.geometry.userData.parameters={width:e.width,height:e.height,depth:e.depth})}updateMesh(e=!1){Wt.buildLevel(this.subdivPointer,!0,this.smoothShading?this.phongAngle:-1,this.originalGeometry,e?this.shearScaleInv:void 0),this.subdividedGeometry&&Wt.buildLevel(this.subdivPointer,!1,this.smoothShading?this.phongAngle:-1,this.subdividedGeometry,e?this.shearScaleInv:void 0)}updateTopology(){this.originalGeometry.dispose(),this.originalGeometry=Wt.buildLevel(this.subdivPointer,!0,this.smoothShading?this.phongAngle:-1),this.subdividedGeometry&&(this.subdividedGeometry.dispose(),this.subdividedGeometry=Wt.buildLevel(this.subdivPointer,!1,this.smoothShading?this.phongAngle:-1)),this.geometry=this.subdividedGeometry??this.originalGeometry}raycast(e,t){this.geometry=this.originalGeometry,lt.prototype.raycast.call(this,e,t),this.geometry=this.subdividedGeometry??this.originalGeometry}updateMatrixWorldSVD(){let e=this.matrixWorld.elements,t=[[e[0],e[4],e[8]],[e[1],e[5],e[9]],[e[2],e[6],e[10]]],{u:o,v:i,q:s}=(0,ef.SVD)(t),a=tf.set(o[0][0],o[0][1],o[0][2],0,o[1][0],o[1][1],o[1][2],0,o[2][0],o[2][1],o[2][2],0,0,0,0,1),l=Fb.set(i[0][0],i[0][1],i[0][2],0,i[1][0],i[1][1],i[1][2],0,i[2][0],i[2][1],i[2][2],0,0,0,0,1),c=Ub.copy(l).transpose();this.shearScale=jb.makeScale(s[0],s[1],s[2]).multiply(c).premultiply(l),this.shearScaleInv=kb.copy(this.shearScale).invert(),this.matrixWorldRigid.multiplyMatrices(a,c),s.every(u=>Math.abs(s[0]-u)<.01)&&(this.shearScale=void 0,this.shearScaleInv=void 0)}activateSVDCompensation(){this.shearScale!==void 0&&(this.matrixAutoUpdate=!1,this.matrix.copy(this.matrixWorldRigid).copyPosition(this.matrixWorld),this.hiddenMatrixOld.copy(this.hiddenMatrix),this.hiddenMatrix.copy(this.parent.matrixWorld).invert())}deactivateSVDCompensation(){this.shearScale!==void 0&&(this.shearScale=void 0,this.shearScaleInv=void 0,this.matrixAutoUpdate=!0,this.hiddenMatrix.copy(this.hiddenMatrixOld))}calcBoundingBox(){let e=this.originalGeometry;e.boundingSphere===null&&(e.boundingSphere=new Tt.Sphere);let t=e.attributes.position,o=e.boundingSphere.center;or.setFromBufferAttribute(t),or.getCenter(o),e.boundingSphere.radius=o.distanceTo(or.max),isNaN(e.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this),or.getSize(io);let i={width:io.x,height:io.y,depth:io.z};return this.geometry.userData.parameters=i,i}updateBoundingBox(e){let t=this.originalGeometry;or.min.set(e[0],e[2],e[4]),or.max.set(e[1],e[3],e[5]),this.shearScaleInv&&(or.min.applyMatrix4(this.shearScaleInv),or.max.applyMatrix4(this.shearScaleInv)),t.boundingSphere===null&&(t.boundingSphere=new Tt.Sphere);let o=t.boundingSphere.center;or.getCenter(o),t.boundingSphere.radius=o.distanceTo(or.max),isNaN(t.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this),or.getSize(io);let i={width:io.x,height:io.y,depth:io.z};return this.geometry.userData.parameters=i,i}freeSubdivPointer(){this.subdivPointer&&(ic.free_bvh(this.subdivPointer),ic.free_subdivision_surface(this.subdivPointer),this.subdivPointer=0)}updateGeometry(e){this.geometry.userData.scale||(this.geometry.userData.scale=Array(3)),this.geometry.userData.scale[0]=this.geometry.userData.parameters.width===0?1:e.parameters.width/this.geometry.userData.parameters.width,this.geometry.userData.scale[1]=this.geometry.userData.parameters.height===0?1:e.parameters.height/this.geometry.userData.parameters.height,this.geometry.userData.scale[2]=this.geometry.userData.parameters.depth===0?1:e.parameters.depth/this.geometry.userData.parameters.depth,Zd(this.originalGeometry.attributes,...this.geometry.userData.scale),this.originalGeometry.attributes.position.needsUpdate=!0,this.originalGeometry.attributes.normal.needsUpdate=!0,this.subdividedGeometry&&(Zd(this.subdividedGeometry.attributes,...this.subdividedGeometry.userData.scale),this.subdividedGeometry.attributes.position.needsUpdate=!0,this.subdividedGeometry.attributes.normal.needsUpdate=!0),this.geometry.userData.parameters={...e.parameters}}};function Zd(n,r,e,t){let o=n.position.array,i=n.normal.array,s=tf.makeScale(r,e,t).invert().elements,a,l,c;for(var u=0,m=o.length;u<m;u+=3)o[u]*=r,o[u+1]*=e,o[u+2]*=t,a=i[u],l=i[u+1],c=i[u+2],i[u]=s[0]*a+s[4]*l+s[8]*c,i[u+1]=s[1]*a+s[5]*l+s[9]*c,i[u+2]=s[2]*a+s[6]*l+s[10]*c}var so=require("three");function rf(n,r){r.flatShading!==void 0&&(n.flatShading=r.flatShading,n.needsUpdate=!0),r.wireframe!==void 0&&(n.wireframe=r.wireframe),r.side!==void 0&&(r.side===0?n.side=so.FrontSide:r.side===1?n.side=so.BackSide:n.side=so.DoubleSide)}function Hb(n,r){if(Array.isArray(n.material))for(let e of n.material)rf(e,r);else{let e=n.material;rf(e,r)}n.objectType==="SubdivObject"&&r.flatShading!==void 0&&(n.material.flatShading=!1,n.smoothShading=!r.flatShading,n.updateMesh())}function of(n,r,e){let t;if(r.geometry.type==="SubdivGeometry")t=zn.createFromState(n,r,e);else{let o=r.geometry.type==="BooleanGeometry"?new so.BufferGeometry:ga(r.geometry,e),i="materials"in r?r.materials.map(s=>e.material(s)):e.material(r.material);js.is2DParametricMesh(o.userData.type)?t=new Na(o,i):o?.userData.type==="VectorGeometry"?t=new In(o,i):r.geometry.type==="NonParametricGeometry"?t=new Ca(o,i):r.geometry.type==="BooleanGeometry"?(t=new xa(void 0,i),t.booleanOp=r.geometry.operation,r.geometry.phongAngle!==void 0&&(t.phongAngle=r.geometry.phongAngle)):t=new Rn(o,i),t.uuid=n,t.fromState(r,e)}return Hb(t,r),t}function nf(n,r,e){return r.type==="Mesh"?of(n,r,e):r.type==="TextFrame"?Po.createFromState(n,r,e):r.type==="Empty"?Co.createFromState(n,r):r.type==="PointLight"?En.createFromState(n,r,e):r.type==="SpotLight"?Bn.createFromState(n,r,e):r.type==="DirectionalLight"?Dn.createFromState(n,r,e):Ko.is(r.type)?zr.createFromState(n,r):(console.error(r),new Co)}var sf=new zt.Vector3,sc=class extends ia(zt.Scene){constructor(e,t){super();this.objectType="Scene";this.alpha=1;this.backupFog=new zt.Fog(16777215,.1,2e3);this.fogUseBGColor=!1;this.wireframeState=!1;this.needsTransmissionDirty=!0;this.needsNormalDirty=!0;this._needsTransmission=!1;this._needsNormal=!1;this._color=new zt.Color(1,0,0);this.bgColor=new zt.Color(1,1,1);this.entityByUuid={};this.ambientLight=new zt.HemisphereLight(13882323,8553090,.75),this.ambientLight.name="Default Ambient Light",this.personalCamera=this.createPersonalCamera(),this.activeCamera=this.personalCamera,this.init(e,t)}needsTransmission(e){return this.needsTransmissionDirty&&(this._needsTransmission=Td(e,this),e!==void 0&&(this.needsTransmissionDirty=!1)),this._needsTransmission}needsNormal(e){return this.needsNormalDirty&&(this._needsNormal=wd(e,this),e!==void 0&&(this.needsNormalDirty=!1)),this._needsNormal}find(e){if(e===""||e===void 0)return;let t=this.entityByUuid[e];return t===void 0?this.getObjectByProperty("uuid",e):t}get color(){return this._color}set color(e){this.fogUseBGColor===!0&&this.backupFog.color.copy(e),this._color.copy(e)}get enableFog(){return this.fog!==null}set enableFog(e){this.fog=e===!0?this.backupFog:null}init(e,t){if(this.createChildrenObjects(e.objects,this,t),this.personalCamera.removeFromParent(),this.add(this.personalCamera),this.ambientLight.removeFromParent(),this.add(this.ambientLight),this.setBackgroundColor(Ke(e.backgroundColor,t)),this.updateFog(e.fog,t),this.updateAmbientLight(e.environment.ambientLight,t),this.activeCamera=this.personalCamera,e.publish.playCamera!==null){let o=this.find(e.publish.playCamera);o instanceof zr&&this.switchActiveCamera(o)}this.traverse(o=>{fr(o)&&o.recomputeBoolean()})}clearScene(){this.traverseEntity(e=>{Nd(e)});for(let e of this.children)Yt(e)&&e.removeFromParent()}resetAfterClear(e,t){this.init(e,t)}createPersonalCamera(){let e=zr.createFromState(sc.PERSONAL_CAMERA_ID,{...Hs.defaultData,name:"Personal Camera"});return e.enableHelper=!1,e.objectHelper.visible=!1,delete e.isEntity,this.registerObjectCreatedInLegacy(e),e}raycast(e){let t=[],o=i=>{for(let s of i.children)Yt(s)&&!s.raycastLock&&s.visible&&((dr(s)||Rr(s)&&s.enableHelper&&s.objectHelper.parent)&&(e.intersectObject(s,!1,t),Cd(s,e,t)),o(s))};return o(this),t}traverseEntity(e){for(let t of this.children)Yt(t)&&t.traverseEntity(e)}updateFog(e,t){this.enableFog=e.enabled,this.fogUseBGColor=e.useBackgroundColor,e.useBackgroundColor?this.backupFog.color.set(this.bgColor):this.backupFog.color=Ke(e.color,t),this.backupFog.near=e.near,this.backupFog.far=e.far}dispose(){this.clearScene()}updateAmbientLight(e,t){Zm(this.ambientLight,e,t),e.groundColor!==void 0&&(this.ambientLight.groundColor=Ke(e.groundColor,t)),e.enabled!==void 0&&(this.ambientLight.visible=e.enabled)}switchActiveCamera(e){this.activeCamera!==this.personalCamera&&(this.activeCamera.enableHelper=!0),this.activeCamera=e,e.enableHelper=!1}setBackgroundColor(e){this.bgColor=e,this.alpha=e.a}createChildrenObjects(e,t,o){for(let i of e)this.createChildObject(i.id,i.data,i.children,t,o)}registerObjectCreatedInLegacy(e){this.entityByUuid[e.uuid]=e}unregisterObject(e){delete this.entityByUuid[e.uuid];for(let t of e.children)this.unregisterObject(t)}createChildObject(e,t,o,i,s){let a=nf(e,t,s);return a&&(this.entityByUuid[e]=a,i.add(a),fr(i)&&dr(a)&&(a.prevBooleanObjectParent=i),this.createChildrenObjects(o,a,s)),a}getCenter(e){let t=[];for(let i=0,s=e.length;i<s;++i){let{id:a,recursive:l}=e[i],c=this.find(a),u=l?c.recursiveBBox:c.singleBBox;t.push(...u.vertices)}let o=new zt.Box3;return o.setFromPoints(t),o.getCenter(sf),sf}copyMatrixWorld(e,t){if(e===null){t.identity();return}let o=this.find(e);o?t.copy(o.matrixWorld):t.identity()}copyParentMatrixWorld(e,t){if(e===null){t.identity();return}let o=this.find(e)?.parent;o?t.copy(o.matrixWorld):t.identity()}traverseMaterial(e){this.traverseEntity(t=>{if(t instanceof lt)if(Array.isArray(t.material))for(let o=0;o<t.material.length;o++)t.material[o]instanceof Zt&&e(t.material[o]);else t.material instanceof Zt&&e(t.material)})}updateCanvasSize(e,t){this.activeCamera.setViewplaneSize(e,t);let o,i;e>=t?(o=t/e,i=1):(o=1,i=e/t),this.traverseMaterial(s=>{s.getLayersOfType("transmission").forEach(l=>{l.uniforms[`f${l.id}_aspectRatio`].value.x=o,l.uniforms[`f${l.id}_aspectRatio`].value.y=i})})}},Ri=sc;Ri.PERSONAL_CAMERA_ID="f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera";var Wb=require("three"),qb=require("three/examples/jsm/utils/BufferGeometryUtils.js");function af(n){let r;if(!!n.index)for(let e=0;e<n.index.array.length;e+=3)r=n.index.array[e],n.index.array[e]=n.index.array[e+2],n.index.array[e+2]=r}var zi=require("three");function lf(n){let r=new Set;return n.traverse(e=>{if(dr(e))if(Ye(e.material))e.material.forEach(t=>{let o=t;r.has(o)||r.add(o)});else{let t=e.material;r.has(t)||r.add(t)}}),r.forEach(e=>{if(e instanceof Array)return;let t=e.onBeforeCompile.bind(e);$b(e)?(Object.assign(e,{isMeshStandardMaterial:!0,isMeshPhysicalMaterial:!0,transmission:1,attenuationColor:new zi.Color,specularColor:new zi.Color}),e.onBeforeCompile=(o,i)=>{t&&t(o,i),o.uniforms=Object.assign(zi.ShaderLib.physical.uniforms,o.uniforms),e.getLayersOfType("transmission").forEach(s=>{o.uniforms.transmissionSamplerMap.value&&(s.uniforms["f"+s.id+"_transmissionSamplerMap"].value=o.uniforms.transmissionSamplerMap.value,s.uniforms["f"+s.id+"_transmissionSamplerSize"].value=o.uniforms.transmissionSamplerSize.value)})}):Xb(e)||(e.onBeforeCompile=(o,i)=>{t&&t(o,i),e.transparent=!1})}),n}function $b(n){return n.getLayersOfType("transmission").length>0}function Xb(n){let r=0;return n.layers.forEach(e=>{if(e.type!=="light"&&e.type!=="fresnel"){let t=e.uniforms["f"+e.id+"_alpha"];t&&(r+=(1-r)*t.value)}}),r<1}function cf(n){return n.traverse(r=>{if(r.type==="Camera"){let e=r;e.type=e.cameraType}}),n}function uf(n){let r=[],e=(t,o=0)=>{let i=o>0?t+o:t;return r.includes(i)?e(t,o+1):i};return n.traverse(t=>{if(r.includes(t.name)){let o=t.name,i=e(t.name);if(t.name=i,t.isMesh){let s=t;s.material instanceof Array?s.material.forEach(a=>{a.name=a.name.replace(o,i)}):s.material.isAsset||(s.material.name=s.material.name.replace(o,i))}}r.push(t.name)}),n}var pf=require("three/examples/jsm/utils/BufferGeometryUtils.js");function mf(n){let r=[];return n.traverse(e=>{e instanceof xo&&r.push(e)}),r.forEach(e=>{let t=e.object,o=e.children,i=o.map(a=>{a.updateMatrix();let l=a.geometry.clone().applyMatrix4(a.matrix);return a.matrix.determinant()<0&&af(l),l}),s=(0,pf.mergeBufferGeometries)(e.parameters.hideBase?i:[t.geometry,...i]);t.geometry=s,t.material=o[0].material,t.remove(e)}),n}function df(n){return n.traverse(r=>{r.matrixAutoUpdate=!0}),n}function ff(n){Object.values(n.shared.materials).forEach(r=>{ac(r)}),n.scene.objects.traverse((r,e)=>{"material"in e?ac(e.material):"materials"in e&&e.materials.forEach(t=>{ac(t)})})}function ac(n){if(typeof n=="string")return;let r=[];n.layers.forEach((e,t)=>{e.type==="outline"&&r.push(t)}),r.reverse().forEach(e=>{n.layers.delete(e)}),r.length&&console.warn("The Spline Loader currently does not support the outline layer.")}var hf="The SplineLoader only accepts .splinecode files that are generated from Spline export panel.",Pa=class extends Aa.Loader{load(r,e,t,o=console.error){let i=new Aa.FileLoader(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),r.endsWith(".spline")?console.warn(hf+" The .spline files are only meant to be used by the Editor."):r.endsWith(".splinecode")||console.warn(hf),i.load(r,async s=>{try{if(typeof s=="string")throw new Error("The .spline file is not binary!");let a=await this.parse(s);e(a)}catch(a){o(a)}},t,o)}async parse(r){let e=await Kd(r,ff),t=new Gi(e.shared);Object.values(t.getMaterials()).forEach(s=>Object.assign(s,{isAsset:!0}));let o=new Ri(e.scene,t);o.remove(o.personalCamera),e.scene.environment.ambientLight.enabled||o.remove(o.ambientLight);let i=e.scene.publish.playCamera;if(i){let s=o.find(i);s&&Jm(s)&&Object.assign(s,{makeDefault:!0})}return o=mf(o),o=lf(o),o=cf(o),o=uf(o),o=df(o),o}};
